<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2019/07/28/0.tips/8.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/07/28/0.tips/8.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>这里直接把我的一篇博客搬过来，文章最后还有一些阅读链接，能够帮助大家加深印象和理解。</p><h1 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>关键渲染路径（Critical Rendering Path）指的是：<br>「浏览器所经历的一系列步骤，从而将 HTML、CSS 和 JavaScript 转换为在屏幕上呈现的像素内容」<br>我们要做的，就是<strong>优化关键渲染路径</strong>，这样就能提高网页呈现的速度，从而使用户和老板更满意。</p><h2 id="网页生成过程"><a href="#网页生成过程" class="headerlink" title="网页生成过程"></a>网页生成过程</h2><p>说白了，「关键渲染路径」即「网页生成的过程」，简要概述就是：</p><ol><li>处理 HTML 标记并构建 DOM 树</li><li>处理 CSS 标记并构建 CSSOM 树</li><li>将 DOM 与 CSSOM 合并成一个渲染树</li><li>根据渲染树来布局，以计算每个节点的几何信息</li><li>将各个节点绘制到屏幕上</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558508180675-0ec43acd-c780-49fa-8f29-c17477193f50.png#align=left&display=inline&height=201&name=CRP.png&originHeight=489&originWidth=907&size=225950&status=done&width=372" alt="CRP.png"></p><h3 id="将-HTML-转为-DOM"><a href="#将-HTML-转为-DOM" class="headerlink" title="将 HTML 转为 DOM"></a>将 HTML 转为 DOM</h3><p>文档对象模型（DOM）存储的是「页面内容」及每个节点「属性方面的数据」。DOM 中对象之间的关系展示了父子节点以及兄弟节点。</p><p><strong>注意</strong>：<br>DOM 的构建过程是逐步实现的，意味着一旦获得了 HTML 就可以开始构建 DOM 了，<strong>不需要</strong>等待整个 HTML 页面加载完毕后再去构建 DOM 。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558509292960-a0a01043-f0a2-4125-94c7-193d3129dacc.png#align=left&display=inline&height=194&name=htmldom.png&originHeight=598&originWidth=1562&size=403495&status=done&width=507" alt="htmldom.png"></p><h3 id="将-CSS-转为-CSSOM"><a href="#将-CSS-转为-CSSOM" class="headerlink" title="将 CSS 转为 CSSOM"></a>将 CSS 转为 CSSOM</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558510890672-c939f295-fb19-431b-98ea-40361848632b.png#align=left&display=inline&height=196&name=cssom.png&originHeight=620&originWidth=1582&size=224349&status=done&width=499" alt="cssom.png"></p><h3 id="合并渲染树"><a href="#合并渲染树" class="headerlink" title="合并渲染树"></a>合并渲染树</h3><p>完成了 DOM 树和 CSSOM 树的构建以后，就要将它们合并成一个渲染树。</p><p><strong>注意：</strong><br>某些节点如果通过 CSS 隐藏，那么在渲染树中也会被忽略，例如我们在 HTML 中编写的 span 节点，它就不会出现在渲染树中。因为有一个 CSS 规则在 span 上设置了 <code>display: none</code> 属性。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558511117401-ac05e76a-37ee-408a-9923-5037fba416d7.png#align=left&display=inline&height=236&name=render-tree-construction.png&originHeight=537&originWidth=1150&size=34944&status=done&width=505" alt="render-tree-construction.png"></p><h3 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h3><p>在渲染树构建阶段，我们已经计算了哪些节点应该是可见的以及它们的计算样式，所以在布局阶段，我们就需要计算它们在设备视口内的确切位置和大小。这个过程称为布局，或者叫做重排。</p><p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。到此，浏览器对网页的第一次生成过程已经结束。</p><p>而我们的前端网站性能优化，也就是针对整个「关键渲染路径」而言的。只有<strong>最大限度的缩短上面第 1 至 5 步耗费的总时间，</strong>才能尽快的将内容渲染到屏幕上，此外还能缩短首屏的加载时间。</p><h1 id="网页加载的优化"><a href="#网页加载的优化" class="headerlink" title="网页加载的优化"></a>网页加载的优化</h1><h2 id="优化DOM"><a href="#优化DOM" class="headerlink" title="优化DOM"></a>优化DOM</h2><h3 id="压缩-删除注释"><a href="#压缩-删除注释" class="headerlink" title="压缩+删除注释"></a>压缩+删除注释</h3><p>为了将 HTML 文件尽可能快的传输给浏览器（客户端），我们需要压缩文件的大小，例如下面html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* reset */</span></span></span><br><span class="line"><span class="css">    * &#123; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">list-style</span>: none; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 正文 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码包含了非常多的注释，这些注释对开发者来说可能有用，然而浏览器在遇到注释时却会忽略它们的，所以根本没必要展示给浏览器，我们完全可以移除它们。另外空格和换行也是个大问题，它会增加我们文件的体积，所以我们需要利用一些工具去压缩它。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558517734187-b48bd1fd-7aa7-459e-b8bd-9ca705ccf3ba.png#align=left&display=inline&height=254&name=html%E5%8E%8B%E7%BC%A9.png&originHeight=818&originWidth=1108&size=103754&status=done&width=344" alt="html压缩.png"></p><p>上图是在删除掉所有注释，并使用 <a href="http://tool.chinaz.com/tools/jsformat.aspx" target="_blank" rel="noopener">在线JS压缩工具</a> 压缩后的文件大小对比。当然，这种策略同样适用于 CSS 文件，你可以使用类似的步骤对 CSS 进行注释的删除与压缩。</p><p>如果你使用 webpack 构建你的应用，你可以使用下面插件来优化html、css和js：</p><ul><li>optimize-css-assets-webpack-plugin（优化css）</li><li>html-webpack-plugin（配置与优化html）</li><li>webpack-parallel-uglify-plugin（优化js）</li></ul><h2 id="优化-CSSOM"><a href="#优化-CSSOM" class="headerlink" title="优化 CSSOM"></a>优化 CSSOM</h2><p>CSS 在默认情况下是<strong>阻塞渲染</strong>的一类资源，也就是说浏览器在 CSSOM 构建完成以前是<strong>不会渲染任何已处理</strong>的内容的，所以我们必须对 CSS 进行精简。<br>由于浏览器必须同时具有 DOM 以及 CSSOM 才能构建渲染树，所以 <strong>HTML 和 CSS 都是阻塞渲染的资源。</strong>刚才已经针对 HTML 进行了优化，现在该轮到 CSS 了。</p><h3 id="压缩-删除注释-1"><a href="#压缩-删除注释-1" class="headerlink" title="压缩+删除注释"></a>压缩+删除注释</h3><p>这一点不多赘述，参考上面html的优化步骤。</p><h3 id="内联-CSS"><a href="#内联-CSS" class="headerlink" title="内联 CSS"></a>内联 CSS</h3><p>如果你的 css 文件很小，小到仅有几十甚至几KB，那么你完全可以将 css 内联进 html ，因为相比使用 link 外链还得发一个请求，内联的代价要小的多得多。</p><h3 id="利用-Media-媒体查询"><a href="#利用-Media-媒体查询" class="headerlink" title="利用 Media 媒体查询"></a>利用 Media 媒体查询</h3><p>有时候一些 CSS 样式只在特定条件下使用，比如打印网页或者网页在大型显示器上显示时。这个时候我们的 media 媒体查询就能大显身手了，它能让这些特定的 CSS 资源不去阻塞页面的渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">media</span>=<span class="string">"(min-width: 980px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的例子在我们的项目中很常见，第一个样式表适用于所有情况，它始终会阻塞渲染。但第二个样式表则不然，它只在打印内容时适用，因此在网页首次加载时，该样式表不需要阻塞渲染。最后一个样式表声明则只在特定环境下被执行，一旦不符合最小宽度大于980px，则始终不会被加载，这样我们就又少了一个不阻塞页面渲染的 CSS 资源。</p><p><strong>注意：</strong></p><ol><li>「阻塞渲染」仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资源，只不过不阻塞渲染的资源优先级较低罢了。</li><li>CSS会造成阻塞吗？<ol><li>css 加载不会阻塞 DOM 树的解析</li><li>css 加载会阻塞 DOM 树的渲染</li><li>css 加载会阻塞后面 js 语句的执行</li><li>了解更多：<a href="https://www.cnblogs.com/chenjg/p/7126822.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjg/p/7126822.html</a></li></ol></li></ol><h2 id="优化-JavaScript"><a href="#优化-JavaScript" class="headerlink" title="优化 JavaScript"></a>优化 JavaScript</h2><p>默认情况下，无论内联还是外联，浏览器遇到文档中的 JavaScript 时都会暂停 DOM 构建，并立即开始执行 JavaScript ，等到脚本执行完毕后，再继续构建 DOM。所以为了提高页面渲染速度，我们可以让 JavaScript 异步执行。</p><h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p>这种解决方案是让脚本在网页加载完毕后再执行。当网页加载完毕后，浏览器会发出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onload" target="_blank" rel="noopener">onload</a> 事件，我们可以将 JavaScript 放进 onload 事件的回调函数中，这样当 onload 事件被触发后，就能执行我们的脚本了，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        init()</span><br><span class="line">          doSomethingElse()</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = load</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="defer-async"><a href="#defer-async" class="headerlink" title="defer / async"></a>defer / async</h3><p>我们还可以向 script 标签添加异步关键字，那样可以让浏览器在等待脚本期间不阻止 DOM 以及 CSSOM 的构建。</p><p>而关于 defer 和 async 的区别，一图胜千言：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558535926595-2bbdec2f-3ab8-4b05-a5e4-92981e15cdbd.png#align=left&display=inline&height=556&name=async-vs-defer.png&originHeight=910&originWidth=699&size=126057&status=done&width=427" alt="async-vs-defer.png"><br>（出处：<a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener">https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html</a>）</p><p>简单来说，当浏览器遇到 script 脚本的时候：</p><ol><li><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，即不等待后续载入的文档元素，读到就加载并执行。<br></li><li><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。<br></li><li><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code><br>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</li></ol><p><strong>注意：</strong><br>HTML5 规定，defer 脚本最后的延迟执行应该按照书写顺序来执行，即下面示例脚本，a.js 一定在 b.js 前面执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script defer src=<span class="string">"./js/a.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script defer src=<span class="string">"./js/b.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>但在 「JavaScript 高级程序设计（第三版）」中作者表示：</p><blockquote><p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p></blockquote><p>我个人是试验过各种浏览器的，Chrome、Firefox、Safari，没有出现作者所说的情况。所以我猜测作者写上这一句话的原因是：即使在 HTML5 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，所以为了安全起见，在开发中使用一个 defer 是非常有必要的。</p><h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>这部分内容可以点击<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="noopener">此处查看</a></p><h1 id="渲染性能的优化"><a href="#渲染性能的优化" class="headerlink" title="渲染性能的优化"></a>渲染性能的优化</h1><p>页面不仅要快速加载，而且要顺畅地运行；例如列表页的滚动应与手指的滑动一样快，侧边栏的弹出隐藏动画应如丝绸般顺滑。<br>所以除了对关键渲染路径的优化以外，我们还得确保自己编写的代码能（包括其他第三方代码）更高效地运行。</p><h2 id="像素管道"><a href="#像素管道" class="headerlink" title="像素管道"></a>像素管道</h2><p>首先我们要了解下「像素管道」的概念。像素管道是「网页从像素到屏幕」的一系列关键节点：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1558602014786-0e43f523-34f4-4806-a61b-506b8d543b7a.png#align=left&display=inline&height=84&name=%E5%83%8F%E7%B4%A0%E7%AE%A1%E9%81%93.png&originHeight=108&originWidth=835&size=70066&status=done&width=653" alt="像素管道.png"></p><ul><li>JavaScript：指的是使用 JavaScript 来实现一些视觉变化的效果。（e.g. 给页面添加 DOM 元素）</li><li>样式计算：指的是根据「匹配选择器」计算出元素所应用的 CSS 规则的过程。</li><li>布局：指的是浏览器根据元素所应用的规则计算它们要占据的空间大小及其在屏幕的位置。</li><li>绘制：指的是填充像素的过程。（e.g. 绘制文本、颜色、边框和阴影，基本上包括元素的每个可视部分）绘制一般是在多个层上完成的。</li><li>合成：由于页面的各部分可能被绘制到多层，所以它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。</li></ul><p>我们在编写代码的时候要时刻注意这五个关键节点，因为其中的每一个部分都可能为我们的应用带来“卡顿”。</p><h2 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h2><p>试想一下，假设现在浏览器正在执行有关样式方面的工作，然后出现了需要处理的 JavaScript 。这个时候浏览器会马上停下手中的活儿，转而执行插进来的 JavaScript ，然而新来的 JavaScript 是有可能导致刚才处理的样式工作重新返工的（配合上面的「管道图」来看，相当于 style 阶段完成后却执行了 JavaScript ，导致丢帧），这样一来浏览器就很有可能丢失了刚才处理完的这一帧，从而导致卡顿现象。所以没错，当你在使用 JavaScript 编写一段动画时，可以使用 RequestAnimationFrame API，该 API 能够提升我们的动画流畅度，因为它会安排 JavaScript 尽早在每一帧的开始执行，这样尽量给浏览器留出足够的时间来运行代码，然后是样式过程——&gt;布局过程——&gt;绘制过程——&gt;渲染层合并过程。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animationWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">  div.style.width = <span class="built_in">parseInt</span>(div.style.width) + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(div.style.width) &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    requestAnimationFrame(animationWidth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animationWidth);</span><br></pre></td></tr></table></figure><h2 id="避免重排与重绘"><a href="#避免重排与重绘" class="headerlink" title="避免重排与重绘"></a>避免重排与重绘</h2><h3 id="What-1"><a href="#What-1" class="headerlink" title="What"></a>What</h3><ul><li><strong>重排：</strong>当 DOM 的变化影响了元素的几何信息（DOM 对象的<strong>位置和尺寸大小</strong>），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</li><li><strong>重绘：</strong>当一个元素更改了<strong>非几何属性</strong>（e.g. 背景、文本或阴影），但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。</li></ul><h3 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="headerlink" title="浏览器的渲染队列"></a>浏览器的渲染队列</h3><p>思考以下代码将会触发几次渲染？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = '10px';</span><br><span class="line">div.style.top = '10px';</span><br><span class="line">div.style.width = '20px';</span><br><span class="line">div.style.height = '20px';</span><br></pre></td></tr></table></figure><p><br>根据我们上文的定义，这段代码理论上会触发4次重排+重绘，因为每一次都改变了元素的几何属性。但实际上最后只触发了一次重排，这都得益于浏览器的<strong>渲染队列机制</strong>：<br>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了<strong>一定的数量或者到了一定的时间间隔</strong>时，浏览器就会批量执行这些操作。</p><h4 id="强制刷新队列"><a href="#强制刷新队列" class="headerlink" title="强制刷新队列"></a>强制刷新队列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">'10px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft);</span><br><span class="line">div.style.top = <span class="string">'10px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop);</span><br><span class="line">div.style.width = <span class="string">'20px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth);</span><br><span class="line">div.style.height = <span class="string">'20px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure><p><br>这段代码会触发4次重排+重绘，因为在<code>console</code>中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。<br><strong>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘</strong>。<br><strong>强制刷新队列的style样式请求</strong>：</p><ol><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li><li>clientTop, clientLeft, clientWidth, clientHeight</li><li>getComputedStyle(), 或者 IE的 currentStyle</li></ol><p><strong>所以我们在开发中，应该谨慎的使用这些style请求，注意上下文关系，避免一行代码一个重排，这对性能是个巨大的消耗。</strong></p><h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><h4 id="分离读写操作"><a href="#分离读写操作" class="headerlink" title="分离读写操作"></a>分离读写操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">'10px'</span>;</span><br><span class="line">div.style.top = <span class="string">'10px'</span>;</span><br><span class="line">div.style.width = <span class="string">'20px'</span>;</span><br><span class="line">div.style.height = <span class="string">'20px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure><p><br>还是上面触发4次重排+重绘的代码，这次只触发了一次重排：<br>在第一个<code>console</code>的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。</p><h4 id="样式集中改变"><a href="#样式集中改变" class="headerlink" title="样式集中改变"></a>样式集中改变</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">'10px'</span>;</span><br><span class="line">div.style.top = <span class="string">'10px'</span>;</span><br><span class="line">div.style.width = <span class="string">'20px'</span>;</span><br><span class="line">div.style.height = <span class="string">'20px'</span>;</span><br></pre></td></tr></table></figure><p><br>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下。</p><p>建议通过改变 class 或者 csstext 属性集中改变样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure><h4 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发两次重排</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">'px'</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><h4 id="离线改变dom"><a href="#离线改变dom" class="headerlink" title="离线改变dom"></a>离线改变dom</h4><ul><li>隐藏要操作的dom<br>在要操作dom之前，通过 display 隐藏 dom ，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dom.display = <span class="string">'none'</span></span><br><span class="line"><span class="comment">// 修改dom样式</span></span><br><span class="line">dom.display = <span class="string">'block'</span></span><br></pre></td></tr></table></figure><ul><li>通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DocumentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 dom ，操作完成之后，再添加到文档中，这样只会触发一次重排。<br></li><li>复制节点，在副本上工作，然后替换它！</li></ul><h4 id="position属性为absolute或fixed"><a href="#position属性为absolute或fixed" class="headerlink" title="position属性为absolute或fixed"></a>position属性为absolute或fixed</h4><p>position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响</p><h4 id="优化动画"><a href="#优化动画" class="headerlink" title="优化动画"></a>优化动画</h4><ul><li>可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小<br>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：<br>比如实现一个动画，以1个像素为单位移动这样最平滑，但是 reflow 就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。<br></li><li>启用 GPU 加速<br>此部分来自<a href="http://caibaojian.com/css-reflow-repaint.html" target="_blank" rel="noopener">优化CSS重排重绘与浏览器性能</a><br><strong>GPU（图像加速器）：</strong><br>GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。<br>GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据上面的结论</span></span><br><span class="line"><span class="comment"> * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment"> * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment"> * 提高动画性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(10px, 10px, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 又或者使用 will-change 属性来创建新层 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">   <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="雅虎性能优化14条"><a href="#雅虎性能优化14条" class="headerlink" title="雅虎性能优化14条"></a>雅虎性能优化14条</h2><h3 id="1、Make-Fewer-HTTP-Requests-（尽可能减少http请求数）"><a href="#1、Make-Fewer-HTTP-Requests-（尽可能减少http请求数）" class="headerlink" title="1、Make Fewer HTTP Requests （尽可能减少http请求数）"></a>1、Make Fewer HTTP Requests （尽可能减少http请求数）</h3><p>http请求是要开销的，减少请求数可以提高网页加载速度。常用的方法，合并css，js以及 Image maps和css sprites等。（css sprites是指只用将页面上的背景图合并成一张，然后通过background-position来取背景。）</p><h3 id="2、Use-a-Content-Delivery-Network-（使用CDN-内容分发网络"><a href="#2、Use-a-Content-Delivery-Network-（使用CDN-内容分发网络" class="headerlink" title="2、Use a Content Delivery Network （使用CDN 内容分发网络)"></a>2、Use a Content Delivery Network （使用CDN 内容分发网络)</h3><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的 cache服务器内，通过DNS负载均衡(可选根据时间或访问速度来决定访问哪台服务器资源)的技术，判断用户来源就近访问cache服务器取得所需的内容。这样可以有效减少数据在网络上传输的时间，提高速度。</p><h3 id="3、Add-an-Expires-Header（添加Expires-catch-control头）"><a href="#3、Add-an-Expires-Header（添加Expires-catch-control头）" class="headerlink" title="3、Add an Expires Header（添加Expires/catch-control头）"></a>3、Add an Expires Header（添加Expires/catch-control头）</h3><p>现在越来越多的图片，脚本，css，flash被嵌入到页面中，当我们访问他们的时候势必会做许多次的http请求。其实我们可以通过设置 Expires header来缓存这些文件。Expire其实就是通过header报文来指定特定类型的文件在览器中的缓存时间。大多数的图片，flash在发布后都是不需要经常修改的，做了缓存以后这样浏览器以后就不需要再从服务器下载这些文件而是而直接从缓存中读取，这样再次访问页面的速度会大大加快。<br>不过期间也有过问题，特别是对于脚本过期时间的设置还是应该仔细考虑下，不然相应的脚本功能更新后客户端可能要过很长一段时间才能“感知”到这样的变化。所以，哪些应该缓存，哪些不该缓存还是应该仔细斟酌一番。</p><h3 id="4、Gzip-Components（启用gzip压缩）"><a href="#4、Gzip-Components（启用gzip压缩）" class="headerlink" title="4、Gzip Components（启用gzip压缩）"></a>4、Gzip Components（启用gzip压缩）</h3><p>Gzip的思想就是把文件（  html ,php, js, css, xml, txt…）先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会重新对压缩过的内容进行解压缩，并执行。</p><h3 id="5、Put-Stylesheets-at-the-Top-将css放在页面最上面"><a href="#5、Put-Stylesheets-at-the-Top-将css放在页面最上面" class="headerlink" title="5、Put Stylesheets at the Top(将css放在页面最上面)"></a>5、Put Stylesheets at the Top(将css放在页面最上面)</h3><h3 id="6、Put-Scripts-at-the-Bottom（将script放在页面最下面）"><a href="#6、Put-Scripts-at-the-Bottom（将script放在页面最下面）" class="headerlink" title="6、Put Scripts at the Bottom（将script放在页面最下面）"></a>6、Put Scripts at the Bottom（将script放在页面最下面）</h3><p>将脚本放在页面最下面的目的有那么两点： 1、因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。 所以放在页面最后，可以有效减少页面可视元素的加载时间。        2、 脚本引起的第二个问题是它阻塞并行下载数量。</p><h3 id="7、Avoid-CSS-Expressions（避免在css中使用表达式）"><a href="#7、Avoid-CSS-Expressions（避免在css中使用表达式）" class="headerlink" title="7、Avoid CSS Expressions（避免在css中使用表达式）"></a>7、Avoid CSS Expressions（避免在css中使用表达式）</h3><p>css表达是的执行次数是远远多于我们想象的，往往会严重地影响性能。而且，它只能在IE中执行。所以因尽量地避免它，其实大部分可以用js实现。</p><h3 id="8、Make-JavaScript-and-CSS-External（把javascript和css都放到外部文件中）"><a href="#8、Make-JavaScript-and-CSS-External（把javascript和css都放到外部文件中）" class="headerlink" title="8、Make JavaScript and CSS External（把javascript和css都放到外部文件中）"></a>8、Make JavaScript and CSS External（把javascript和css都放到外部文件中）</h3><p>不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。</p><h3 id="9、Reduce-DNS-Lookups（减少DNS查询）"><a href="#9、Reduce-DNS-Lookups（减少DNS查询）" class="headerlink" title="9、Reduce DNS Lookups（减少DNS查询）"></a>9、Reduce DNS Lookups（减少DNS查询）</h3><p>在Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域名数尽量控制在2-4个。</p><h3 id="10、Minify-JavaScript（压缩-JavaScript）"><a href="#10、Minify-JavaScript（压缩-JavaScript）" class="headerlink" title="10、Minify JavaScript（压缩 JavaScript）"></a>10、Minify JavaScript（压缩 JavaScript）</h3><p>压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。这点我们做得不错。常用的压缩工具有JsMin、YUI compressor等。另外像 <a href="http://dean.edwards.name/packer/" target="_blank" rel="noopener">http://dean.edwards.name/packer/</a> 还给我们提供了一个非常方便的在线压缩工具。压缩带来的一个弊端就是代码的可读性没了，但是在调试的时候，工具可以将其复原，也就是调用本地的。</p><h3 id="11、Avoid-Redirects（避免重定向）"><a href="#11、Avoid-Redirects（避免重定向）" class="headerlink" title="11、Avoid Redirects（避免重定向）"></a>11、Avoid Redirects（避免重定向）</h3><p>发生重定向的原因很多，比如跳转后面缺少 /等，每增加一次重定向就会增加一次web请求，所以因该尽量减少。</p><h3 id="12、Remove-Duplicate-Scripts-（移除重复的脚本）"><a href="#12、Remove-Duplicate-Scripts-（移除重复的脚本）" class="headerlink" title="12、Remove Duplicate Scripts （移除重复的脚本）"></a>12、Remove Duplicate Scripts （移除重复的脚本）</h3><h3 id="13、Configure-ETags（配置实体标签（ETags））"><a href="#13、Configure-ETags（配置实体标签（ETags））" class="headerlink" title="13、Configure ETags（配置实体标签（ETags））"></a>13、Configure ETags（配置实体标签（ETags））</h3><p>使用ETags减少Web应用带宽和负载</p><h3 id="14、Make-Ajax-Cacheable（使-AJAX-缓存）"><a href="#14、Make-Ajax-Cacheable（使-AJAX-缓存）" class="headerlink" title="14、Make Ajax Cacheable（使 AJAX 缓存）"></a>14、Make Ajax Cacheable（使 AJAX 缓存）</h3><p>做ajax请求的时候往往还要增加一个时间戳去避免他缓存。It’s important to remember that “asynchronous” does not imply “instantaneous”.（记住“异步”不是“瞬间”这一点很重要）。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。</p><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><ul><li><a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/" target="_blank" rel="noopener">Google Web Fundamentals - Performance</a></li><li><a href="https://www.cnblogs.com/chenjg/p/7126822.html" target="_blank" rel="noopener">css加载会造成阻塞吗？</a></li><li><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener">async vs defer attributes</a></li><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24#issuecomment-467777086" target="_blank" rel="noopener">介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack和vue面试题</title>
      <link href="/2019/07/20/0.tips/7.webpack%E5%92%8Cvue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/20/0.tips/7.webpack%E5%92%8Cvue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>下面的题目都摘自各种 webpack 面试相关的文章，我只选择了感觉很重要的一些题，想要了解更多，可以查看本文最后的参考链接。</p><h2 id="webpack-有什么用"><a href="#webpack-有什么用" class="headerlink" title="webpack 有什么用"></a>webpack 有什么用</h2><ul><li>静态资源的合并/打包/压缩</li><li>解决加载慢，错综复杂的依赖关系</li></ul><h2 id="有哪些常见-loader-和-plugin，你用过哪些"><a href="#有哪些常见-loader-和-plugin，你用过哪些" class="headerlink" title="有哪些常见 loader 和 plugin，你用过哪些"></a>有哪些常见 loader 和 plugin，你用过哪些</h2><p>loader：</p><ul><li>css：postcss-l+autoprefixer，style-l(js到&lt;style&gt;)，css-l(js中 import 的 css)，less-l，sass-l</li><li>图片/字体加载：url-loader，file-loader</li><li>图片压缩：image-webpack-loader</li><li>js：babel-loader es6转es5，eslint-loader 检查js代码</li></ul><p>plugin：</p><ul><li>webpack-dev-server 实时打包构建</li><li>html-webpack-plugin 配置启动页</li><li>clean-webpack-plugin 清理 dist 文件夹</li><li>mini-css-extract-plugin 提取css为单独文件</li><li>optimize-css-assets-webpack-plugin 压缩css</li></ul><h2 id="loader-和-plugin-的区别是什么"><a href="#loader-和-plugin-的区别是什么" class="headerlink" title="loader 和 plugin 的区别是什么"></a>loader 和 plugin 的区别是什么</h2><p>loaders 是加载器。用来处理源文件的（JSX，Scss，Less..），一次处理一个，让 webpack 有能力加载处理非js文件，plugin 是插件。并不直接操作单个文件，它直接对整个构建过程起作用。</p><h2 id="如何按需加载代码"><a href="#如何按需加载代码" class="headerlink" title="如何按需加载代码"></a>如何按需加载代码</h2><p>import(‘文件路径’).then【代码执行到时再加载】</p><h2 id="如何提高-webpack-构建速度"><a href="#如何提高-webpack-构建速度" class="headerlink" title="如何提高 webpack 构建速度"></a>如何提高 webpack 构建速度</h2><ul><li>用 webpack4</li><li>用 externals 提取常用库</li><li>提前打包第三方库：dllplugin</li><li>happypack：多线程进行打包，提升 loader 解析速度</li><li>webpack-parallel-uglify-plugin 并发压缩js，提升速度</li></ul><h2 id="如何利用-webpack-提升前端性能"><a href="#如何利用-webpack-提升前端性能" class="headerlink" title="如何利用 webpack 提升前端性能"></a>如何利用 webpack 提升前端性能</h2><ol><li>动态加载：路由懒加载【import()动态加载模块，返回结果是Promise】</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadView</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>( <span class="comment">/* webpackChunkName: "view-[request]" */</span> <span class="string">`../components/<span class="subst">$&#123;view&#125;</span>.vue`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">component</span>: loadView(<span class="string">'Home'</span>) &#125;</span><br></pre></td></tr></table></figure><ol><li>第三方依赖用 cdn（vue，vue-router，element-ui）【webpack.config.js externals】</li><li>压缩文件【uglifyjs-plugin/optimize-css-assets-plugin/image-webpack-loader】</li><li>提取公共代码【CommonChunkPlugin / splitChunksPlugin】</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/44438844" target="_blank" rel="noopener">关于webpack的面试题总结</a></li><li><a href="http://louiszhai.github.io/2019/01/04/webpack4/" target="_blank" rel="noopener">使用webpack4提升180%编译速度</a></li><li><a href="https://www.cnblogs.com/dashnowords/p/9545482.html" target="_blank" rel="noopener">webpack4.0 各个击破</a></li></ul><h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><h2 id="watch-和-computed-区别"><a href="#watch-和-computed-区别" class="headerlink" title="watch 和 computed 区别"></a>watch 和 computed 区别</h2><ul><li>watch 是监听动作，computed 是计算属性</li><li>computed 有缓存，只在属性变化的时候才去计算。watch 没缓存，只要数据变化就执行</li></ul><h2 id="讲一下-Vue-的生命周期？"><a href="#讲一下-Vue-的生命周期？" class="headerlink" title="讲一下 Vue 的生命周期？"></a>讲一下 Vue 的生命周期？</h2><p>创建期间的生命周期函数：</p><ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中。<ul><li>换句话说，此时页面中的类似  这样的语法还没有被替换成真正的数据。</li></ul></li><li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【可以获取 DOM 节点 | 发起异步请求】<ul><li>用户已经可以看到渲染好的页面了</li></ul></li></ul><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul><p>销毁期间的生命周期函数：</p><ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h3 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h3><ul><li><a href="https://segmentfault.com/a/1190000014640577" target="_blank" rel="noopener">包你理解—vue 的生命周期</a></li></ul><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><ul><li><p>父子组件</p><ul><li>父—&gt;子：prop传递值、v-on绑定方法(@子属性名=”父方法名”) | 子主动获取 this.$parent.*</li><li>子—&gt;父：子组件 this.$emit</li></ul></li><li><p>兄弟组件（非父子）【用eventBus】</p><ul><li>封装 eventVue.js export 一个新 vue 实例</li><li>监听者：VueEvent.$on(“事件名”, function(data){…})</li><li>广播者：VueEvent.$emit(“事件名”, data)</li><li>缺点：消息容易重名，同一个状态分散在不同地方，不容易管理</li></ul></li></ul><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><ul><li>v-if: 是否加载这个元素（一次性的）</li><li>v-show：控制显示方式block or none（需要切换的，侧边栏）</li></ul><p>因此：如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好</p><h2 id="数据响应式（双向绑定）怎么做到的？"><a href="#数据响应式（双向绑定）怎么做到的？" class="headerlink" title="数据响应式（双向绑定）怎么做到的？"></a>数据响应式（双向绑定）怎么做到的？</h2><p>原理：采用 数据劫持 + 发布/订阅者模式的方式</p><ul><li>创建 vm 实例时深度遍历 data 下所有属性，利用 Object.defineProperty() 把属性转为 setter，getter</li><li>在数据变动时利用消息订阅器（Dep）发消息给订阅者（Watcher），触发相应的监听回调。</li><li>创建 vm 实例时有一个指令解析的过程，会对每个元素节点的指令进行扫描和解析（e.g. v-if, v-model），根据指令模板替换数据，以及绑定相应的更新函数，并且在遇到 v-model 指令时，监听用户的输入，以便更新 data 下相应的属性。</li></ul><p>参考：</p><p><a href="https://www.cnblogs.com/kidney/p/6052935.html" target="_blank" rel="noopener">Vue.js双向绑定的实现原理</a></p><p><a href="https://www.bilibili.com/video/av16175295" target="_blank" rel="noopener">vue双向数据绑定简单实现(一)</a></p><h3 id="追问1：那如果我要监听一个对象属性的删除或添加呢？"><a href="#追问1：那如果我要监听一个对象属性的删除或添加呢？" class="headerlink" title="追问1：那如果我要监听一个对象属性的删除或添加呢？"></a>追问1：那如果我要监听一个对象属性的删除或添加呢？</h3><p>受 defineProperty 限制，Vue 无法检测对象属性的删除和添加。所以我们可以利用 Vue 提供的 <code>Vue.set</code> 来解决此问题。</p><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有一个obj:&#123;a:1&#125;，想要this.obj.b=233，不会触发视图更新</span><br><span class="line"></span><br><span class="line">Vue.set(this.obj, 'b', 233) or this.$set(this.obj, 'b', 233)</span><br></pre></td></tr></table></figure><h3 id="追问2：为什么对象属性的删除或添加无法触发页面更新"><a href="#追问2：为什么对象属性的删除或添加无法触发页面更新" class="headerlink" title="追问2：为什么对象属性的删除或添加无法触发页面更新"></a>追问2：为什么对象属性的删除或添加无法触发页面更新</h3><p>因为 vue 在实例化过程中，深度遍历了 data 下所有属性, 把属性全转为 getter/setter 。这样才能监听属性变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>当你在对象上新加了一个属性 newProperty ，当前新加的这个属性并没有加入 vue 检测数据更新的机制（因为是在初始化之后添加的）, vue.$set 是能让 vue 知道你添加了属性, 它会给你做处理。</p><h2 id="Vuex-用过吗？"><a href="#Vuex-用过吗？" class="headerlink" title="Vuex 用过吗？"></a>Vuex 用过吗？</h2><p>Vuex 是专为 Vue 应用程序开发的状态管理工具，相当于共享仓库，方便任何组件直接获取和修改。</p><ul><li>state - 数据【存项目共享状态，是响应式的，store的数据改变，所有依赖此状态的组件会更新】<ul><li>$store.state.count</li></ul></li><li>mutations - 方法【同步函数】<ul><li>inc(state, 参数唯一) {}</li><li>$store.commit(‘inc’, 2)</li></ul></li><li>getters - 包装数据 【store的计算属性，可缓存】<ul><li>show: function(state) {}</li><li>this.$store.getters.show</li><li>传参，返回函数：show(state) {return function(参数) {return …}}【不会缓存数据】</li></ul></li><li>actions -【异步操作】【提交的是mutations，不直接修改状态】<ul><li>increment(context, num) {context.commit()}</li><li>this.$store.dispatch(‘’,arg)</li></ul></li></ul><h2 id="VueRouter-是什么？你平常是怎么用的？"><a href="#VueRouter-是什么？你平常是怎么用的？" class="headerlink" title="VueRouter 是什么？你平常是怎么用的？"></a>VueRouter 是什么？你平常是怎么用的？</h2><ul><li><p>是什么：Vue-Router 是 Vue 官方的路由管理器</p></li><li><p>作用：为了页面跳转</p></li><li><p>原理：监听锚点值改变，渲染指定页面</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"h"</span>&gt;我是头部&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="content" class="b"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"f"</span>&gt;我是底部&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">//监视锚点值的改变</span></span><br><span class="line"><span class="string">window.addEventListener('hashchange', function() &#123;</span></span><br><span class="line"><span class="string">    var text = '';</span></span><br><span class="line"><span class="string">    switch (location.hash) &#123;</span></span><br><span class="line"><span class="string">        case '#/music':</span></span><br><span class="line"><span class="string">            text = '各种音乐的数据';</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        case '#/movie':</span></span><br><span class="line"><span class="string">            text = '各种电影的数据';</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    document.getElementById('content').innerHTML = text;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>查询字符串：</p><ol><li>去哪（列表页传参） <router-link :to="{name:'detail',query:{id:1}}">xxx</router-link></li><li>导航（router中） { name:’detail’ , path:’/detail’, component: Detail }</li><li>去了干嘛（详情页接收参数）this.$route.query.id</li></ol><p>path方式：</p><ol><li>去哪里 <router-link :to="{name:'detail',params:{name:1}}">xxx</router-link></li><li>导航 { name:’detail’ , path:’/detail/:name’, component: Detail}</li><li>去了干嘛（获取路由参数）this.$route.params.name</li></ol><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name配params：</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">'Goods'</span>, <span class="attr">params</span>: &#123;<span class="attr">goodsId</span>:id&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// path配query：</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">query</span>: &#123;<span class="attr">goodsId</span>:id&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数接收匹配：</span></span><br><span class="line"><span class="keyword">this</span>.goodsId = <span class="keyword">this</span>.$route.query.goodsId</span><br><span class="line"><span class="keyword">this</span>.goodsId = <span class="keyword">this</span>.$route.params.goodsId</span><br></pre></td></tr></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><ul><li>全局守卫：beforeEach, beforeResolve, afterEach【没有next】</li><li>路由独享守卫：beforeEnter</li><li>组件内守卫：beforeRouteEnter【唯一next有回调】, Update, Leave</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>全局守卫：beforeEach（用户登录以及权限判定）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = localStroage.token</span><br><span class="line">  <span class="comment">// 个人中心需要登录</span></span><br><span class="line">  <span class="keyword">if</span> (to.name === <span class="string">'Member'</span>) &#123;</span><br><span class="line">    isLogin ? next() : next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：beforeRouteEnter（根据用户从何而来，修改当前组件标题）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详情页组件</span></span><br><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> title = <span class="string">''</span></span><br><span class="line">    title = <span class="keyword">from</span>.name === <span class="string">'news.list'</span> ? <span class="string">'新闻详情'</span> : <span class="string">'商品详情'</span></span><br><span class="line">    <span class="comment">// 一定要调用 next ，否则无法从列表页跳转到详情页</span></span><br><span class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> vm.title = title) <span class="comment">// 通过 vm 访问组件实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="你是如何使用插槽的？"><a href="#你是如何使用插槽的？" class="headerlink" title="你是如何使用插槽的？"></a>你是如何使用插槽的？</h2><ul><li>默认插槽：父<child>html模板</child> | 子<slot></slot></li><li>具名插槽：父<child><template slot="footer"></template> | 子 <slot name="footer"></slot></child></li><li>作用域插槽：父<child><template slot-scope="user"></template></child> | 子提供数据 <slot :data="data"></slot></li></ul><p>阅读更多：<a href="https://segmentfault.com/a/1190000012996217" target="_blank" rel="noopener">深入理解vue中的slot与slot-scope</a></p><h2 id="nextTick的更新原理"><a href="#nextTick的更新原理" class="headerlink" title="nextTick的更新原理"></a>nextTick的更新原理</h2><p>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</p><p>nextTick的回调函数会等到同步任务执行完毕，DOM更新后才触发。</p><p>阅读更多：<a href="https://segmentfault.com/a/1190000012861862" target="_blank" rel="noopener">Vue.nextTick 的原理和用途</a></p><h2 id="在列表组件中添加-key-属性的作用？"><a href="#在列表组件中添加-key-属性的作用？" class="headerlink" title="在列表组件中添加 key 属性的作用？"></a>在列表组件中添加 key 属性的作用？</h2><p>key的主要作用是为了高效的更新虚拟 DOM。另外如果给列表组件设置了过渡效果，不添加key属性会导致过渡效果无法触发。</p><p>阅读更多：</p><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1" target="_blank" rel="noopener">写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</a></li><li><a href="https://www.zhihu.com/question/61064119/answer/183717717" target="_blank" rel="noopener">Vue2.0 v-for 中 :key 到底有什么用？</a></li></ul><h2 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop</h2><p>因为 prop 的传递是单向数据流，这样易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。另外 props 传入的值如果对象的话，是可以直接在子组件里更改的，因为是同一个引用。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="谈谈你对-MVVM-开发模式的理解"><a href="#谈谈你对-MVVM-开发模式的理解" class="headerlink" title="谈谈你对 MVVM 开发模式的理解"></a>谈谈你对 MVVM 开发模式的理解</h3><ul><li>Model 数据模型层，保存页面中的数据</li><li>View 视图层，页面数据的展示；</li><li>ViewModel M，V调度者。双向数据绑定。通过监听 Model 数据的改变来控制V的更新，处理用户交互操作；</li></ul><p>M 数据改变 =&gt;VM =&gt; 触发 View 更新</p><p>V 用户操作 =&gt; VM =&gt; M 数据同步更新</p><p>开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS+JS+浏览器面试题</title>
      <link href="/2019/07/20/0.tips/6.h5c3js%E5%B7%A5%E5%85%B7%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/20/0.tips/6.h5c3js%E5%B7%A5%E5%85%B7%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="你对语义化的理解"><a href="#你对语义化的理解" class="headerlink" title="你对语义化的理解"></a>你对语义化的理解</h2><p>用正确的标签做正确的事情</p><ul><li>利于开发：使代码<strong>结构清晰</strong>，<strong>可读性高</strong>，<strong>方便维护</strong></li><li>利于SEO：方便爬虫根据语义标签确定<strong>页面结构</strong>和<strong>关键字</strong>的权重</li></ul><h3 id="你在平常工作中使用过哪些语义标签？"><a href="#你在平常工作中使用过哪些语义标签？" class="headerlink" title="你在平常工作中使用过哪些语义标签？"></a>你在平常工作中使用过哪些语义标签？</h3><p>header, nav, aside, main, section, article, footer, canvas, video, audio</p><h3 id="你说你用过canvas-video-audio，你是怎么用它们的？"><a href="#你说你用过canvas-video-audio，你是怎么用它们的？" class="headerlink" title="你说你用过canvas/video/audio，你是怎么用它们的？"></a>你说你用过canvas/video/audio，你是怎么用它们的？</h3><ul><li><p>画布：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">canvas</a></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;canvas width=<span class="string">"500"</span> height=<span class="string">"500"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">"canvas"</span>)</span><br><span class="line">     &lt;!-- 获取上下文 --&gt;</span><br><span class="line">     <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line">     ctx.beginPath()</span><br><span class="line">     &lt;!-- 设置图形轮廓的颜色 --&gt;</span><br><span class="line">     ctx.strokeStyle = <span class="string">"red"</span></span><br><span class="line">     &lt;!-- 绘制直线 --&gt;</span><br><span class="line">     ctx.moveTo(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">     ctx.lineTo(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">     ctx.stroke()</span><br><span class="line">     &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></li><li><p>媒体元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">video</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="noopener">audio</a></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"视频资源路径"</span> <span class="attr">poster</span>=<span class="string">"海报资源路径"</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"音频资源路径"</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解释下移动端为什么要添加-meta-viewport-，怎么写？"><a href="#解释下移动端为什么要添加-meta-viewport-，怎么写？" class="headerlink" title="解释下移动端为什么要添加 meta viewport ，怎么写？"></a>解释下移动端为什么要添加 meta viewport ，怎么写？</h2><p>作用：</p><p>防止页面在移动端可以缩放。</p><p>写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>使用 <code>viewport</code> 来控制浏览器视口的宽度和缩放比例</li><li>添加 <code>width=device-width</code> 以便让视口的宽度与设备一致</li><li>添加 <code>initial-scale=1</code> 以便让页面的默认缩放比例与PC端一致</li></ul><p>参考阅读：</p><ul><li><strong><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank" rel="noopener">在移动浏览器中使用viewport元标签控制布局</a></strong></li><li><strong><a href="https://developers.google.cn/web/tools/lighthouse/audits/has-viewport-meta-tag?hl=zh-cn" target="_blank" rel="noopener">HTML 具有视口元标记</a></strong></li><li><strong><a href="https://www.cnblogs.com/chunyangji/p/5795487.html" target="_blank" rel="noopener">移动端web开发——视口</a></strong></li></ul><h1 id="CSS知识点"><a href="#CSS知识点" class="headerlink" title="CSS知识点"></a>CSS知识点</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>标准盒模型（W3C标准）：</p><p>一个块的总宽度 = <strong>内容宽度</strong> + margin(左右) + padding(左右) + border(左右)</p><p>怪异盒模型（IE标准）：</p><p>一个块的总宽度 = <strong>width（包含 padding 和 border）</strong> + margin(左右)</p><h3 id="怪异盒模型触发条件"><a href="#怪异盒模型触发条件" class="headerlink" title="怪异盒模型触发条件"></a>怪异盒模型触发条件</h3><p>如果 html 文件最顶部 doctype 缺失，则在 ie6、7、8 将会触发怪异模式(quirks);</p><h3 id="通过css来设置盒模型"><a href="#通过css来设置盒模型" class="headerlink" title="通过css来设置盒模型"></a>通过css来设置盒模型</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>; <span class="comment">/* 标准模型 */</span></span><br><span class="line">            <span class="selector-tag">border-box</span>;  <span class="comment">/* IE模型 */</span></span><br><span class="line">            <span class="selector-tag">inherit</span>;     <span class="comment">/* 从父元素继承 */</span></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>怪异盒模型（border-box）</li></ul><blockquote><p>比如我们想做一个内边距 10px ，边框为 2px ，最终包括边框宽度为  100px 的 div ，之前的做法是先算出内容宽 <code>width</code> 。但有点繁琐，需要人算。此时我们可以把 div 的 box-sizing 设置为 border-box ，我们就可以直接把 width 设置为 100px ，其余的 padding 和 border 按照给定好的值一一填入，就可以完成这一切工作，省去了人为的计算内容宽 content 的过程，减少计算量的同时减少了错误率。</p></blockquote><h2 id="CSS选择符有哪些？哪些属性可以继承？"><a href="#CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h2><ol><li>id选择器（ #my-id ）</li><li>类选择器（ .my-class-name ）</li><li>标签选择器（ div, h1, p ）</li><li>相邻选择器（ h1 + p 紧贴在 h1 后面的第一个 p 标签。同级标签，之间不能有其他标签 ）</li><li>子代选择器（ ul &gt; li  ul 标签下的下一个层级的 li ，并不是所有 ）</li><li>后代选择器（ li a ）</li><li>通配符选择器（ * ）</li><li>属性选择器（ a[rel = “external”] ）</li><li>伪类选择器（ a:hover, li:nth-child ）</li></ol><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><p>font-size font-family color, UL LI DL DD DT;</p><h3 id="不可继承属性"><a href="#不可继承属性" class="headerlink" title="不可继承属性"></a>不可继承属性</h3><p>border padding margin width height</p><h2 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h2><ul><li>写在后面的覆盖写在前面的</li><li>描述越具体优先级越高 (div , div[class=’restart’])</li><li>同权重 行内样式 &gt; 内嵌样式 &gt; 外部样式</li><li>!important 优先级最高</li></ul><h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><ul><li><p><code>p:first-of-type</code> 属于其父元素的特定类型首个子元素 等同于 <code>:nth-of-type(1)</code></p></li><li><p><code>p:last-of-type</code> 属于其父元素的特定类型的最后一个子元素  等同于 <code>:nth-last-of-type(1)</code></p></li><li><p><code>::after</code> 在元素之前添加内容,也可以用来做清除浮动。</p></li><li><p><code>::before</code> 在元素之后添加内容</p></li><li><p><code>:enabled/:disabled</code> 控制表单控件的禁用状态。</p></li><li><p><code>:checked</code> 单选框或复选框被选中。</p></li></ul><h2 id="display-none-与-visibility-hidden-的区别？"><a href="#display-none-与-visibility-hidden-的区别？" class="headerlink" title="display: none 与 visibility: hidden 的区别？"></a>display: none 与 visibility: hidden 的区别？</h2><ul><li><code>display: none</code> 不显示对应的元素，在文档布局中不再分配空间（重排+重绘）</li><li><code>visibility: hidden</code> 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li></ul><h2 id="position-跟-display-、-overflow-、float-这些特性相互叠加后会怎么样？"><a href="#position-跟-display-、-overflow-、float-这些特性相互叠加后会怎么样？" class="headerlink" title="position 跟 display 、 overflow 、float 这些特性相互叠加后会怎么样？"></a>position 跟 display 、 overflow 、float 这些特性相互叠加后会怎么样？</h2><ul><li>position 属性规定元素的定位类型</li><li>display 属性规定元素应该生成的框的类型</li><li>float 属性是一种布局方式，定义元素在哪个方向浮动。</li></ul><p>优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</p><h2 id="讲一讲-position-属性中的各种值"><a href="#讲一讲-position-属性中的各种值" class="headerlink" title="讲一讲 position 属性中的各种值"></a>讲一讲 position 属性中的各种值</h2><table><thead><tr><th><strong>值</strong></th><th><strong>是否脱标占有位置</strong></th><th><strong>可使用边偏移</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>static</td><td>不脱标，正常模式</td><td>不可以</td><td>自动（没有）定位（默认定位方式）</td></tr><tr><td>relative(自恋)</td><td>不脱标，占有位置</td><td>可以</td><td>相对定位，相对于其原文档流的位置进行定位</td></tr><tr><td>absolute(拼爹)</td><td>完全脱标，不占位置</td><td>可以</td><td>绝对定位，相对于其上一个已经定位（不为static）的父元素进行定位</td></tr><tr><td>fixed(浏览器)</td><td>完全脱标，不占位置</td><td>可以</td><td>固定定位，相对于浏览器窗口进行定位（老IE不支持）</td></tr><tr><td>inherit</td><td></td><td></td><td>规定从父元素继承 position 属性的值</td></tr></tbody></table><h2 id="CSS3-有哪些新特性？"><a href="#CSS3-有哪些新特性？" class="headerlink" title="CSS3 有哪些新特性？"></a>CSS3 有哪些新特性？</h2><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 语法 */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">CSS</span>属性，过渡时间，效果曲线（默认<span class="selector-tag">ease</span>），延迟时间（默认0）</span><br><span class="line"></span><br><span class="line"><span class="comment">/* demo1 */</span></span><br><span class="line"><span class="comment">/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> <span class="selector-class">.5s</span> <span class="selector-tag">ease</span> <span class="selector-class">.2s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* demo2 */</span></span><br><span class="line"><span class="comment">/* 分开写 */</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">width</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">linear</span>;</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 2<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 语法 */</span></span><br><span class="line"><span class="selector-tag">animation</span>：动画名称，动画时间，运动曲线（默认<span class="selector-tag">ease</span>），动画延迟（默认0），播放次数（默认1），</span><br><span class="line">是否反向播放动画（默认<span class="selector-tag">normal</span>），是否暂停动画（默认<span class="selector-tag">running</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">/* demo1 */</span></span><br><span class="line"><span class="comment">/* 执行一次logo2-line动画，运动时间2秒，运动曲线为 linear */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* demo2 */</span></span><br><span class="line"><span class="comment">/* 2秒后开始执行一次 logo2-line 动画，运动时间2秒，运动曲线为 linear */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 2<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* demo3 */</span></span><br><span class="line"><span class="comment">/*无限执行 logo2-line 动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> <span class="selector-tag">alternate</span> <span class="selector-tag">infinite</span>;</span><br><span class="line"></span><br><span class="line">还有一个重要属性：用来指定在动画执行之前和之后如何给动画的目标应用样式。</span><br><span class="line">animation-fill-mode: none | forwards | backwards | both;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动画分为 初始状态 等待期 动画执行期 完成期 四个阶段。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响</span></span><br><span class="line"><span class="comment">- forwards 表示等待期保持初始样式，完成期间保持最后一帧样式</span></span><br><span class="line"><span class="comment">- backwards 表示等待期为第一帧样式，完成期跳转为初始样式</span></span><br><span class="line"><span class="comment">- both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://segmentfault.com/q/1010000003867335" target="_blank" rel="noopener">如何理解animation-fill-mode及其使用？</a></p><h3 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h3><p>transform: 适用于2D或3D转换的元素 <a href="https://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/" target="_blank" rel="noopener">(3d看这里)</a><br>transform-origin: 转换元素的位置（围绕那个点进行转换,默认中心）。默认 x, y, z ： 50%, 50%, 0 对应 left, top</p><ul><li>缩放 scale</li><li>位移 translate</li><li>旋转 rotate</li><li>倾斜 skew</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(30<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(30<span class="selector-tag">px</span>, 30<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(<span class="selector-class">.8</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skew</span>(10<span class="selector-tag">deg</span>, 10<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>; <span class="comment">/* 左上（默认中心）【改变元素变形的原点】 */</span></span><br></pre></td></tr></table></figure><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>对 transition 、animation 和 transform 这块儿内容不熟的同学可以参考我的博客简单上手教程，基本上每个属性都有相应的 demo 展示：<a href="https://evestorm.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/" target="_blank" rel="noopener">Lance的个人博客-css分类</a></p><p>另外，上面的知识点参考于下方资源，可自取：</p><ul><li><a href="https://segmentfault.com/a/1190000010780991" target="_blank" rel="noopener">个人总结（css3新特性）</a></li><li><a href="http://cubic-bezier.com/#.42,0,.58,1" target="_blank" rel="noopener">cubic-bezier贝塞尔在线预览</a></li><li><a href="https://cssreference.io/property/transition-timing-function/" target="_blank" rel="noopener">transition-timing-function | cssreference</a></li><li><a href="https://www.smashingmagazine.com/2014/04/understanding-css-timing-functions/" target="_blank" rel="noopener">Understanding The CSS3 transition-timing-function Property</a></li><li><a href="https://segmentfault.com/a/1190000011019534" target="_blank" rel="noopener">翻译 | 深入理解CSS时序函数</a></li><li><a href="http://koala.ink/posts/86be452a/" target="_blank" rel="noopener">css3动画详解【推荐】</a></li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul><li>div[index] { background: red }    表示 div 下面带 index 属性的背景为红色</li><li>div[index=a] { background: red }  表示 div 下面的自定义属性 index=a 的 div 的颜色变成红色。</li><li>div[index~=a] { background: red }    只要 div 中 index 属性带 a 这个单词的就生效。[a这个单词必须独立存在]<ul><li>p[class~=’lance’] 只会匹配到 class=”xxx lance”，而不会匹配 class=”xxlancexx”</li></ul></li><li>div[index*=a] { background: red }     只要 div 里面的 index 属性带 a 字母的就生效。</li><li>div[index^=a] { background: red }   以 a 开头的</li><li>div[index$=a] { background: red }    以 a 结尾</li><li>div[index|=a] { background:red }    只要以 a- 开头的</li></ul><p>当需要多个的时候： div[key1=value1][key2=value2][key3=value3]…. { background:red }</p><h4 id="结构性伪类选择器"><a href="#结构性伪类选择器" class="headerlink" title="结构性伪类选择器"></a>结构性伪类选择器</h4><p>前提：假如 div 是下面 p 标签的父元素</p><ul><li><code>p:nth-child(n)</code> div 下类型为 p 的第 n 个子元素，下标从 1 开始！！<ul><li><code>:nth-child(odd)</code> 奇数</li><li><code>:nth-child(even)</code> 偶数</li></ul></li><li><code>p:nth-last-child(n)</code> 从倒数，div 下类型为 p 的第 n 个子元素</li><li><code>p:last-child</code> div 下最后一个子元素如果是 p ，则生效，否则不生效</li><li><code>p:first-child</code> div 下第一个子元素如果是 p ，则生效，否则不生效【css2的】</li><li><code>p:first-of-type</code> div 下第一个类型为 p 的子元素【不需要 p 是这个 div 下的第一个子元素】</li><li><code>p:last-of-type</code> div 下最后一个类型为 p 的子元素</li></ul><p>参考：<a href="https://www.cnblogs.com/2050/p/3569509.html" target="_blank" rel="noopener">css选择器中:first-child与:first-of-type的区别</a></p><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><ol><li><code>::first-letter</code>  文本的第一个单词或字（如中文、日文、韩文等）</li><li><code>::first-line</code>    文本第一行；</li><li><code>::selection</code>    可改变选中文本的样式；</li><li><code>::before</code> 和 <code>::after</code> 在元素内部的开始火结束为止创建一个元素，该元素为行内元素，必须结合 content 属性使用 div::before { content: ‘开始’ }</li></ol><h4 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h4><p><code>:target</code> 目标伪类选择器， <code>:</code> 选择器可用于选取当前活动的目标元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.2</span>);</span><br></pre></td></tr></table></figure><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li><p>边框图片 border-image</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image</span>: <span class="selector-tag">image-source</span> <span class="selector-tag">image-height</span> <span class="selector-tag">image-width</span> <span class="selector-tag">image-repeat</span></span><br></pre></td></tr></table></figure></li><li><p>圆角边框 border-radius</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 左上角，右上角，右下角，左下角</span><br></pre></td></tr></table></figure></li></ul><h3 id="CSS弹性布局（flex）"><a href="#CSS弹性布局（flex）" class="headerlink" title="CSS弹性布局（flex）"></a>CSS弹性布局（flex）</h3><h4 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列</span><br><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line"></span><br><span class="line">换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-direction</span>属性和<span class="selector-tag">flex-wrap</span>属性的简写形式，默认值为<span class="selector-tag">row</span> <span class="selector-tag">nowrap</span></span><br><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line"></span><br><span class="line">主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐</span><br><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"></span><br><span class="line">交叉轴对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 第一行文字的基线对齐</span><br><span class="line">align-items: stretch | flex-start | flex-end | center | baseline;</span><br><span class="line"></span><br><span class="line">多根轴线对齐方式：拉伸对齐（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐</span><br><span class="line">align-content: stretch | flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><h4 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">顺序：数值越小越靠前，默认为0</span><br><span class="line"><span class="selector-tag">order</span>: &lt;<span class="selector-tag">number</span>&gt;;</span><br><span class="line"></span><br><span class="line">放大比例：默认为0，如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推</span><br><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;;</span><br><span class="line"></span><br><span class="line">缩小比例：默认为1，如果空间不足则会缩小，值为0不缩小</span><br><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;;</span><br><span class="line"></span><br><span class="line">项目自身大小：默认auto，为原来的大小，可设置固定值 50px/50%</span><br><span class="line">flex-basis: &lt;length&gt; | auto;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-grow</span>, <span class="selector-tag">flex-shrink</span> 和 <span class="selector-tag">flex-basis</span> 的简写，默认值为0 1 <span class="selector-tag">auto</span></span><br><span class="line">两个快捷值：<span class="selector-tag">auto</span> (1 1 <span class="selector-tag">auto</span>) 和 <span class="selector-tag">none</span> (0 0 <span class="selector-tag">auto</span>)</span><br><span class="line">flex:none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br><span class="line"></span><br><span class="line">项目自身对齐：继承父元素（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 基线对齐 | 拉伸对齐</span><br><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>左右分栏、上下分栏。（检验下自己如何完成下列布局）</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549370833162-7634582a-1731-4566-96e6-0632a2ea0cfa.png?x-oss-process=image/resize,w_416" alt="上下分栏.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549370843489-6c8f8d27-843d-4447-9e39-b74e665bde27.png?x-oss-process=image/resize,w_408" alt="左右分栏.png"><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549370859715-e41edd2d-53a8-4528-9365-4c0c3f9f1f40.png?x-oss-process=image/resize,w_398" alt="内容结构板块.png"></p><p>对 flex 不熟悉的同学可以参考下面网站进行学习：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="noopener">30 分钟学会 Flex 布局</a></li><li><a href="http://www.deathghost.cn/article/css/38" target="_blank" rel="noopener">flex网页布局首选方案 灵活应用 flex 弹性布局快速构建 web 结构</a></li></ul><p>不愿意看长篇大论的可以通过这个塔防游戏来学习：<a href="http://www.flexboxdefense.com/" target="_blank" rel="noopener">Flexbox Defense</a></p><h2 id="li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>有时，在写页面的时候，会需要将 <li> 这个块状元素横排显示，此时就需要将 display 属性设置为 inline-block ，此时问题出现了，在两个 </li><li> 元素之间会出现大约 8px 左右的空白间隙</li></p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab ）渲染成一个空格，也就是我们上面的代码 <li> 换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。</li></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>给 ul 标签设置 <code>font-size: 0;</code> 并为 li 元素重新设置 <code>font-size: xxpx;</code></p><h2 id="BFC-块级格式化上下文：block-formatting-context"><a href="#BFC-块级格式化上下文：block-formatting-context" class="headerlink" title="BFC(块级格式化上下文：block formatting context)"></a>BFC(块级格式化上下文：block formatting context)</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。我们可以利用这些特性解决特定环境下的布局问题。</p><h3 id="常见-BFC-应用"><a href="#常见-BFC-应用" class="headerlink" title="常见 BFC 应用"></a>常见 BFC 应用</h3><h4 id="清除元素内部浮动"><a href="#清除元素内部浮动" class="headerlink" title="清除元素内部浮动"></a>清除元素内部浮动</h4><blockquote><p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p></blockquote><p>只要把父元素设为 BFC 就可以清理子元素的浮动了，最常见的用法就是在父元素上设置 <code>overflow: hidden</code> 样式，对于 IE6 加上 <code>zoom: 1</code> 就可以了。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1549248451155-32c8a424-69d4-4e63-8892-3d6baa570934.jpeg" alt="fu.jpg"></p><h4 id="解决外边距合并问题"><a href="#解决外边距合并问题" class="headerlink" title="解决外边距合并问题"></a>解决外边距合并问题</h4><blockquote><p>盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</p></blockquote><p>属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠，那么我们创建不属于同一个 BFC ，就不会发生 margin 重叠了。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549249157981-50f0a18a-c021-4f4c-a1d2-9161d5b29200.png" alt="ma.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container4 green"</span> <span class="attr">style</span>=<span class="string">"height: 500px;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给其中一个 div 外面包一个 div ，然后通过触发外面这个 div 的 BFC ，就可以阻止这两个 div 的 margin 重叠 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue w100 h100"</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red w200 h200"</span> <span class="attr">style</span>=<span class="string">"margin-top: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两栏布局，实现左定宽-右宽自适应"><a href="#两栏布局，实现左定宽-右宽自适应" class="headerlink" title="两栏布局，实现左定宽+右宽自适应"></a>两栏布局，实现左定宽+右宽自适应</h4><blockquote><p>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549249227363-1b32cd7b-610e-4a7e-925c-05c6fc7ea76d.png?x-oss-process=image/resize,w_590" alt="you.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"height: 300px; background-color: red;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px; height: 100px; float: left; background-color: blue;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"overflow: hidden; background-color: green;"</span>&gt;</span>我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容我是右边内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 给右侧div添加 overflow: hidden即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：设置浮动后，<strong>div 会被 float 覆盖，而文本却不会被 float 覆盖</strong>，是因为** float 当初设计的时候<strong>就是为了</strong>使文本围绕在浮动对象的周围**。</p></blockquote><p>参考: <a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="noopener">[布局概念] 关于CSS-BFC深入理解</a></p><h2 id="请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="请解释一下为什么需要清除浮动？清除浮动的方式"></a>请解释一下为什么需要清除浮动？清除浮动的方式</h2><p>浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。</p><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。</p><h3 id="如何清除"><a href="#如何清除" class="headerlink" title="如何清除"></a>如何清除</h3><p>设置一个 clearfix 类，在出现浮动问题的父元素上添加此类即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是外边距合并？"><a href="#什么是外边距合并？" class="headerlink" title="什么是外边距合并？"></a>什么是外边距合并？</h2><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><blockquote><p>当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/260235/1549267541505-1dfd9327-a171-40f4-bd87-eda5a347ff30.gif" alt="img"></p><blockquote><p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/260235/1549267561084-700185b4-3e8b-4665-a5f4-0c9149fc0702.gif" alt="img"></p><blockquote><p>尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。</p><p>假设有一个空元素，它有外边距，但是</p><p>没有边框或填充</p><p>。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/260235/1549267577840-ad07cab7-66c8-45f0-97a7-67702219cf70.gif" alt="img"></p><blockquote><p>如果这个外边距遇到另一个元素的外边距，它还会发生合并：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/260235/1549267597856-b20a453d-b664-40bb-8a30-8feec3b1e22d.gif" alt="img"></p><p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。<strong>行内框、浮动框或绝对定位</strong>之间的外边距不会合并。</p><h2 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h2><p>从右向左的，这样会提高查找选择器所对应的元素的效率</p><ol><li>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。</li><li>只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</li></ol><h2 id="抽离样式模块怎么写，说出思路，有无实践经验？"><a href="#抽离样式模块怎么写，说出思路，有无实践经验？" class="headerlink" title="抽离样式模块怎么写，说出思路，有无实践经验？"></a>抽离样式模块怎么写，说出思路，有无实践经验？</h2><p>我们按照 CSS 的性质和用途，将 CSS 文件分成 「公共型样式」、「特殊型样式」、「皮肤型样式」，并以此顺序引用（按需求决定是否添加版本号）。</p><ol><li>公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。</li><li>特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。</li><li>皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。</li></ol><p>参考：<a href="http://nec.netease.com/standard/css-sort.html" target="_blank" rel="noopener">CSS规范 - 分类方法</a></p><h2 id="元素竖向的百分比设定是相对于父容器的高度吗？"><a href="#元素竖向的百分比设定是相对于父容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于父容器的高度吗？"></a>元素竖向的百分比设定是相对于父容器的高度吗？</h2><ul><li>对于 height 属性来说是的。</li><li>对于 margin-top/bottom(padding-top/bottom) 来讲不是，而是相对于容器的宽度计算的</li></ul><h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h2><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">990px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;head&gt;里边 &lt;link rel=”stylesheet” href=”xxx.css” media=”only screen and (max-width:480px)”&gt; */</span></span><br></pre></td></tr></table></figure><p>页面头部必须有 meta 声明的 viewport ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>兼容 ie6-8 方案：使用 respond.js 插件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lte IE 8]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="响应式和自适应设计的区别"><a href="#响应式和自适应设计的区别" class="headerlink" title="响应式和自适应设计的区别"></a>响应式和自适应设计的区别</h2><p>其实 RWD 和 AWD 都是响应式设计，从外观上很难分辨，但他们自己运行机理不同，</p><p>RWD 是主动式的响应设计，AWD 是被动式的响应式设计。</p><ul><li>RWD 不管用户使用的是什么设备都是在服务器把数据推送到浏览器后，脚本或 CSS 自行侦测屏幕大小后执行对应的样式表内容，并且一直通过本地脚本在监听屏幕大小的变化，随时做出样式响应的变化，所以是主动的。</li><li>AWD 是用户通过浏览器发送请求后，服务器根据请求中用户设备信息（request headers 的 user-agent）做出判断，调用已经在服务器里准备好的，适应对应设备样式文件+HTML内容+JS，返回给浏览器以这种方式响应不同设备。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deviceAgent = request.headers[<span class="string">"user-agent"</span>].toLowerCase();</span><br><span class="line"><span class="keyword">var</span> agentID = deviceAgent.match(<span class="regexp">/(iphone|ipod|ipad|android)/</span>);</span><br><span class="line"><span class="keyword">if</span> (agentID) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"手机访问"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"电脑访问"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549352188368-47bb3ec1-f6cb-4c9f-ab4b-253dd6816319.png" alt="rwdawd.png"></p><h2 id="你对-line-height-是如何理解的？如何单行文本垂直居中？多行文本呢？"><a href="#你对-line-height-是如何理解的？如何单行文本垂直居中？多行文本呢？" class="headerlink" title="你对 line-height 是如何理解的？如何单行文本垂直居中？多行文本呢？"></a>你对 line-height 是如何理解的？如何单行文本垂直居中？多行文本呢？</h2><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height ，没有定义 height 属性，最终其表现作用一定是 line-height 。</p><h3 id="单行文本垂直居中：（行高-元素高度）"><a href="#单行文本垂直居中：（行高-元素高度）" class="headerlink" title="单行文本垂直居中：（行高 == 元素高度）"></a>单行文本垂直居中：（行高 == 元素高度）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:40px</span>;</span><br><span class="line"><span class="selector-tag">line-height</span><span class="selector-pseudo">:40px</span>; <span class="comment">/* 行高==高 */</span></span><br></pre></td></tr></table></figure><h3 id="多行文本垂直居中：（父容器table，子容器table-cell-vertical-align-center）"><a href="#多行文本垂直居中：（父容器table，子容器table-cell-vertical-align-center）" class="headerlink" title="多行文本垂直居中：（父容器table，子容器table-cell+vertical-align:center）"></a>多行文本垂直居中：（父容器table，子容器table-cell+vertical-align:center）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span>&gt;</span><br><span class="line">        啊实打实大苏打啊实打实大师大师的啊实打实大苏打</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置元素浮动后，该元素的display值是多少？"><a href="#设置元素浮动后，该元素的display值是多少？" class="headerlink" title="设置元素浮动后，该元素的display值是多少？"></a>设置元素浮动后，该元素的display值是多少？</h2><p>自动变成了 display: block</p><h2 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></table></figure><h2 id="overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="overflow: scroll 时不能平滑滚动的问题怎么处理？"></a>overflow: scroll 时不能平滑滚动的问题怎么处理？</h2><p>一个 div 使用了 <code>overflow:scroll;</code> ，在移动端可以滚动，但是无法平滑滚动（就像浏览网页那样）</p><p>开启滚动硬件加速：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure><h2 id="什么是-CSS-预处理器-后处理器？"><a href="#什么是-CSS-预处理器-后处理器？" class="headerlink" title="什么是 CSS 预处理器 / 后处理器？"></a>什么是 CSS 预处理器 / 后处理器？</h2><h3 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h3><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件</p><blockquote><p>Sass（SCSS）、LESS</p></blockquote><h3 id="CSS-后处理器"><a href="#CSS-后处理器" class="headerlink" title="CSS 后处理器"></a>CSS 后处理器</h3><p>CSS 后处理器 是对 CSS 进行处理，并最终生成 CSS 的 预处理器，它属于广义上的 CSS 预处理器。</p><p>我们很久以前就在用 CSS 后处理器 了，最典型的例子是 CSS 压缩工具（如 clean-css），只不过以前没单独拿出来说过。还有最近比较火的 Autoprefixer，以 Can I Use 上的 浏览器支持数据 为基础，自动处理兼容性问题。</p><blockquote><p>Rework、PostCSS</p></blockquote><p>参考：<a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752" target="_blank" rel="noopener">CSS预处理器和后处理器</a></p><h2 id="图片为什么有左右上下间隙-怎么去除："><a href="#图片为什么有左右上下间隙-怎么去除：" class="headerlink" title="图片为什么有左右上下间隙,怎么去除："></a>图片为什么有左右上下间隙,怎么去除：</h2><p>原因：</p><ul><li>左右：因为 img 是 inline-block 行内元素，行内元素之间有『换行（回车），空格，tab』时会产生左右间隙</li><li>上下：行内元素默认与父容器基线对齐，而基线与父容器底部有一定间隙，所以上下图片间有间隙</li></ul><p>解决办法：</p><ul><li>移除上下间隙：<ul><li>img 本身设置 display: block;</li><li>父元素设置 font-size: 0; （基线与字体大小有关，字体为零，基线间就没距离了）</li><li>img本身设置 vertical-align: bottom;（让 inline-block 的 img 与每行的底部对齐）</li></ul></li><li>移除左右间距：<ul><li>行内元素间不要有换行，连成一行写消除间隙</li><li>第一行结尾写上 <code>&lt;!-- ，第二行开头跟上 --&gt;</code> 。即利用注释消除间距</li><li>父元素 font-size 设置 0</li></ul></li></ul><h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><h2 id="如何居中div？"><a href="#如何居中div？" class="headerlink" title="如何居中div？"></a>如何居中div？</h2><h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单个-div（块级元素）水平居中"><a href="#单个-div（块级元素）水平居中" class="headerlink" title="单个 div（块级元素）水平居中"></a>单个 div（块级元素）水平居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个-div-水平居中"><a href="#多个-div-水平居中" class="headerlink" title="多个 div 水平居中"></a>多个 div 水平居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 传统方案 */</span></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* flex 布局方案 */</span></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绝对定位的-div-居中（已知宽高）"><a href="#绝对定位的-div-居中（已知宽高）" class="headerlink" title="绝对定位的 div 居中（已知宽高）"></a>绝对定位的 div 居中（已知宽高）</h3><h4 id="子绝父相-margin"><a href="#子绝父相-margin" class="headerlink" title="子绝父相 + margin"></a>子绝父相 + margin</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto; <span class="comment">/* 0 auto 水平居中；auto 水平垂直居中 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/* 方便看效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子绝父相-负边距"><a href="#子绝父相-负边距" class="headerlink" title="子绝父相 + 负边距"></a>子绝父相 + 负边距</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">150px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">250px</span>;  <span class="comment">/* 外边距为自身宽高的一半 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: pink;     <span class="comment">/* 方便看效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当被居中的元素是-inline-or-inline-block-元素"><a href="#当被居中的元素是-inline-or-inline-block-元素" class="headerlink" title="当被居中的元素是 inline or inline-block 元素"></a>当被居中的元素是 inline or inline-block 元素</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意元素（未知宽高）"><a href="#任意元素（未知宽高）" class="headerlink" title="任意元素（未知宽高）"></a>任意元素（未知宽高）</h3><h4 id="子绝父相-translate"><a href="#子绝父相-translate" class="headerlink" title="子绝父相 + translate"></a>子绝父相 + translate</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 利用transform */</span></span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex（需考虑兼容性）"><a href="#flex（需考虑兼容性）" class="headerlink" title="flex（需考虑兼容性）"></a>flex（需考虑兼容性）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari仍旧需要使用特定的浏览器前缀 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;    <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;  <span class="comment">/* 水平居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;   <span class="comment">/* 方便看效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请解释一下CSS3的-Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的-Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的 Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的 Flexbox（弹性盒布局模型）,以及适用场景？</h2><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。</p><p>在传统的布局方式中:</p><ul><li>block 布局是把块在垂直方向从上到下依次排列的；</li><li>inline 布局则是在水平方向来排列。</li><li>flex 弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</li></ul><p>适用场景：弹性布局适合于移动前端开发，在 Android 和 iOS 上也完美支持。</p><p>参考：<a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="noopener">http://www.w3cplus.com/css3/flexbox-basics.html</a></p><h3 id="如何使用-flex-实现三列等宽布局"><a href="#如何使用-flex-实现三列等宽布局" class="headerlink" title="如何使用 flex 实现三列等宽布局"></a>如何使用 flex 实现三列等宽布局</h3><p>父元素 display: flex，子元素 flex: 1</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>子元素的设置等同于：flex: 1 1 auto</p><p>flex的默认值是：0 1 auto</p><p>意思是项目默认有剩余空间也不放大（0），但空间不足会缩小（1）</p><p>现在改为了值 1 ，就可以放大了，所以三栏可以平分宽度</p><p>阅读：<a href="https://segmentfault.com/q/1010000004080910" target="_blank" rel="noopener">flex设置成1和auto有什么区别</a></p><h3 id="如何使用-flex-实现下列布局"><a href="#如何使用-flex-实现下列布局" class="headerlink" title="如何使用 flex 实现下列布局"></a>如何使用 flex 实现下列布局</h3><p><img src="https://gitee.com/evestorm/various_resources/raw/master/css/flex-left.png" alt="flex"></p><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>margin-left: auto<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">  <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: springgreen;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box5</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘自：<a href="https://juejin.im/post/5bde54ce51882516e840a8af" target="_blank" rel="noopener">css flex布局中妙用 margin: auto</a></p><h2 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">把上、左、右三条边隐藏掉（颜色设为 <span class="selector-tag">transparent</span>）</span><br><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css多列等高如何实现？"><a href="#css多列等高如何实现？" class="headerlink" title="css多列等高如何实现？"></a>css多列等高如何实现？</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用 <code>padding-bottom|margin-bottom</code> 正负值相抵； </p><p>设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度， 当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度， 其他比这列矮的列则会用它们的 padding-bottom 来补偿这部分高度差。</p><p>因为背景是可以用在 padding 占用的空间里的，而且边框也是跟随 padding 变化的，所以就成功的完成了一个障眼法。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"Article"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js-equalheight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      一家将客户利益置于首位的经纪商，</span><br><span class="line">      为客户提供专业的交易工具一家将客户利益置于首位的经纪商</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js-equalheight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一家将客户利益置于首位的经纪商，为客户提供专业的交易工具<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js-equalheight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一家将客户利益置于首位的经纪商<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Article</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Article</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span> -<span class="number">9999px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4577dc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Article</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一个高度自适应的-div-，里面有两个-div-，一个高度-100px-，希望另一个填满剩下的高度。"><a href="#有一个高度自适应的-div-，里面有两个-div-，一个高度-100px-，希望另一个填满剩下的高度。" class="headerlink" title="有一个高度自适应的 div ，里面有两个 div ，一个高度 100px ，希望另一个填满剩下的高度。"></a>有一个高度自适应的 div ，里面有两个 div ，一个高度 100px ，希望另一个填满剩下的高度。</h2><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"A"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"B"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.B</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">calc</span>(100vh - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  利用border-box将padding包含在高度内； </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">100px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  用负margin值将A子容器顶到页面顶部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#BBE8F2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  剩下的高度100%-100px就是B容器所谓的100%高了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.B</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#D9C666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">100px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  绝对定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#BBE8F2</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.B</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#D9C666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#BBE8F2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.B</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#D9C666</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案5"><a href="#方案5" class="headerlink" title="方案5"></a>方案5</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">-webkit-flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.B</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rem布局的优缺点"><a href="#rem布局的优缺点" class="headerlink" title="rem布局的优缺点"></a>rem布局的优缺点</h2><p>优点：</p><p>能维持能整体的布局效果，移动端兼容性好，不用写多个css代码，而且还可以利用@media进行优化。</p><p>缺点：</p><p>开头要引入一段 js 代码，单位都要改成 rem（ font-size 可以用 px ），计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。PC 和 Mobile 要分开。</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/qieguo/p/5386565.html" target="_blank" rel="noopener">用 rem 实现 WebApp 自适应的优劣分析</a></li><li><a href="https://www.zhihu.com/question/21504656" target="_blank" rel="noopener">CSS3 的字体大小单位[rem]到底好在哪？</a></li><li><a href="https://segmentfault.com/a/1190000010211016" target="_blank" rel="noopener">总结个人使用过的移动端布局方法</a></li></ul><h2 id="慎用-em-的原因"><a href="#慎用-em-的原因" class="headerlink" title="慎用 em 的原因"></a>慎用 em 的原因</h2><p><strong>em会叠加计算。</strong>在这个机制下太容易犯错了，因为你不知道这段<code>css</code>指定的字号具体是多少。</p><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    abc</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>def<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    abc</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.5em</span>; &#125;</span><br></pre></td></tr></table></figure><p>实际效果：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549344767634-006a0ce5-2c0c-4087-97c3-c8e77933009d.png" alt="abc.png"></p><p>先要搞清楚 <code>em</code> 的计算原理，它是根据<strong>当前元素的字号</strong>按比例计算的。</p><p>外层 <code>span</code> 的字号是 <code>16px</code>（浏览器默认值），所以 <code>1.5em</code> 之后是 <code>24px</code> 。由于字号是继承的，导致内层 <code>span</code> 的字号继承过来是 <code>24px</code> ，再经过 <code>1.5em</code> 之后就成了 <code>36px</code> 。</p><p>所以，就算要用 <code>em</code> 的话，尽量不要用在继承属性（<code>font-size</code>）上，除非你真的清楚你在做什么！</p><h2 id="两列布局（左列定宽，右列自适应）"><a href="#两列布局（左列定宽，右列自适应）" class="headerlink" title="两列布局（左列定宽，右列自适应）"></a>两列布局（左列定宽，右列自适应）</h2><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-利用-float-margin"><a href="#1-利用-float-margin" class="headerlink" title="1. 利用 float + margin"></a>1. 利用 float + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>; <span class="comment">/*设置间隔，大于等于#left的宽度*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原理：<span class="selector-id">#left</span>左浮动，脱离文档流，<span class="selector-id">#right</span>为了不被<span class="selector-id">#left</span>挡住，</span><br><span class="line">设置<span class="selector-tag">margin-left</span>大于等于<span class="selector-id">#left</span>的宽度达到视觉上的两栏布局</span><br></pre></td></tr></table></figure><h3 id="2-使用-float-overflow（触发bfc）"><a href="#2-使用-float-overflow（触发bfc）" class="headerlink" title="2. 使用 float + overflow（触发bfc）"></a>2. 使用 float + overflow（触发bfc）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/*触发bfc达到自适应*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原理：<span class="selector-id">#left</span>左浮动，<span class="selector-id">#right</span>触发<span class="selector-tag">bfc</span>达到自适应</span><br></pre></td></tr></table></figure><h3 id="3-使用-table-实现"><a href="#3-使用-table-实现" class="headerlink" title="3. 使用 table 实现"></a>3. 使用 table 实现</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*利用单元格自动分配宽度*/</span></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用-position-实现"><a href="#4-使用-position-实现" class="headerlink" title="4. 使用 position 实现"></a>4. 使用 position 实现</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;  <span class="comment">/*父相*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;  <span class="comment">/*子绝*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;  <span class="comment">/*子绝*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;  <span class="comment">/*值大于等于#left的宽度*/</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用-flex-实现"><a href="#5-使用-flex-实现" class="headerlink" title="5. 使用 flex 实现"></a>5. 使用 flex 实现</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/*均分了父元素剩余空间*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两列布局（一列不定宽，一列自适应）"><a href="#两列布局（一列不定宽，一列自适应）" class="headerlink" title="两列布局（一列不定宽，一列自适应）"></a>两列布局（一列不定宽，一列自适应）</h2><h3 id="1-float-overflow"><a href="#1-float-overflow" class="headerlink" title="1. float + overflow"></a>1. float + overflow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;  <span class="comment">/*只设置浮动,不设宽度*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  <span class="comment">/*触发bfc*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原理：<span class="selector-id">#left</span>不设宽度左浮动，<span class="selector-id">#right</span>触发 <span class="selector-tag">bfc</span> 达到自适应</span><br></pre></td></tr></table></figure><h3 id="2-flex-布局"><a href="#2-flex-布局" class="headerlink" title="2. flex 布局"></a>2. flex 布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123; <span class="comment">/*不设宽度*/</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;  <span class="comment">/*均分#parent剩余的部分*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三列布局（左中定宽，右侧自适应）"><a href="#三列布局（左中定宽，右侧自适应）" class="headerlink" title="三列布局（左中定宽，右侧自适应）"></a>三列布局（左中定宽，右侧自适应）</h2><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1. float + margin"></a>1. float + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">310px</span>;</span><br><span class="line">&#125; <span class="comment">/*100+10+200,防止宽度不够,子元素换行*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;  <span class="comment">/*#left和#center间隔*/</span></span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eeff2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">320px</span>;  <span class="comment">/*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-float-overflow"><a href="#2-float-overflow" class="headerlink" title="2. float + overflow"></a>2. float + overflow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">320px</span>;</span><br><span class="line">&#125; <span class="comment">/*100+10+200+20,防止宽度不够,子元素换行*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="comment">/*间隔*/</span></span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="comment">/*在此定义和#right的间隔*/</span></span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eeff2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  <span class="comment">/*触发bfc*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-利用-position"><a href="#3-利用-position" class="headerlink" title="3. 利用 position"></a>3. 利用 position</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125; <span class="comment">/*父相*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; <span class="comment">/*子绝*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; <span class="comment">/*子绝*/</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;        <span class="comment">/*对应#left的width值*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eeff2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; <span class="comment">/*子绝*/</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">300px</span>;        <span class="comment">/*对应#left和#center的width值之和*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-利用-table"><a href="#4-利用-table" class="headerlink" title="4. 利用 table"></a>4. 利用 table</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">520px</span>; <span class="comment">/*抵消上下间距10*2的高度影响*/</span></span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">10px</span> <span class="number">0</span>;  <span class="comment">/*抵消上下边间距10的位置影响*/</span></span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="comment">/*左右两边间距无法消除,子元素改用padding设置盒子间距就没有这个问题*/</span></span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">10px</span>;  <span class="comment">/*关键!!!设置间距*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eeff2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-利用-flex"><a href="#5-利用-flex" class="headerlink" title="5. 利用 flex"></a>5. 利用 flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;  <span class="comment">/*间距*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;  <span class="comment">/*间距*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eeff2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;  <span class="comment">/*均分#parent剩余的部分达到自适应*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三列布局（两侧定宽，中间自适应）"><a href="#三列布局（两侧定宽，中间自适应）" class="headerlink" title="三列布局（两侧定宽，中间自适应）"></a>三列布局（两侧定宽，中间自适应）</h2><h3 id="圣杯布局-详解"><a href="#圣杯布局-详解" class="headerlink" title="圣杯布局 详解"></a>圣杯布局 <a href="https://blog.csdn.net/konglei1996/article/details/50881391?utm_source=blogxgwz4" target="_blank" rel="noopener">详解</a></h3><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 让中间第一，这样浮动的时候它会先占据100%宽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">400px</span>;  <span class="comment">/* 左边w*2+右边w */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span> <span class="number">0</span> <span class="number">150px</span>; <span class="comment">/* 1. 父容器左右留出固定padding */</span></span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 4.1 让被挤到center下方的left左移整个容器的宽度，此时左上角与center重叠 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="comment">/* 4.2 为了让left移到最左边,设置相对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">150px</span>; <span class="comment">/* 4.3 然后相对自己左移自已宽度的单位，使自己移动到最左边 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;  <span class="comment">/* 2.1 左浮动 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(233, 233, 0, .2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;  <span class="comment">/* 3. 让center占据剩下父容器的100%宽 */</span></span><br><span class="line">  <span class="attribute">float</span>: left;  <span class="comment">/* 2.1 左浮动 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(165, 12, 23, .4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">100px</span>; <span class="comment">/* 5. 给在第二行的right设置一个负自己宽度的margin-right。让其最右边 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;  <span class="comment">/* 2.1 左浮动 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双飞翼布局方法-详情"><a href="#双飞翼布局方法-详情" class="headerlink" title="双飞翼布局方法 详情"></a>双飞翼布局方法 <a href="http://m.10qianwan.com/web/350789.html" target="_blank" rel="noopener">详情</a></h3><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;  <span class="comment">/* 1. 整个容器宽100%自适应 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="comment">/* 3.1 设置定宽 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 5. 左移容器宽度100%个单位，就把自己排在了center前面 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(233, 233, 0, .2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;  <span class="comment">/* 4. 中间容器100%，此时会把左右挤到第二行 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(165, 12, 23, .4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">150px</span> <span class="number">0</span> <span class="number">100px</span>;  </span><br><span class="line">    <span class="comment">/* 7. 此时center的左右分别有100和150宽与left，right重叠。所以让center子容器左右margin抵消 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>; <span class="comment">/* 3.2 设置定宽 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;  <span class="comment">/* 6. 同样左移自身宽度的单位，让right也回到第一行 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left; <span class="comment">/*2. 子容器全部左浮动 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布局的几种方式"><a href="#布局的几种方式" class="headerlink" title="布局的几种方式"></a>布局的几种方式</h2><ol><li>伸缩布局 flex</li><li>流式布局 百分比</li><li>响应式布局 媒体查询（超小屏设备时：流式布局）<br> &lt;!- 以上布局共同点：元素只能做到宽度的适配（排除图片）-&gt;</li><li>rem布局 宽度和高度都能做到适配（等比适配）</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:1px;overflow:hidden;background:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="JS类型"><a href="#JS类型" class="headerlink" title="JS类型"></a>JS类型</h2><p>string，number，boolean，undefined，null，symbol，object</p><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>两种类型的区别是：存储位置不同；</p><ul><li>值类型存储在栈（stack）中，占空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用类型存储在堆（heap）中,占据空间大、大小不固定。如果存在栈中，影响程序运行性能；引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549856966458-39b2f008-64fc-4753-936b-e513a5de46d2.png" alt="js类型堆栈图.png"></p><h3 id="JS的类型检测"><a href="#JS的类型检测" class="headerlink" title="JS的类型检测"></a>JS的类型检测</h3><ul><li><p>typeof （判断一个变量是什么类型）undefined object function boolean string number symbol</p></li><li><p>instanceof （判断当前对象是不是某个类型）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 要检测的对象 <span class="keyword">instanceof</span> 某个构造函数 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.make = make;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> auto = <span class="keyword">new</span> Car(<span class="string">'Honda'</span>, <span class="string">'Accord'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> Car);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString.call()（检测一个对象的类型）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"Lance"</span>));<span class="comment">//[object String]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h3><p><code>==</code> 在允许强制转换的条件下检查值的等价性，而 <code>===</code> 是在不允许强制转换的条件下检查值的等价性；</p><p>因此 <code>===</code> 常被称为「严格等价」。（”55” == 55 true, “55” === 55 false。p.s. 把字符串转为数值）</p><h3 id="哪些非-boolean-值被强制转换为一个-boolean-时，它是-false-？"><a href="#哪些非-boolean-值被强制转换为一个-boolean-时，它是-false-？" class="headerlink" title="哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？"></a>哪些非 boolean 值被强制转换为一个 boolean 时，它是 false ？</h3><ul><li><code>&quot;&quot;</code>（空字符串）</li><li><code>0</code>, <code>-0</code>, <code>NaN</code> （非法的 <code>number</code> ）</li><li><code>null</code>, <code>undefined</code></li></ul><h3 id="null，undefined-的区别？"><a href="#null，undefined-的区别？" class="headerlink" title="null，undefined 的区别？"></a>null，undefined 的区别？</h3><ul><li><p>null 表示一个对象是「没有值」的值，也就是值为 “空”；</p></li><li><p>undefined 表示一个变量声明了没有初始化(赋值)；</p></li><li><p>undefined 的类型（typeof）是 undefined ；</p></li><li><p>null 的类型（typeof）是 object ；</p></li><li><p>JavaScript 将未赋值的变量默认值设为undefined；</p></li><li><p>JavaScript 从来不会将变量设为 null 。它是用来让程序员表明某个用 var 声明的变量时没有值的。</p></li></ul><p>在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）创建新节点</span><br><span class="line">    createDocumentFragment()    <span class="comment">//创建一个DOM片段</span></span><br><span class="line">    createElement()   <span class="comment">//创建一个具体的元素</span></span><br><span class="line">    createTextNode()   <span class="comment">//创建一个文本节点</span></span><br><span class="line">（<span class="number">2</span>）添加、移除、替换、插入</span><br><span class="line">    appendChild()</span><br><span class="line">    removeChild()</span><br><span class="line">    replaceChild()</span><br><span class="line">    insertBefore() <span class="comment">//在已有的子节点前插入一个新的子节点</span></span><br><span class="line">（<span class="number">3</span>）查找</span><br><span class="line">    querySelector(<span class="string">"ul"</span>) / querySelectorAll(<span class="string">"ul li"</span>) <span class="comment">// 查找单个元素 / 多个元素</span></span><br><span class="line">    getElementsByTagName(<span class="string">"div"</span>)</span><br><span class="line">    getElementsByClassName()</span><br><span class="line">    getElementById()</span><br></pre></td></tr></table></figure><h2 id="对象的原生方法"><a href="#对象的原生方法" class="headerlink" title="对象的原生方法"></a>对象的原生方法</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>copy 对象的可枚举属性</p><blockquote><p>语法：Object.assign(target, …sources)</p><p>参数：目标对象, …源对象</p><p>返回值：目标对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>创建新对象</p><blockquote><p>语法：Object.create(proto, [ propertiesObject ])</p><p>参数：新创建对象的原型对象, 用于指定创建对象的一些属性，（eg：是否可读、是否可写，是否可以枚举etc）</p></blockquote><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>用来判断两个值是否是同一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'haorooms'</span>, <span class="string">'haorooms'</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="built_in">window</span>, <span class="built_in">window</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'bar'</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is([], []);           <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.is(test, test);       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>);       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-keys-Object-values"><a href="#Object-keys-Object-values" class="headerlink" title="Object.keys / Object.values"></a>Object.keys / Object.values</h3><p>返回给定对象的自身可枚举属性 / 值 的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: ['0', '1', '2']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: ['0', '1', '2']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// ['bar', 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>**Object.entries()**</code> 方法返回对象自身可枚举属性的键值对数组，其排列与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['foo', 'bar'], ['baz', 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">7</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// "a 5", "b 7", "c 9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的遍历方法"><a href="#数组的遍历方法" class="headerlink" title="数组的遍历方法"></a>数组的遍历方法</h3><ul><li>标准for循环</li><li>forEach((当前值, 当前索引,当前数组)=&gt;{})<ul><li>无法中途退出循环，只能用 <code>return</code> 退出本次回调，进行下一次回调。</li><li>它总是返回 undefined 值,即使你 return 了一个值。</li></ul></li><li>for-in（不推荐）会把继承链的对象属性都会遍历一遍，而且数组遍历不一定按次序<ul><li>for-in 循环返回的是所有能通过对象访问的、可枚举的属性。</li></ul></li><li>for (variable of iterable)（ES6）可迭代 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array" target="_blank" rel="noopener">Array</a> ，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map" target="_blank" rel="noopener">Map</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">Set</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" target="_blank" rel="noopener">String</a> 等（迭代的是值 value ）<ul><li>在 <code>for-of</code> 中如果遍历中途要退出，可以使用 <code>break</code> 退出循环。</li></ul></li></ul><h4 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h4><ul><li><p>map (不改变原数组) 会给原数组中的每个元素都按顺序调用一次 callback 函数</p></li><li><p>reduce (不改变原数组) 数组中的前项和后项做某种计算,并累计最终值。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment">// callback 参数</span></span><br><span class="line"><span class="comment">// (累积器, 当前元素, 当前元素索引, 当前数组)</span></span><br><span class="line"><span class="comment">// initialValue:指定第一次回调 的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> wallets = [<span class="number">4</span>, <span class="number">7.8</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> totalMoney = wallets.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">countedMoney, curMoney</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countedMoney + curMoney;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>filter（不改变原数组）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> morearr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// [4,5,6]</span></span><br></pre></td></tr></table></figure></li><li><p>every（不改变原数组）测试数组的所有元素是否都通过了指定函数的测试</p><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回  true 。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>some（不改变原数组）测试是否至少有一个元素通过 callback 中的条件.对于放在空数组上的任何条件，此方法返回 false 。</p><ul><li>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回 false 。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some(callback, thisArg)</span></span><br><span class="line"><span class="comment">// callback:</span></span><br><span class="line"><span class="comment">//    (当前元素, 当前索引, 调用some的数组)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item,index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li><p>find() &amp; findIndex() 根据条件找到数组成员</p><ul><li><p>find() 定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined 。</p></li><li><p>findIndex() 定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line"><span class="keyword">let</span> new_array = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">new_array</span> = <span class="title">arr</span>.<span class="title">findIndex</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function">&lt;!-- 这两个方法都可以识别<span class="title">NaN</span>,弥补了<span class="title">indexOf</span>的不足 --&gt;</span></span><br><span class="line"><span class="function">&lt;!-- <span class="title">find</span> --&gt;</span></span><br><span class="line">let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0);</span><br><span class="line">&lt;!-- 返回元素<span class="number">-5</span> --&gt;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));</span><br><span class="line">&lt;!-- 返回元素<span class="literal">NaN</span> --&gt;</span><br><span class="line">&lt;!-- findIndex --&gt;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line">&lt;!-- 返回索引<span class="number">2</span> --&gt;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>,<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n));</span><br><span class="line">&lt;!-- 返回索引<span class="number">4</span> --&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值</p><ul><li><p>三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.keys()   array.values()   array.entries()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="for-in-和-for-of-区别"><a href="#for-in-和-for-of-区别" class="headerlink" title="for in 和 for of 区别"></a>for in 和 for of 区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;  &lt;-- 循环的是索引</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 打印 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 打印 0, 1, 2, "foo"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;  &lt;-- 迭代的是值</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 打印 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/5a3a59e7518825698e72376b" target="_blank" rel="noopener">JavaScript 数组遍历方法的对比</a></p><h3 id="JS数组有哪些方法"><a href="#JS数组有哪些方法" class="headerlink" title="JS数组有哪些方法"></a>JS数组有哪些方法</h3><h4 id="改变原数组的方法（9个）"><a href="#改变原数组的方法（9个）" class="headerlink" title="改变原数组的方法（9个）"></a>改变原数组的方法（9个）</h4><h5 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加 / 删除数组元素"></a>splice() 添加 / 删除数组元素</h5><blockquote><p>splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p><p>array.splice(index,howmany,item1,…..,itemX)</p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX： 可选。向数组添加的新项目。</li></ol><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p></blockquote><p><strong>删除元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">-1</span>, <span class="number">3</span>) <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure><p><strong>删除并添加</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素'添加'</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">3</span>,<span class="string">'添加'</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ['添加',4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> item = b.splice(<span class="number">-2</span>,<span class="number">3</span>,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>) <span class="comment">// [6,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4,5,'添加1','添加2']</span></span><br></pre></td></tr></table></figure><p><strong>不删除只添加</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>) <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ['添加1','添加2',1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> item = b.splice(<span class="number">-1</span>,<span class="number">0</span>,<span class="string">'添加1'</span>,<span class="string">'添加2'</span>) <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure><h5 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h5><blockquote><p>定义: sort() 方法对数组元素进行排序，并返回这个数组。</p><p>参数可选: 规定排序顺序的比较函数。</p><p>默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 <code>toString()</code> 方法将元素转化为字符串的 Unicode (万国码)位点，然后再比较字符。</p></blockquote><p><strong>不传参</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>]</span><br><span class="line">a.sort() <span class="comment">// ["Apple","Banana","Mango","Orange"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>,<span class="number">25</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()) <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure><p><em>比较函数的两个参数：</em></p><p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p><ul><li>若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面;</li><li>若比较函数返回值 =0 ，那么 a 和 b 相对位置不变；</li><li>若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面；</li></ul><p><strong>数字升降序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array =  [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];  </span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure><h5 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h5><blockquote><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.pop()  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><h5 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h5><blockquote><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.shift()  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure><h5 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h5><blockquote><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.push(<span class="string">'末尾'</span>, <span class="string">'233'</span>)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1,2,3,'末尾', '233']</span></span><br></pre></td></tr></table></figure><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><blockquote><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> item = a.unshift(<span class="string">'开头'</span>, <span class="string">'开头2'</span>)  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [ '开头', '开头2', 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h5 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h5><blockquote><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><h4 id="不改变原数组的方法（8个）"><a href="#不改变原数组的方法（8个）" class="headerlink" title="不改变原数组的方法（8个）"></a>不改变原数组的方法（8个）</h4><h5 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h5><blockquote><p>定义： 方法返回一个从开始到结束（<strong>不包括结束</strong>）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p><p>语法：array.slice(begin, end);</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">'hello'</span>,<span class="string">'world'</span>]</span><br><span class="line"><span class="keyword">let</span> b=a.slice(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// ['hello']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'改变原数组'</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">// ['改变原数组','world'] ['hello']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [&#123;<span class="attr">name</span>:<span class="string">'OBKoro1'</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> b = a.slice()</span><br><span class="line"><span class="built_in">console</span>.log(b,a) <span class="comment">// [&#123;"name":"OBKoro1"&#125;]  [&#123;"name":"OBKoro1"&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name='改变原数组'</span></span><br><span class="line"><span class="comment">// console.log(b,a) // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;]</span></span><br></pre></td></tr></table></figure><h5 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h5><blockquote><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p><p>语法: array.join(str)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'hello'</span>,<span class="string">'world'</span>]</span><br><span class="line"><span class="keyword">let</span> str = a.join() <span class="comment">// 'hello,world'</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.join(<span class="string">'+'</span>) <span class="comment">// 'hello+world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [[<span class="string">'OBKoro1'</span>,<span class="string">'23'</span>],<span class="string">'test'</span>]</span><br><span class="line"><span class="keyword">let</span> str1 = a.join() <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123;<span class="attr">name</span>:<span class="string">'OBKoro1'</span>,<span class="attr">age</span>:<span class="string">'23'</span>&#125;,<span class="string">'test'</span>]</span><br><span class="line"><span class="keyword">let</span> str2 = b.join() <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为 [object Object] 字符串。</span></span><br></pre></td></tr></table></figure><h5 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h5><blockquote><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的  toLocaleString() 返回值经调用  join() 方法连接（由逗号隔开）组成。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123;</span><br><span class="line">    name: <span class="string">'OBKoro1'</span></span><br><span class="line">&#125;, <span class="number">23</span>, <span class="string">'abcd'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.join(<span class="string">","</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a.toString())</span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString(<span class="string">'en-us'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString(<span class="string">'zh-cn'</span>))</span><br><span class="line"></span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,Tue Feb <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> GMT+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,Tue Feb <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> GMT+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,<span class="number">2</span>/<span class="number">26</span>/<span class="number">2019</span>, <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> AM</span><br><span class="line">[object <span class="built_in">Object</span>],<span class="number">23</span>,abcd,<span class="number">2019</span>/<span class="number">2</span>/<span class="number">26</span> 上午<span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span></span><br></pre></td></tr></table></figure><h5 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h5><blockquote><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p><p>语法：var newArr =oldArray.concat(arrayX,arrayX,……,arrayX)</p><p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.concat(b) <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.concat(b, c) <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.concat(<span class="string">'添加元素'</span>,b, c,<span class="string">'再加一个'</span>)</span><br><span class="line"><span class="comment">// [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>,<span class="number">2</span> ]</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>,[<span class="number">4</span>]]</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.concat(f) <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure><h5 id="ES6扩展运算符-合并数组"><a href="#ES6扩展运算符-合并数组" class="headerlink" title="ES6扩展运算符 ... 合并数组"></a>ES6扩展运算符 <code>...</code> 合并数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> b = [ <span class="number">4</span>,...a, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure><h5 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h5><blockquote><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回0而不是-1</p><p>语法：array.indexOf(searchElement,fromIndex)</p><p>参数：</p><p>searchElement (必须):被查找的元素</p><p>fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p><p>严格相等的搜索:</p><p>数组的 indexOf 搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p><p><strong>注意</strong>：indexOf() 不能识别<code>NaN</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">'啦啦'</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'啦'</span>))  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'NaN'</span>))  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'啦啦'</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h5 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h5><blockquote><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p><p>语法：arr.lastIndexOf(searchElement,fromIndex)</p><p>参数:</p><p>searchElement(必须): 被查找的元素</p><p>fromIndex(可选): 逆向查找开始位置，默认值数组的 <code>长度-1</code>，即查找整个数组。</p><p>关于fromIndex有三个规则:</p><ol><li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li><li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li><li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'OB'</span>,<span class="number">4</span>,<span class="string">'Koro1'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">'Koro1'</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'Koro1'</span>] <span class="comment">// 数组长度为10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf('Koro1',4) // 从下标4开始往前找 返回下标2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf('Koro1',100) //  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf('Koro1',-11) // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b = a.lastIndexOf(<span class="string">'Koro1'</span>,<span class="number">-9</span>) <span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure><h5 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h5><blockquote><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法：array.includes(searchElement,fromIndex=0)</p><p>参数：</p><p>searchElement (必须):被查找的元素</p><p>fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。</p><p><strong>includes 方法是为了弥补 indexOf 方法的缺陷而出现的:</strong></p><ol><li>indexOf 方法不能识别 <code>NaN</code></li><li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 <code>-1</code> ，表达不够直观</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'OB'</span>,<span class="string">'Koro1'</span>,<span class="number">1</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="comment">// let b=a.includes(NaN) // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes('Koro1',100) // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes('Koro1',-3)  // true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes('Koro1',-100)  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/5b0903b26fb9a07a9d70c7e0" target="_blank" rel="noopener">js 数组详细操作方法及解析合集</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><h4 id="charAt-返回字符串字符"><a href="#charAt-返回字符串字符" class="headerlink" title="charAt 返回字符串字符"></a>charAt 返回字符串字符</h4><blockquote><p>从一个字符串中返回指定字符<br>如果指定的 index 值超出了该范围，则返回一个空字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyString = <span class="string">"Brave new world"</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.charAt(<span class="number">0</span>)) <span class="comment">// B</span></span><br></pre></td></tr></table></figure><h4 id="substring-返回字符串子集"><a href="#substring-返回字符串子集" class="headerlink" title="substring 返回字符串子集"></a>substring 返回字符串子集</h4><blockquote><p>返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</p><ul><li>如果 <code>indexStart</code> 等于 <code>indexEnd</code>，<code>substring</code> 返回一个空字符串。</li><li>如果省略 <code>indexEnd</code>，<code>substring</code> 提取字符一直到字符串末尾。</li><li>如果任一参数小于 0 或为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a>，则被当作 0。</li><li>如果任一参数大于 <code>stringName.length</code>，则被当作 <code>stringName.length</code>。</li><li>如果 <code>indexStart</code> 大于 <code>indexEnd</code>，则 <code>substring</code> 的执行效果就像两个参数调换了一样。见下面的例子。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyString = <span class="string">"Mozilla"</span></span><br><span class="line"><span class="comment">// 输出 "Moz"</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>,<span class="number">-3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">3</span>,<span class="literal">NaN</span>))</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">-2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="literal">NaN</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="replace-替换字符串"><a href="#replace-替换字符串" class="headerlink" title="replace 替换字符串"></a>replace 替换字符串</h4><blockquote><p>返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp" target="_blank" rel="noopener">正则表达式</a> ，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。</p></blockquote><h4 id="toLowerCase-toUpperCase-转换字母大小写"><a href="#toLowerCase-toUpperCase-转换字母大小写" class="headerlink" title="toLowerCase / toUpperCase 转换字母大小写"></a>toLowerCase / toUpperCase 转换字母大小写</h4><p>字母转为全小写或全大写</p><h2 id="什么是-JavaScript-作用链域？"><a href="#什么是-JavaScript-作用链域？" class="headerlink" title="什么是 JavaScript 作用链域？"></a>什么是 JavaScript 作用链域？</h2><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</p><p>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包-对闭包的理解"><a href="#什么是闭包-对闭包的理解" class="headerlink" title="什么是闭包/对闭包的理解"></a>什么是闭包/对闭包的理解</h3><p>函数中有另一个函数或有另一个对象，里面的函数或者是对象都可以使用外面函数中定义的变量或者参数，此时形成闭包。</p><blockquote><p>YouDontKnowJS对闭包的解释 —— 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。由于这个性质，<strong>闭包让我们能够从一个函数内部访问其外部函数的作用域</strong></p><p>闭包就是能够读取其他函数内部变量的函数。可以简单理解成“定义在一个函数内部的函数”</p></blockquote><h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ul><li><strong>保存</strong>：缓存数据，延长作用域链</li><li><strong>保护</strong>：形成私有作用域，保护里面私有变量不受外界干扰，避免全局污染</li></ul><blockquote><p>缺点：<strong>耗内存，耗性能</strong>，函数中的变量不能及时释放</p></blockquote><h3 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h3><p>要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。</p><p><strong>内部函数将能够访问到外部函数作用域中的变量</strong>，即使外部函数已经执行完毕。</p><p>想要缓存数据的时候就用闭包，把想要缓存的数据放在外层函数和内层函数的中间位置。</p><h3 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h3><h4 id="li-节点的-onclick-事件都能正确的弹出当前被点击的-li-索引"><a href="#li-节点的-onclick-事件都能正确的弹出当前被点击的-li-索引" class="headerlink" title="li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引"></a>li 节点的 onclick 事件都能正确的弹出当前被点击的 li 索引</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"testUL"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> index = 0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> index = 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> index = 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span> index = 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        nodes[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     <span class="comment">// &lt;----重点是此处返回了个一个匿名函数，这个函数能访问</span></span></span><br><span class="line"><span class="javascript">              <span class="comment">// 立即执行函数作用域内的i这个变量，形成闭包</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(i)</span></span><br><span class="line"><span class="javascript">            &#125; <span class="comment">//不用闭包的话，值每次都是4</span></span></span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h4><p>使用闭包定义能访问私有函数和私有变量的公有函数（也叫做模块模式）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)() <span class="comment">// 立即执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.value()) <span class="comment">// logs 0</span></span><br><span class="line">counter.increment()</span><br><span class="line">counter.increment()</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()) <span class="comment">// logs 2</span></span><br><span class="line">counter.decrement()</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()) <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure><p>环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。必须通过匿名包装器返回的对象的三个公共函数访问。</p><h3 id="解决-循环-闭包-问题"><a href="#解决-循环-闭包-问题" class="headerlink" title="解决 循环+闭包 问题"></a>解决 循环+闭包 问题</h3><p>直接 <a href="https://juejin.im/post/58f1fa6a44d904006cf25d22" target="_blank" rel="noopener">点击此处</a> 查看</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h3><ul><li>this 总是指向函数的直接调用者（而非间接调用者）</li><li>如果有 new 关键字，this 指向 new 出来的那个对象</li><li>在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 window</li></ul><p><strong>重要</strong>：</p><ul><li>普通函数的 this 指向是在函数的<strong>执行期间</strong>绑定的</li><li>箭头函数的 this 指向是在函数<strong>创建期间</strong>就绑定好了的，指向的是创建该箭头函数所在的作用域对象</li><li>一般不在事件（比如 onclick ）上传递箭头函数，使用 function 就好</li></ul><h3 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 <code>this</code></h3><blockquote><p>摘自 YouDontKnowJS</p></blockquote><p>现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 <code>this</code> 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。</p><ol><li>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。<br><code>var bar = new foo()</code></li><li>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。<br><code>var bar = foo.call( obj2 )</code></li><li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。<br><code>var bar = obj1.foo()</code></li><li>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。<br><code>var bar = foo()</code></li></ol><p>以上，就是理解对于普通的函数调用来说的 <code>this</code> 绑定规则 <em>所需的全部</em>。是的……几乎是全部。</p><h2 id="apply-call-bind-的区别"><a href="#apply-call-bind-的区别" class="headerlink" title="apply, call, bind 的区别"></a>apply, call, bind 的区别</h2><blockquote><p>apply, call, bind 本身存在于大 Function 构造函数的 prototype 中</p><p>所有的函数都是大 Function 的实例对象</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549791418436-78a38fa1-d824-45c0-8caa-7a6314637140.png" alt="apply"></p><p>apply, call, bind 方法都可以改变 this 的指向</p><ul><li>apply(对象, [参数1, 参数2, 餐数3, …])</li><li>call(对象, 参数1, 参数2, 餐数3,…)</li><li>bind(对象,参数1, 参数2, 餐数3,…)<ul><li>函数名称.bind()—-&gt;返回值是复制之后的这个函数</li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>apply，call 是调用的时候改变 this 指向，然后返回函数执行的结果。<ul><li>参数较多时用 apply ，参数较少时用 call</li></ul></li><li>bind 是复制一份函数并返回，并且这个函数的 this 指向变成了传入的第一个参数。</li></ul><h2 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><blockquote><p><strong>实例对象</strong>中有个属性 __proto__ ，是个对象，叫原型，不是标准的属性，浏览器使用的—–&gt;可以叫<strong>原型对象</strong></p><p><strong>构造函数</strong>中有一个属性 <strong>prototype</strong> ，也是个对象，叫原型，是标准属性，程序员使用—&gt;可以叫<strong>原型对象</strong></p><p><em>实例对象的 __proto__ 和构造函数中的 prototype 相等—&gt; true</em></p><p><em>又因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype</em></p><p><em>实例对象的 __proto__ 指向了构造函数的原型对象 prototype</em></p></blockquote><p>每个对象都会在其内部初始化一个属性，就是 prototype（原型）。原型就是 __proto__（IE8不支持，非标准属性） 或者是 prototype ，都是原型对象。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>共享数据，目的是：节省内存空间</li><li>实现继承，目的是：节省内存空间</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><p><strong>精简版</strong></p><p>原型链是一种关系，实例对象和原型对象之间的关系，关系是通过原型（<strong>proto</strong>）来联系的。</p><p><strong>详细版</strong></p><p>每个对象都会在其内部初始化一个属性 prototype（原型），当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p><p><strong>原型和原型链</strong><br><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549711479179-356c282c-60db-41ea-82df-5ebfb9550785.png" alt="prototype"></p><p><strong>原型链最终指向</strong><br><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1549711526339-9b043225-9ad9-4f88-b1b5-95da79cc4bf8.png" alt="原型链最终指向"></p><h3 id="分别使用原型链和-class-的方式实现继承"><a href="#分别使用原型链和-class-的方式实现继承" class="headerlink" title="分别使用原型链和 class 的方式实现继承"></a>分别使用原型链和 class 的方式实现继承</h3><h4 id="1-组合继承（原型链-借用构造函数）【不推荐】"><a href="#1-组合继承（原型链-借用构造函数）【不推荐】" class="headerlink" title="1. 组合继承（原型链 + 借用构造函数）【不推荐】"></a>1. 组合继承（原型链 + 借用构造函数）【不推荐】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, weight</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.weight = weight</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变原型指向----继承</span></span><br><span class="line"><span class="comment">// 我们让 Student.prototype 指向一个 Person 的实例对象</span></span><br><span class="line"><span class="comment">// 这个对象的 __proto__ 指向的是 Person.prototype</span></span><br><span class="line"><span class="comment">// 所以我们就可以借助这个实例对象拿到 sayHi 方法，实现继承</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">"Lance"</span>, <span class="number">20</span>, <span class="number">120</span>)</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">"Will"</span>, <span class="number">200</span> , <span class="number">110</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性和方法都被继承了</span></span><br></pre></td></tr></table></figure><p>由上面方案引出的问题：</p><h5 id="为什么不能-Student-prototype-Person-prototype"><a href="#为什么不能-Student-prototype-Person-prototype" class="headerlink" title="为什么不能 Student.prototype = Person.prototype"></a>为什么不能 Student.prototype = Person.prototype</h5><p>对象的赋值只是引用的赋值, 上面两者都指向同一个内存地址，只要随便通过 1 个途径就能修改该内存地址的对象，这样子类就无法单独扩展方法，因为会影响父类。</p><h5 id="单纯的原型链继承有什么缺陷"><a href="#单纯的原型链继承有什么缺陷" class="headerlink" title="单纯的原型链继承有什么缺陷"></a>单纯的原型链继承有什么缺陷</h5><p>虽然改变了原型的指向，但属性在初始化的时候就已经固定了【Student.prototype = new Person(“小明”, 29, 90)】，如果是多个对象实例化，那么每个实例对象的属性的初始值就都是一样的。换句话说，无法向父类传递参数。</p><h5 id="单纯的借用构造函数继承有什么缺陷"><a href="#单纯的借用构造函数继承有什么缺陷" class="headerlink" title="单纯的借用构造函数继承有什么缺陷"></a>单纯的借用构造函数继承有什么缺陷</h5><p>只能继承父类构造函数里面的属性和方法【Person.call(this, name, age)】，但父类的 prototype（原型）上的属性和方法不能继承。</p><h5 id="组合继承的缺点"><a href="#组合继承的缺点" class="headerlink" title="组合继承的缺点"></a>组合继承的缺点</h5><p>调用了两次父类的构造函数。第一次给子类的原型添加了父类构造函数中的属性方法，第二次又给子类的构造函数添加了父类的构造函数的属性方法，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>) <span class="comment">// 第二次调用SuperType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">// 第一次调用SuperType</span></span><br></pre></td></tr></table></figure><h4 id="2-寄生组合继承【推荐】"><a href="#2-寄生组合继承【推荐】" class="headerlink" title="2. 寄生组合继承【推荐】"></a>2. 寄生组合继承【推荐】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, weight</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">    <span class="keyword">this</span>.weight = weight</span><br><span class="line">    <span class="keyword">this</span>.study = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</span></span><br><span class="line">F.prototype = Person.prototype <span class="comment">// 创建了父类原型的浅复制</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Student.prototype.constructor = Student <span class="comment">// 修正原型的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="string">"Lance"</span>, <span class="number">19</span>, <span class="number">120</span>)</span><br><span class="line"><span class="built_in">console</span>.dir(stu1)</span><br></pre></td></tr></table></figure><h4 id="3-class-实现继承"><a href="#3-class-实现继承" class="headerlink" title="3. class 实现继承"></a>3. class 实现继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="comment">// 类本身的方法</span></span><br><span class="line">        <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 eat 相当于 prototype 中的 eat</span></span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键点：extends super</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, weight) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">        <span class="keyword">this</span>.weight = weight</span><br><span class="line">        <span class="keyword">this</span>.study = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">"Jerry"</span>, <span class="number">20</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.dir(stu)</span><br></pre></td></tr></table></figure><h3 id="原型链，proto-和-prototype-的区别"><a href="#原型链，proto-和-prototype-的区别" class="headerlink" title="原型链，proto 和 prototype 的区别"></a>原型链，proto 和 prototype 的区别</h3><p>对象拥有 __proto__ 属性，函数拥有 prototype 属性。某个实例对象的 __proto__ 指向构造它的构造函数的 prototype 属性。所以：实例对象的 __proto__ 指向了构造函数的原型对象 prototype<br>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'lc'</span>)</span><br><span class="line">b.__proto__ === B.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/lc237423551/article/details/80010100" target="_blank" rel="noopener"><strong>彻底理解什么是原型链，prototype和<strong>proto</strong>的区别。</strong></a></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>函数（包括构造函数）是对象</p><p>对象不一定是函数</p><p>对象有 __proto__</p><p>函数有 prototype</p></blockquote><h3 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h3><h4 id="字面量的方式"><a href="#字面量的方式" class="headerlink" title="字面量的方式"></a>字面量的方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Lance"</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用系统的构造函数"><a href="#调用系统的构造函数" class="headerlink" title="调用系统的构造函数"></a>调用系统的构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.name = <span class="string">'Lance'</span></span><br><span class="line">obj.age = <span class="number">20</span></span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new-操作符具体干了什么呢？"><a href="#new-操作符具体干了什么呢？" class="headerlink" title="new 操作符具体干了什么呢？"></a>new 操作符具体干了什么呢？</h4><ol><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;</span><br><span class="line">obj.__proto__ = Base.prototype</span><br><span class="line">Base.call(obj)</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="什么是事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#什么是事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="什么是事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>什么是事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><ol><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被  JavaScript 侦测到的行为。</li><li>事件处理机制：IE9以下只支持事件冒泡、Firefox、Chrome等则同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。</li><li>ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true）</li></ol><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1550160415749-0297296f-0559-485f-bfe4-05859bdc757a.jpeg" alt="事件阶段.jpg"></p><h3 id="事件绑定的三种方式"><a href="#事件绑定的三种方式" class="headerlink" title="事件绑定的三种方式"></a>事件绑定的三种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【 DOM0 级事件 】</span></span><br><span class="line"><span class="comment">// 第一种：作为属性，写在标签上</span></span><br><span class="line"><span class="comment">// &lt;div onclick="fun();"&gt;click&lt;/div&gt; ← 绑定在事件冒泡阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，使用 onclick</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"xxx"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;   <span class="comment">// ← 绑定在事件冒泡阶段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【 DOM2 级事件 】</span></span><br><span class="line"><span class="comment">// 第三种：使用推荐的标准模式</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"xxx"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 第三种可以改变事件绑定的阶段</span></span><br><span class="line"><span class="comment">// ---&gt; 为 false 时，绑定在事件冒泡阶段（默认下是绑定在冒泡阶段）</span></span><br><span class="line"><span class="comment">// ---&gt; 为 true 时，绑定在捕获阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果绑定在捕获阶段，监听函数就只在捕获阶段触发</span></span><br><span class="line"><span class="comment">// 如果绑定在冒泡阶段，监听函数只在冒泡阶段触发。</span></span><br></pre></td></tr></table></figure><h3 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h3><ul><li>无论是哪种绑定方式，对于同一个绑定元素，都是遵循先绑定的先执行原则。</li><li>如果是以 onclick 的方式绑定的，如果对同一个元素重复绑定的话，后面的会覆盖前面的。但是如果是以 addEventListener 方式绑定的话，同一个元素绑定多少次，就会执行多少次。</li><li>如果在 DOM 中直接使用 onclick ，则 onclick 的绑定是早于 addEventListener 的。</li></ul><h4 id="我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"><a href="#我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？" class="headerlink" title="我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"></a>我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</h4><p>会执行两次事件，按代码执行顺序来</p><p><strong>规律</strong>：绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照<a href="https://www.baidu.com/s?wd=W3C&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">W3C</a>的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>绑定在父级元素，利用事件冒泡去触发父级事件处理函数的一种技巧。</p><h4 id="实现一个事件委托"><a href="#实现一个事件委托" class="headerlink" title="实现一个事件委托"></a>实现一个事件委托</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">element, eventType, targetElement, fn</span>) </span>&#123;</span><br><span class="line">    element.addEventListener(eventType, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 先拿到当前事件的直接触发对象</span></span><br><span class="line">        <span class="keyword">var</span> curTarget = e.target</span><br><span class="line">        <span class="comment">// 看它是不是使用者监听的目标对象类型</span></span><br><span class="line">        <span class="comment">// 一旦发现不是，就执行循环</span></span><br><span class="line">        <span class="keyword">while</span>(!curTarget.matches(targetElement)) &#123;</span><br><span class="line">            <span class="comment">// 先看看当前对象是不是和父元素相同</span></span><br><span class="line">            <span class="comment">// 相同则把当前对象置为空，且不执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (curTarget === element) &#123;</span><br><span class="line">                curTarget = <span class="literal">null</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不相同则把当前对象设置成自己的父对象</span></span><br><span class="line">            curTarget = curTarget.parentNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是，则先看当前对象有没有值，有值则执行回调函数</span></span><br><span class="line">        curTarget &amp;&amp; fn(e, curTarget, e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen(ul, <span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event, el)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery 使用方式</span></span><br><span class="line">$(<span class="string">"ul"</span>).on(<span class="string">"click"</span>, <span class="string">"li"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log($(e.target).html());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这个 on 事件是绑定在 ul 上面的，li 是目标元素，</span></span><br><span class="line"><span class="comment">// on 事件内部是通过 e.target 来判断点击元素是不是 li 的</span></span><br></pre></td></tr></table></figure><h3 id="什么是节流和防抖"><a href="#什么是节流和防抖" class="headerlink" title="什么是节流和防抖"></a>什么是节流和防抖</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>debounce（防抖）的作用是在让在用户动作停止后延迟x ms再执行回调</li><li>throttle（节流）的作用是在用户动作时每隔一定时间（如200ms）执行一次回调</li></ul><h4 id="节流防抖作用"><a href="#节流防抖作用" class="headerlink" title="节流防抖作用"></a>节流防抖作用</h4><ul><li>debounce 应用在搜索框的即时搜索（input 事件），避免用户狂按键盘导致的频繁请求</li><li>throttle 应用在监听 resize 改变布局或 onscroll 滚动</li></ul><p><strong>防抖</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" oninput="change()"&gt;</span></span><br><span class="line"><span class="comment">// 防抖（一段时间会等，然后带着一起做了）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">window</span>.clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> change = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">"input"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(input.value)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>节流</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div class="sw"&gt;23333&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// 节流（一段时间执行一次之后，就不执行第二次）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (canUse) &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">      canUse = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>canUse = <span class="literal">true</span>, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sw = <span class="built_in">document</span>.querySelector(<span class="string">".sw"</span>)</span><br><span class="line"></span><br><span class="line">sw.addEventListener(<span class="string">"click"</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_37860930/article/details/83545473‘" target="_blank" rel="noopener">在React、Vue和小程序中使用函数节流和函数防抖</a></li><li><a href="https://zhuanlan.zhihu.com/p/38313717" target="_blank" rel="noopener">函数防抖与函数节流</a></li><li><a href="http://www.webfront-js.com/articaldetail/99.html" target="_blank" rel="noopener">JS事件中防抖debounce和节流throttle概念原理的学习</a></li></ul><h3 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h3><ul><li>mouseover：<br>不论鼠标指针穿过被选元素或其子元素，都会触发 <code>mouseover</code> 事件。<br>支持事件冒泡。<br>相对应 <code>mouseout</code> 事件。</li><li>mouseenter：<br>只有在鼠标指针穿过被选元素时，才会触发 <code>mouseenter</code> 事件。<br>不支持事件冒泡。<br>相对应 <code>mouseleave</code> 事件。</li></ul><p>参考：<a href="https://blog.csdn.net/u010297791/article/details/57412796" target="_blank" rel="noopener">JavaScript中的 mouseover 与 mouseenter ，mouseout 和 mouseleave 的区别</a></p><h2 id="ES6相关"><a href="#ES6相关" class="headerlink" title="ES6相关"></a>ES6相关</h2><h3 id="ES6-用到过吗，新增了哪些东西，你用到过什么？"><a href="#ES6-用到过吗，新增了哪些东西，你用到过什么？" class="headerlink" title="ES6 用到过吗，新增了哪些东西，你用到过什么？"></a>ES6 用到过吗，新增了哪些东西，你用到过什么？</h3><ul><li><p><code>let</code> 和 <code>const</code></p></li><li><p>模板字符串</p></li><li><p>箭头函数（自己没有 this ，从自己的作用域链的<code>上一层继承 this</code> ）</p></li><li><p><code>for-of</code>（用来遍历数据—例如数组中的值）e.g. Array，String，Set，Map</p></li><li><p><code>arguments</code> 对象可被不定参数和默认参数完美代替</p></li><li><p>Promise</p></li><li><p>数组的拓展</p><ul><li>数组.find((item,index,arr) =&gt; {条件}) 返回满足条件的第一个元素的值。否则返回 undefined</li><li>数组.findIndex((item,index,arr)=&gt;{…}) 返回满足条件的第一个元素的索引值。否则返回 -1</li><li>数组.includes(数据,[searchIndex]) 判断数据是否在数组中,第二个参数(可选参数)为从指定索引处(包含索引处的值)开始搜索 返回布尔值(es7时加入)</li><li>扩展运算符 …</li></ul></li><li><p>引入 <code>module</code> 模块的概念</p></li></ul><h3 id="const-和-let-区别"><a href="#const-和-let-区别" class="headerlink" title="const 和 let 区别"></a>const 和 let 区别</h3><ul><li>let 定义变量可以只声明不赋值</li><li>const 定义常量声明时必须赋值，一旦定义不可轻易改变值</li></ul><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>解决 var 没有块作用域、变量提升、可以重复声明的问题。let 和 const 有自己的块作用域，不存在变量提升问题，同一块作用域中不可重复声明（会报错）</p><h4 id="let-var-区别"><a href="#let-var-区别" class="headerlink" title="let var 区别"></a>let var 区别</h4><ul><li><p>var 有变量提升，let 没有</p></li><li><p>let 的作用域是块，而 var 的作用域是函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">4</span> <span class="comment">// The scope is inside the if-block</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> <span class="comment">// The scope is inside the function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>let 有暂时性死区，只要 let/const 声明的变量，在未声明之前使用或者赋值都会报错（ReferenceError）</p></li><li><p>let 不能重复定义</p></li></ul><h4 id="可以改变-const-定义的某个对象的属性吗"><a href="#可以改变-const-定义的某个对象的属性吗" class="headerlink" title="可以改变 const 定义的某个对象的属性吗"></a>可以改变 const 定义的某个对象的属性吗</h4><p>可以，因为对象是复杂类型，const 存储的是引用，所以改变对象的成员不会报错，但不建议这样做。</p><h3 id="箭头函数（-this-指向）"><a href="#箭头函数（-this-指向）" class="headerlink" title="箭头函数（ this 指向）"></a>箭头函数（ this 指向）</h3><ul><li>箭头函数，本质上，就是一个匿名函数</li><li>箭头函数无法通过 call、apply、bind 来手动改变内部 this 指向</li><li>箭头函数：自动 .bind(this) 也就是说箭头函数中的 this 指向与其所在作用域的 this 指向相同</li></ul><p><strong>总结</strong>：</p><p>箭头函数不会创建自己的 <code>this</code> ，它只会从自己的作用域链的 <code>上一层继承 this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this` 作为它自己的实例.</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在非严格模式, growUp() 函数定义 `this`作为全局对象, </span></span><br><span class="line">    <span class="comment">// 与在 Person() 构造函数中定义的 `this`并不相同.</span></span><br><span class="line">    <span class="keyword">this</span>.age++</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++ <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Set 是有序列表，类似于数组，但是没有重复值</li><li>Map 是存储许多键值对的有序列表，key 和 value 支持所有数据类型</li></ul><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>都是有序列表</li><li>Set 值不重复；Map 键不重复</li></ul><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><blockquote><p>SET</p></blockquote><ul><li><p>属性：</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 Set 函数</li><li><code>Set.prototype.size</code>：返回实例的成员总数</li></ul></li><li><p>操作方法：</p><ul><li><code>add(value)</code>：添加一个值，返回Set结构本身</li><li><code>delete(value)</code>：删除某个值，返回布尔值</li><li><code>has(value)</code>：返回布尔值，表示是否是成员</li><li><code>clear()</code>：清除所有成员，无返回值</li></ul></li><li><p>遍历方法（ key() 和 values() 行为是一致的。）</p><ul><li><code>keys()</code>：返回键名的遍历器（什么是遍历器？Iterator）</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>MAP</p></blockquote><ul><li><p>属性</p><ul><li><code>size</code> ：返回 Map 结构的成员总数。</li></ul></li><li><p>操作方法</p><ul><li><code>set(key, value)</code>: <code>set</code> 方法设置键名 <code>key</code> 对应的键值为 <code>value</code> ，然后返回整个 Map 结构。</li><li><code>get(key)</code> ：<code>get</code> 方法读取 <code>key</code> 对应的键值，如果找不到 <code>key</code> ，返回 <code>undefined</code> 。</li><li><code>has(key)</code>：<code>has</code> 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li><code>delete(key)</code>：<code>delete</code> 方法删除某个键，返回 <code>true</code> 。如果删除失败，返回 <code>false</code> 。<ul><li><code>clear()</code>：<code>clear</code>方法清除所有成员，没有返回值。</li></ul></li></ul></li><li><p>遍历方法</p><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><code>forEach()</code>：遍历 Map 的所有成员。</li></ul></li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>Set 集合可以用来过滤数组中重复的元素，只能通过 has 方法检测指定的值是否存在，或者是通过 forEach 处理每个值。</p><p>Map 集合通过 set() 添加键值对，通过 get() 获取键值，各种方法的使用查看文章教程，你可以把它看成是比 Object 更加强大的对象。</p><h4 id="Set-与-数组-的区别"><a href="#Set-与-数组-的区别" class="headerlink" title="Set 与 数组 的区别"></a>Set 与 数组 的区别</h4><p>set不可重复，array可重复</p><h4 id="Map-与-对象-的区别"><a href="#Map-与-对象-的区别" class="headerlink" title="Map 与 对象 的区别"></a>Map 与 对象 的区别</h4><ul><li>Object 的键只能是字符串或者 symbol ，Map 的键可以是任意类型的值（包括对象）</li><li>Map 可以通过 size 获取元素个数，对象得遍历。</li><li>Map 是有序的（根据用户插入的顺序进行排序），对象排序有自己规则（比如先排数字开头的 key ，再到字符串）</li><li><code>Map</code> 可直接进行迭代，而 <code>Object</code> 的迭代需要先获取它的键数组，然后再进行迭代。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">"name"</span>, <span class="string">"Lance"</span>)</span><br><span class="line">map.set(<span class="string">"age"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per = &#123;</span><br><span class="line">    name: <span class="string">'Jerry'</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(attr)</span><br><span class="line">&#125; <span class="comment">// Lance 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> <span class="built_in">Object</span>.keys(per)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(per[attr])</span><br><span class="line">&#125; <span class="comment">// Jerry 19</span></span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="promise-是什么"><a href="#promise-是什么" class="headerlink" title="promise 是什么"></a>promise 是什么</h4><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p><h4 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h4><p>异步网络请求的回调地狱，而且我们还得对每次请求的结果进行一些处理，代码会更加臃肿。</p><h4 id="promise-使用场景有哪些"><a href="#promise-使用场景有哪些" class="headerlink" title="promise 使用场景有哪些"></a>promise 使用场景有哪些</h4><ul><li>ajax请求得到返回值的时间不同,有了 callback 的回调结果之后才能知道接下来应该做什么</li><li>node 中读取文件</li></ul><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//defined Promise async function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">            resolve(<span class="comment">/*resolve parameter*/</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="comment">/*Error*/</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use Promise&amp;then</span></span><br><span class="line">asyncFun().then(<span class="comment">/*function*/</span>).then(<span class="comment">/*function*/</span>)...</span><br></pre></td></tr></table></figure><h4 id="promise-特性"><a href="#promise-特性" class="headerlink" title="promise 特性"></a>promise 特性</h4><p>参考：<a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></p><h4 id="promise-里面-return-一个-string，和在-resolve-一个-string-的区别"><a href="#promise-里面-return-一个-string，和在-resolve-一个-string-的区别" class="headerlink" title="promise 里面 return 一个 string，和在 resolve 一个 string 的区别"></a>promise 里面 return 一个 string，和在 resolve 一个 string 的区别</h4><p>return 一个 string 后续的 then 不会执行; resolve 一个 string 会返回一个 promise 对象，对象的值是这个 string</p><h4 id="在-then-里面-throw-一个-error，怎么捕捉"><a href="#在-then-里面-throw-一个-error，怎么捕捉" class="headerlink" title="在 then 里面 throw 一个 error，怎么捕捉"></a>在 then 里面 throw 一个 error，怎么捕捉</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw 这个 error 后，在紧挨的下一个 then 中添加两个回调方法（ resolve 的，和 reject ）。</span></span><br><span class="line"><span class="comment">// 然后在第二个 reject 方法中可以捕获</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(<span class="string">"返回Promise"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"第一个then"</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"我是错误"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(resolve)</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"紧挨的失败"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"catch错误"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 第一个then</span></span><br><span class="line"><span class="comment">// 紧挨的失败</span></span><br><span class="line"><span class="comment">// Error: 我是错误</span></span><br><span class="line"><span class="comment">// at Promise.then.data (&lt;anonymous&gt;:6:15)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 then 的链式调用后添加一个 catch 来捕获</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="string">"返回Promise"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个then"</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"我是错误"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then错误"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch错误"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 第一个 then</span></span><br><span class="line"><span class="comment">// catch 错误</span></span><br><span class="line"><span class="comment">// Error: 我是错误</span></span><br><span class="line"><span class="comment">// at Promise.then.data</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-封装一个-url"><a href="#使用-Promise-封装一个-url" class="headerlink" title="使用 Promise 封装一个 url"></a>使用 Promise 封装一个 url</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">''</span></span><br><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="params">url</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123; <span class="comment">// &lt;= 请求已完成，且响应已就绪</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123; <span class="comment">// &lt;= 状态OK</span></span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"请求失败"</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getJSON(url).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><h4 id="在-Promise-链式调用中，怎样才能保证上一个-promise-出现报错不会影响到后续-then-的正常执行"><a href="#在-Promise-链式调用中，怎样才能保证上一个-promise-出现报错不会影响到后续-then-的正常执行" class="headerlink" title="在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行"></a>在 Promise 链式调用中，怎样才能保证上一个 promise 出现报错不会影响到后续 .then 的正常执行</h4><p>为了不影响后续 .then 的执行，需要在每一个 then 中指定失败的回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> asyncFunc = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"123"</span>)                 <span class="comment">// 123, 二楼</span></span><br><span class="line">  <span class="comment">// throw new Error("出错了")    // Error: 出错了, 二楼</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncFunc().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"二楼"</span>)</span><br><span class="line">&#125;, err =&gt; &#123;                      <span class="comment">// &lt;====== 指定失败的回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"二楼"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> <span class="keyword">new</span>的时候会立即执行里面的代码 then是微任务 会在本次任务执行完的时候执行 setTimeout是宏任务 会在下次任务执行的时候执行</span><br></pre></td></tr></table></figure><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async / Await"></a>Async / Await</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul><li>async 用于声明一个异步的 function</li><li>await 用于等待一个异步方法执行完成</li></ul><h4 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h4><p>async 函数会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><h4 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h4><p>await 是在等待一个 async 函数完成。不过按 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">语法说明</a> ，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"something"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello async"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething()</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync()</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>让代码更易读</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。</p><p>传统 promise ，链式调用 then 一个接一个</p><p>改用 async/await 后就像同步代码一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>)</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span></span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt()</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span></span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1)</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解 JavaScript 的 async/await</a></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前后的形式必须完全一致 才可以完成结构赋值</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>]</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>]</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 如果解构不成功，变量的值就等于undefined。</span></span><br></pre></td></tr></table></figure><h4 id="对象用法"><a href="#对象用法" class="headerlink" title="对象用法"></a>对象用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span></span><br><span class="line">&#123;name, age&#125; = &#123;<span class="attr">name</span>:<span class="string">'wang'</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">name <span class="comment">// wang</span></span><br><span class="line">age <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持别名</span></span><br><span class="line">&#123;<span class="attr">name</span>:nname, age&#125; = &#123;<span class="attr">name</span>:<span class="string">'wang'</span>,<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">name <span class="comment">// '' 取别名时原名就会为空字符串</span></span><br><span class="line">nname <span class="comment">// wang</span></span><br><span class="line">age <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h4 id="…运算符"><a href="#…运算符" class="headerlink" title="…运算符"></a>…运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="function">(<span class="params">...sum</span>) =&gt;</span> &#123;sum.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))&#125;</span><br><span class="line">app(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="comment">// 此运算符或得值为数组形式 主要用于替代函数中的 arguments(伪数组) 属性</span></span><br><span class="line"><span class="comment">// 这样可以非常方便的遍历获取到的未知个数的实参</span></span><br></pre></td></tr></table></figure><h3 id="函数中的-rest（剩余）参数"><a href="#函数中的-rest（剩余）参数" class="headerlink" title="函数中的 rest（剩余）参数"></a>函数中的 rest（剩余）参数</h3><blockquote><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p><p>——&gt; MDN - <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数和-arguments-对象的区别"><a href="#剩余参数和-arguments-对象的区别" class="headerlink" title="剩余参数和 arguments 对象的区别"></a>剩余参数和 arguments 对象的区别</h4><p>剩余参数和 <code>arguments</code> 对象之间的区别主要有三个：</p><ul><li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li><li><code>arguments</code> 对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code> 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code> 或 <code>pop</code> 。</li><li><code>arguments</code> 对象还有一些附加的属性 （如 <code>callee</code> 属性）。<ul><li>arguments.callee 属性包含当前正在执行的函数。</li></ul></li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="模块化发展"><a href="#模块化发展" class="headerlink" title="模块化发展"></a>模块化发展</h4><p>无模块化 –&gt; CommonJS规范 –&gt; AMD规范 –&gt; CMD规范 –&gt; ES6模块化</p><h4 id="无模块劣势"><a href="#无模块劣势" class="headerlink" title="无模块劣势"></a>无模块劣势</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"jquery_scroller.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">被依赖的放在前面，否则使用就会报错</span><br><span class="line">污染全局作用域</span><br><span class="line">维护成本高</span><br><span class="line">依赖关系不明显</span><br></pre></td></tr></table></figure><h4 id="CommonJS规范（NodeJS）"><a href="#CommonJS规范（NodeJS）" class="headerlink" title="CommonJS规范（NodeJS）"></a>CommonJS规范（NodeJS）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">  add,</span><br><span class="line">  basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>)</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p><strong>exports 是对 module.exports 的引用</strong>。比如我们可以认为在一个模块的顶部有这句代码： <code>exports = module.exports</code> 所以，我们不能直接给 <code>exports</code> 赋值:</p><ul><li>✅ exports.foo = ‘bar’</li><li>❌ exports = {foo: ‘bar’} //error 这种方式是错误的，相当于重新定义了 exports</li></ul><p><strong>优点</strong></p><p>解决了依赖、全局变量污染的问题</p><p><strong>缺点</strong></p><p>CommonJS 用同步的方式加载模块，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。所以<strong>不适合浏览器端模块加载</strong>，更合理的方案是使用异步加载。</p><h4 id="AMD规范（RequireJS）"><a href="#AMD规范（RequireJS）" class="headerlink" title="AMD规范（RequireJS）"></a>AMD规范（RequireJS）</h4><p>AMD规范采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入 require.js 及 main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用 config() 指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>适合在浏览器环境中异步加载模块、并行加载多个模块</p><p><strong>缺点</strong></p><p>必须要<strong>提前加载所有的依赖</strong>，然后才可以使用，而不是需要使用时再加载。（<strong>不能按需加载</strong>）</p><h4 id="CMD（SeaJS）"><a href="#CMD（SeaJS）" class="headerlink" title="CMD（SeaJS）"></a>CMD（SeaJS）</h4><p>与AMD类似，不同点在于：</p><ul><li>AMD 推崇依赖前置、提前执行</li><li>CMD 推崇依赖就近、延迟执行。</li></ul><p><strong>CMD 与 AMD 区别</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.doSomething()</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>) <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething()</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为<strong>浏览器和服务器通用</strong>的模块解决方案。其模块功能主要由两个命令构成： <code>export</code> 和 <code>import</code> 。 <code>export</code> 命令用于规定模块的对外接口，<code>import</code> 命令用于输入其他模块提供的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = add(<span class="number">99</span> + basicNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es6 在导出的时候有一个默认导出， <code>export default</code> ，使用它导出后，在 import 的时候，不需要加上 {} ，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** export default **/</span></span><br><span class="line"><span class="comment">//定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = math.add(<span class="number">99</span> + math.basicNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li><li><a href="https://juejin.im/post/5b4420e7f265da0f4b7a7b27" target="_blank" rel="noopener">这一次，我要弄懂javascript的模块化</a></li></ul><h4 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h4><p><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="noopener">立即执行函数</a>,不暴露私有成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    m1,</span><br><span class="line">    m2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="Ajax-是什么-如何创建一个Ajax？"><a href="#Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个Ajax？"></a>Ajax 是什么? 如何创建一个Ajax？</h4><p>使用 JavaScript 异步获取数据，而且页面不会发生整页刷新的，提高了用户体验。</p><ol><li>创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</li><li>创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</li><li>设置响应 HTTP 请求状态变化的函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'./time.php'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 xhr 的 readyState 判断此次请求的响应是否接收完成</span></span><br><span class="line">    <span class="comment">// 4代表done</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过 xhr 的 responseText 获取到响应的响应体</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h4><ol><li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)</li><li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)</li><li>在URL后面加上一个随机数： “fresh=” + Math.random()</li><li>在URL后面加上时间戳：”nowtime=” + new Date().getTime()</li></ol><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p>同源策略是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口</strong> 完全相同，只有同源的地址才可以相互通过 AJAX 的方式请求。</p><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>借助于 <code>script</code> 标签发送跨域请求的技巧</p><p><strong>原理</strong></p><p>css，script 标签允许跨域。客户端借助 <code>script</code> 标签请求服务端的一个动态网页（php 文件），服务端的这个动态网页返回一段带有函数调用的 JavaScript 全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。</p><p>客户端：</p><ul><li>foo(…arr) {console.log(arr.join(“,”))} 定义方法，名称随便</li><li><script src="http://api.zce.me/users.php?callback=foo"></script><ul><li>服务端会获取参数名 callback 的值 foo ，然后把数据扔进 foo 中调用</li><li>一旦数据返回，就相当于在调用上面的 foo</li></ul></li></ul><p>服务端：</p><ul><li>foo([‘我’, ‘是’, ‘你’, ‘原’, ‘本’, ‘需’, ‘要’, ‘的’, ‘数’, ‘据’])</li></ul><p><strong>特色</strong></p><ol><li>JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数</li><li>只能发送 GET 请求</li></ol><h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h4><p>服务端设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端请求头设置：允许远端访问</span></span><br><span class="line">header(<span class="string">'Access‐Control‐Allow‐Origin: *'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个  </span></span><br><span class="line"><span class="comment">// Access-Control-Allow-Origin  的响应头，表示这个资源是否允许指定域请求。</span></span><br></pre></td></tr></table></figure><p>如果跨域 + 发送 cookie：</p><ul><li>前端：withCredentials = true</li><li>后端：Access-Control-Allow-Origin 不为 * ，(Access-Control-Allow-Credentials, true)</li><li>如果还需要发送 post 请求：<ul><li>前端：<ul><li>post:[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</li><li>qs.stringify(): 对象序列化成URL的形式，以 &amp; 进行拼接</li></ul></li></ul></li></ul><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>除此之外，还可以通过前端设置代理实现跨域，原理是利用后端不存在跨域问题。比如可以在 <code>@vue/cli</code> 项目中新建 <code>vue.config.js</code> 文件来配置代理。如果你想了解更多这方面的设置，可以阅读我的这篇博客 <a href="https://evestorm.github.io/posts/15391/" target="_blank" rel="noopener">Axios异步请求跨域解决方案</a></p><h3 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h3><p>参考：<a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000640869</a></p><h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><h3 id="JSON-的了解"><a href="#JSON-的了解" class="headerlink" title="JSON 的了解"></a>JSON 的了解</h3><p>一种轻量级的数据交换格式。 它是基于 JavaScript 的一个子集。</p><p>数据格式简单、易于读写、占用带宽小。 e.g. {“age”:”12”, “name”:”back”}</p><p>JSON读写的基本封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = &#123;</span><br><span class="line">    <span class="keyword">set</span>: (key, val) =&gt; &#123;</span><br><span class="line">        localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(val))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: key =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(localStorage.getItem(key) === <span class="literal">null</span> ? <span class="string">'[]'</span> : localStorage.getItem(key))</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        localStorage.removeItem(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> storage</span><br></pre></td></tr></table></figure><h4 id="JSON-方法的缺点"><a href="#JSON-方法的缺点" class="headerlink" title="JSON 方法的缺点"></a>JSON 方法的缺点</h4><ul><li>不能复制function、正则、Symbol</li><li>循环引用报错</li><li>相同的引用会被重复复制</li></ul><h2 id="概念性问题"><a href="#概念性问题" class="headerlink" title="概念性问题"></a>概念性问题</h2><h3 id="你理解的面向对象"><a href="#你理解的面向对象" class="headerlink" title="你理解的面向对象"></a>你理解的面向对象</h3><p>一种编程开发思想。是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><ul><li>优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow</li><li>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用 flash 上传，但如果浏览器支持  HTML5 的文件上传功能，则使用 HTML5 实现更好的体验</li></ul><h3 id="compose-函数-❌"><a href="#compose-函数-❌" class="headerlink" title="compose 函数 ❌"></a>compose 函数 ❌</h3><h3 id="函数柯里化-❌"><a href="#函数柯里化-❌" class="headerlink" title="函数柯里化 ❌"></a>函数柯里化 ❌</h3><h1 id="JS笔试题"><a href="#JS笔试题" class="headerlink" title="JS笔试题"></a>JS笔试题</h1><h2 id="JS类型相关"><a href="#JS类型相关" class="headerlink" title="JS类型相关"></a>JS类型相关</h2><h3 id="typeof-没定义的变量会报错吗？typeof-let定义了的呢？"><a href="#typeof-没定义的变量会报错吗？typeof-let定义了的呢？" class="headerlink" title="typeof 没定义的变量会报错吗？typeof let定义了的呢？"></a>typeof 没定义的变量会报错吗？typeof let定义了的呢？</h3><ul><li>未声明的变量使用 typeof 返回字符串 “undefined”</li><li>typeof 一个 let 定义的变量会因为暂时性死区报错 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" target="_blank" rel="noopener">ReferenceError</a>（前提：let/const 未声明之前赋值或使用）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span> <span class="comment">// ReferenceError: tmp is not defined</span></span><br><span class="line">  <span class="keyword">let</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> tmp) <span class="comment">// ReferenceError: tmp is not defined</span></span><br><span class="line"><span class="keyword">let</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tmp</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> tmp) <span class="comment">// undefined 不会报错</span></span><br></pre></td></tr></table></figure><h3 id="typeof-的值有哪些"><a href="#typeof-的值有哪些" class="headerlink" title="typeof 的值有哪些"></a>typeof 的值有哪些</h3><p>7种数据类型（返回的都是字符串形式）：</p><p>string, number, function, object, undefined, boolean, symbol（表独一无二的值）</p><p>注意：</p><ul><li>null 和 数组 返回的都是 object</li><li>NaN 返回的是 number</li></ul><h3 id="valueOf-和-toString"><a href="#valueOf-和-toString" class="headerlink" title="valueOf 和 toString"></a>valueOf 和 toString</h3><ul><li>toString(): 返回对象的字符串表示。</li><li>valueOf(): 返回对象的字符串、数值或布尔值表示。</li></ul><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="判断一个单词是否是回文"><a href="#判断一个单词是否是回文" class="headerlink" title="判断一个单词是否是回文"></a>判断一个单词是否是回文</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"mamam"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPalindrom</span>(<span class="params">str</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> str === str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><ul><li><strong>输入:</strong> “A man, a plan, a canal: Panama”        <strong>输出:</strong> true</li><li><strong>输入:</strong> “race a car”                                      <strong>输出:</strong> false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/[^A-Za-z0-9]/g</span></span><br><span class="line">    <span class="keyword">var</span> tempStr = s.replace(reg, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">var</span> reverseStr = tempStr.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> reverseStr.toLowerCase() === tempStr.toLowerCase()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(str))</span><br></pre></td></tr></table></figure><h3 id="统计字符串出现最多的字母"><a href="#统计字符串出现最多的字母" class="headerlink" title="统计字符串出现最多的字母"></a>统计字符串出现最多的字母</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"afjghdfraaaasdenas"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">1</span>) <span class="keyword">return</span> str</span><br><span class="line">    <span class="keyword">let</span> charObj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!charObj[str.charAt(i)]) &#123;</span><br><span class="line">            charObj[str.charAt(i)] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            charObj[str.charAt(i)] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxChar = <span class="string">''</span>,</span><br><span class="line">        maxValue = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> charObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charObj[key] &gt;= maxValue) &#123;</span><br><span class="line">            maxChar = key</span><br><span class="line">            maxValue = charObj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxChar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h3><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><ul><li>s = “leetcode”          返回 0.</li><li>s = “loveleetcode”    返回 2.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"leetcode"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstUniqChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> curChar = str[i]</span><br><span class="line">    <span class="keyword">if</span> (str.lastIndexOf(curChar) === str.indexOf(curChar)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(firstUniqChar(str))</span><br></pre></td></tr></table></figure><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p>即判断字符串中是否只有字符的位置不同，也就是判断两个字符串中包含的字符以及这些字符出现的次数是否相同</p><ul><li><strong>输入:</strong> <em>s</em> = “anagram”, <em>t</em> = “nagaram”        <strong>输出:</strong> true</li><li><strong>输入:</strong> <em>s</em> = “rat”, <em>t</em> = “car”                        <strong>输出:</strong> false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> ss = s.split(<span class="string">""</span>).sort().join(<span class="string">""</span>)</span><br><span class="line">  <span class="keyword">var</span> tt = t.split(<span class="string">""</span>).sort().join(<span class="string">""</span>)</span><br><span class="line">  <span class="keyword">return</span> ss === tt ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isAnagram(s, t))</span><br></pre></td></tr></table></figure><h3 id="判断一个给定的字符串是否是同构的"><a href="#判断一个给定的字符串是否是同构的" class="headerlink" title="判断一个给定的字符串是否是同构的"></a>判断一个给定的字符串是否是同构的</h3><blockquote><p>输入: s = “egg”, t = “add”<br>输出: true<br>输入: s = “foo”, t = “bar”<br>输出: false</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isIsomorphic = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.indexOf(s[i]) != t.indexOf(t[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="报数"><a href="#报数" class="headerlink" title="报数"></a>报数</h3><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。</p><p><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。</p><p><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从1开始报数</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">'1'</span></span><br><span class="line">    <span class="comment">// 循环第 N 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 默认当前连续的数字的次数为1</span></span><br><span class="line">        <span class="keyword">var</span> repeatCount = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">''</span></span><br><span class="line">        <span class="comment">// 循环当前数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result[j], result[j + <span class="number">1</span>])</span><br><span class="line">            <span class="comment">// 当前数字和后面一个是否相同，相同则重复数计数+1</span></span><br><span class="line">            <span class="keyword">if</span> (result[j] === result[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                repeatCount++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就把到目前为止的报数“读出来”</span></span><br><span class="line">                str += repeatCount + result[j]</span><br><span class="line">                repeatCount = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前第N次报数的结果，下次报数以此为准</span></span><br><span class="line">        result = str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><ul><li><strong>输入:</strong> [“flower”,”flow”,”flight”]    <strong>输出:</strong> “fl”</li><li><strong>输入:</strong> [“dog”,”racecar”,”car”]      <strong>输出:</strong> “”</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestCommonPrefix</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> firstStr = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; firstStr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstStr[i] !== arr[j][i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result += firstStr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(longestCommonPrefix(arr))</span><br></pre></td></tr></table></figure><h3 id="生成指定长度的随机字母数字字符串"><a href="#生成指定长度的随机字母数字字符串" class="headerlink" title="生成指定长度的随机字母数字字符串"></a>生成指定长度的随机字母数字字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomStr</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++ ) &#123;</span><br><span class="line">        str += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(<span class="number">0</span>, len)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr)</span><br><span class="line"></span><br><span class="line">arr.constructor === <span class="built_in">Array</span> <span class="comment">// 前提是保证 constructor 不会被更改</span></span><br><span class="line"><span class="comment">// 不能使用 typeof 因为 它返回的是个 'object'</span></span><br></pre></td></tr></table></figure><h3 id="JS数组去重"><a href="#JS数组去重" class="headerlink" title="JS数组去重"></a>JS数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123;&#125;, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：indexOf去重（无法对 对象，NaN 识别去重）</span></span><br><span class="line"><span class="comment">// → indexOf 不认 NaN，遇到NaN就返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDistinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回数组：[ 1, '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]</span></span><br><span class="line"><span class="comment">// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：filter + indexOf（对 对象 和 NaN 无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDistinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = arr.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 重复的值的索引肯定大于第一次出现这个值的索引，不会被返回</span></span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回数组：[ 1, '1', &#123;&#125;, &#123;&#125; ]</span></span><br><span class="line"><span class="comment">// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：filter 升级版（解决了 对象 和 NaN 的问题）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDistinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 由于对象的键值只能是字符串，导致 1 和 '1' 被认为是相同的值，所以下方使用 typeof item + item 拼成字符串作为 key 值来避免这个问题</span></span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) </span><br><span class="line">              ? <span class="literal">false</span> </span><br><span class="line">              : obj[<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)] = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回数组：[ 1, '1', NaN, &#123;&#125; ]</span></span><br><span class="line"><span class="comment">// 原数组：[ 1, 1, '1', '1', NaN, NaN, &#123;&#125;, &#123;&#125;, NaN ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：for循环（解决了 对象 和 NaN 的问题）</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, &#123;&#125;, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prop = <span class="built_in">Array</span>.prototype</span><br><span class="line">    prop.myDistinct = <span class="function"><span class="keyword">function</span> <span class="title">myDistinct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> hash = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i])</span><br><span class="line">            <span class="keyword">if</span> (hash[temp]) &#123;</span><br><span class="line">                <span class="keyword">this</span>[i] = <span class="keyword">this</span>[<span class="keyword">this</span>.length - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">this</span>.length--</span><br><span class="line">                i--</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash[temp] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.myDistinct())</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="两个数组比较，判断是否有相同元素（交集）"><a href="#两个数组比较，判断是否有相同元素（交集）" class="headerlink" title="两个数组比较，判断是否有相同元素（交集）"></a>两个数组比较，判断是否有相同元素（交集）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="literal">NaN</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：filter + indexOf（支持 NaN）</span></span><br><span class="line"><span class="keyword">var</span> c = a.filter(<span class="function"><span class="params">v</span> =&gt;</span> b.indexOf(v) &gt; <span class="number">-1</span>) <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> aHasNaN = a.some(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">isNaN</span>(v))</span><br><span class="line"><span class="keyword">var</span> bHasNaN = b.some(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">isNaN</span>(v))</span><br><span class="line"><span class="keyword">var</span> c = a.filter(<span class="function"><span class="params">v</span> =&gt;</span> b.indexOf(v) &gt; <span class="number">-1</span>)</span><br><span class="line">          .concat(aHasNaN &amp;&amp; bHasNaN ? [<span class="literal">NaN</span>] : [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若下面 a、b 情况，上面方法会导致结果为 [2, 2]，但按正常逻辑预期应该是 [2] )</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="literal">NaN</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aHasNaN = a.some(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">isNaN</span>(v))</span><br><span class="line"><span class="keyword">var</span> bHasNaN = b.some(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">isNaN</span>(v))</span><br><span class="line"><span class="keyword">return</span> a.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = b.indexOf(v)</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            b.splice(index, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).concat(aHasNaN &amp;&amp; bHasNaN ? [<span class="literal">NaN</span>] : [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：es7 includes</span></span><br><span class="line"><span class="keyword">var</span> c = a.filter(<span class="function"><span class="params">v</span> =&gt;</span> b.includes(v))</span><br></pre></td></tr></table></figure><h3 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：随机交换数组内的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 随机索引【Math.random()返回一个浮点,  伪随机数在范围[0，1)】</span></span><br><span class="line">        <span class="keyword">let</span> randomIndex = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">        <span class="comment">// 存下当前正常索引值对应的数字</span></span><br><span class="line">        <span class="keyword">let</span> curNum = arr[i]</span><br><span class="line">        <span class="comment">// 将其重新赋值为随机索引对应的数字</span></span><br><span class="line">        arr[i] = arr[randomIndex]</span><br><span class="line">        <span class="comment">// 将随机索引对应的数字替换为当前正常索引值对应的数字</span></span><br><span class="line">        arr[randomIndex] = curNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：sort() 可以调用一个函数做为参数，如果这个函数返回的值为负数表示数组中的 a 项排在 b 项前</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">.5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure><h3 id="找出正数组中的最大差值"><a href="#找出正数组中的最大差值" class="headerlink" title="找出正数组中的最大差值"></a>找出正数组中的最大差值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]; <span class="comment">// 11-5=6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxProfit</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min = max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    min = min &lt;= arr[i] ? min : arr[i];</span><br><span class="line">    max = max &gt;= arr[i] ? max : arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(max - min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从排序数组中删除重复项"><a href="#从排序数组中删除重复项" class="headerlink" title="从排序数组中删除重复项"></a>从排序数组中删除重复项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若 nums = [1,1,2], 则函数应返回长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</span></span><br><span class="line"><span class="comment">// 若 nums = [0,0,1,1,1,2,2,3,3,4], 则返回 5, 并且原数组被修改为 0, 1, 2, 3, 4。</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicates</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] === nums[i]) &#123;</span><br><span class="line">      nums.splice(i - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出数组中出现次数最多的元素，并给出其出现过的位置"><a href="#找出数组中出现次数最多的元素，并给出其出现过的位置" class="headerlink" title="找出数组中出现次数最多的元素，并给出其出现过的位置"></a>找出数组中出现次数最多的元素，并给出其出现过的位置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bestItem, indexs = [], obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = arr[i].toString()</span><br><span class="line">        obj[item] ? obj[item].push(i) : obj[item] = [].concat([i])</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> tempArr = <span class="built_in">Object</span>.entries(obj)</span><br><span class="line">    bestItem = <span class="built_in">parseInt</span>(tempArr[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    indexs = tempArr[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> tempArr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexs.length &lt; value.length) &#123;</span><br><span class="line">            bestItem = <span class="built_in">parseInt</span>(key)</span><br><span class="line">            indexs = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; bestItem, indexs &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(arr))</span><br></pre></td></tr></table></figure><h3 id="将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"><a href="#将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组" class="headerlink" title="将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"></a>将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</h3><blockquote><p>已知如下数组：</p><p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p><p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="comment">// 扁平化数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...this.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item) ? item.flat() : [item]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="keyword">this</span>)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组排序</span></span><br><span class="line"><span class="keyword">const</span> sort = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat().unique().sort(sort))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.toString().split(<span class="string">','</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tempItem = <span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(tempItem) ?</span><br><span class="line">      <span class="literal">false</span> :</span><br><span class="line">    obj[tempItem] = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sort = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat().unique().sort(sort))</span><br></pre></td></tr></table></figure><h3 id="使用迭代的方式实现-flatten-函数"><a href="#使用迭代的方式实现-flatten-函数" class="headerlink" title="使用迭代的方式实现 flatten 函数"></a>使用迭代的方式实现 flatten 函数</h3><blockquote><p>迭代实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>], <span class="number">9</span>, <span class="number">10</span>, [<span class="number">11</span>, [<span class="number">12</span>, <span class="number">13</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Array</span>.isArray(v))) &#123;</span><br><span class="line">     arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Array</span>.isArray(v) ? flatten(v) : [v]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串转换</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">','</span>).split(<span class="string">','</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Number</span>(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>输入: [7,1,5,3,6,4]         输出: 7</p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> income = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> gap = arr[i] - arr[i - <span class="number">1</span>] <span class="comment">// 后一个与前一个比较，大于零则赚</span></span><br><span class="line">        <span class="keyword">if</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            income += gap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> income</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxProfit(arr))</span><br></pre></td></tr></table></figure><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3          输出: [5,6,7,1,2,3,4]</p><p>解释:</p><p>向右旋转 1 步: [7,1,2,3,4,5,6]</p><p>向右旋转 2 步: [6,7,1,2,3,4,5]</p><p>向右旋转 3 步: [5,6,7,1,2,3,4]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr.pop()</span><br><span class="line">        arr.unshift(temp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rotate(arr, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="判断数组是否存在重复"><a href="#判断数组是否存在重复" class="headerlink" title="判断数组是否存在重复"></a>判断数组是否存在重复</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>输入: [1,2,3,1]        输出: true</p><p>输入: [1,2,3,4]        输出: false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsDuplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[arr[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj[arr[i]] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsDuplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)].length !== arr.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(containsDuplicate(arr))</span><br></pre></td></tr></table></figure><h3 id="找出只出现一次的数字"><a href="#找出只出现一次的数字" class="headerlink" title="找出只出现一次的数字"></a>找出只出现一次的数字</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleNumber</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempArr = arr</span><br><span class="line">    tempArr.sort()</span><br><span class="line">    <span class="keyword">var</span> onceNumber = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = tempArr.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempArr[i] !== tempArr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            onceNumber = tempArr[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有可能排序后最后一个才是单着的数字，所以直接赋值为数组最后一个值</span></span><br><span class="line">    <span class="keyword">return</span> onceNumber !== <span class="literal">null</span> ? onceNumber : tempArr[tempArr.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleNumber</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = [...new <span class="built_in">Set</span>(arr)].reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + cur, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + cur, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(singleNumber(arr))</span><br></pre></td></tr></table></figure><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>] <span class="comment">// 预期：[1, 0, 0, 0]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusOne</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 从末尾往前倒</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 只要当前位+1大于9，就把当前位置为0，count--</span></span><br><span class="line">        <span class="keyword">if</span> (arr[count] + <span class="number">1</span> &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            arr[count] = <span class="number">0</span></span><br><span class="line">            count--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一旦当前位+1不大于9，就放心+1，且直接退出，不用再算更高位的了</span></span><br><span class="line">            arr[count]++</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果while后，第一位还是0，证明这个数组所有数字都为9.这个时候往数组最前面加个1就好</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">        arr.unshift(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(plusOne(arr))</span><br></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>] <span class="comment">// 预期：[ 1, 3, 12, 0, 0 ]</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 长度提取出来</span></span><br><span class="line">    <span class="keyword">var</span> len = nums.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 从头往后遍历，遇到0则删掉追放到尾部，</span></span><br><span class="line">        <span class="comment">// 同时让i--，因为头部删了个0；同时len--，因为不再判断追加后的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">            nums.splice(i, <span class="number">1</span>)</span><br><span class="line">            nums.push(<span class="number">0</span>)</span><br><span class="line">            i--</span><br><span class="line">            len--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(moveZeroes(arr))</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = nums[i]</span><br><span class="line">    <span class="comment">// 第二个数索引</span></span><br><span class="line">    <span class="keyword">const</span> targetIndex = nums.indexOf(target - num)</span><br><span class="line">    <span class="comment">// 确保存在第二个数，且不为当前遍历的数</span></span><br><span class="line">    <span class="keyword">if</span> (targetIndex &gt; <span class="number">-1</span> &amp;&amp; targetIndex !== i) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, targetIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(twoSum(nums, target))</span><br></pre></td></tr></table></figure><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">    [<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">    [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> tempArr = arr[j][i]</span><br><span class="line">            arr[j][i] = arr[i][j]</span><br><span class="line">            arr[i][j] = tempArr</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i].reverse()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rotate(matrix))</span><br></pre></td></tr></table></figure><h3 id="如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』？"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』？" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』？"></a>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">12000000.11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：利用 toLocaleString() 返回某语言系统下数字的表示字符串 IE6+</span></span><br><span class="line">num.toLocaleString()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toThousands</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num !== <span class="string">'number'</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 判断 num 是否小于 0 ，小于则设 flag 为 "-" 并且把 num 转为绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="string">"-"</span></span><br><span class="line">        num = <span class="built_in">Math</span>.abs(num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转为数组 e.g. [ '12000000', '11' ]</span></span><br><span class="line">    <span class="keyword">var</span> arr = num.toString().split(<span class="string">"."</span>)</span><br><span class="line">    <span class="comment">// 分别把「.」左边和右边存起来</span></span><br><span class="line">    <span class="keyword">var</span> left = [...arr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">var</span> right = <span class="string">""</span></span><br><span class="line">    <span class="comment">// 如果 num 不是个整数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        right = <span class="string">"."</span> + arr[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = left.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 操作左边整数部分，逆向遍历并且逢3前面加个「,」 ，最后 i-1</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// [1,2,0,0,0,0]</span></span><br><span class="line">        <span class="comment">// 例如如果数组长度为6，则一开始 count=5 ，不加</span></span><br><span class="line">        <span class="comment">// count=3 时，就需要在前面加个「,」</span></span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            left.splice(-count, <span class="number">0</span>, <span class="string">','</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正负符号 + 左边 + 小数点和右边</span></span><br><span class="line">    <span class="keyword">return</span> flag + left.join(<span class="string">""</span>) + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toThousands</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num &amp;&amp; num</span><br><span class="line">    .toString()</span><br><span class="line">    .replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span>, $<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">2</span> + <span class="string">','</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个数组合并成一个数组"><a href="#两个数组合并成一个数组" class="headerlink" title="两个数组合并成一个数组"></a>两个数组合并成一个数组</h3><p>请把两个数组 <code>[&#39;A1&#39;, &#39;A2&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;D1&#39;, &#39;D2&#39;]</code> 和 <code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code>，合并为 <code>[&#39;A1&#39;, &#39;A2&#39;, &#39;A&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D&#39;]</code>。</p><blockquote><p>考察点：假设有一种情况，让你在一个列表中插入一个广告，不光是数组，对象依然有这种需求，这道题其实就是平常经常需要用到的一个小功能。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">"A1"</span>, <span class="string">"A2"</span>, <span class="string">"B1"</span>, <span class="string">"B2"</span>, <span class="string">"C1"</span>, <span class="string">"C2"</span>, <span class="string">"D1"</span>, <span class="string">"D2"</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">[...arr1, ...arr2].sort(<span class="function">(<span class="params">v2, v1</span>) =&gt;</span> (</span><br><span class="line">  v2.codePointAt(<span class="number">0</span>) - v1.codePointAt(<span class="number">0</span>) ||</span><br><span class="line">    v1.length - v2.length ||</span><br><span class="line">    v2.codePointAt(<span class="number">1</span>) - v1.codePointAt(<span class="number">1</span>)</span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>第一个条件v2.codePointAt(0) - v1.codePointAt(0) 保证了所有已A开头的字符串会放在最前边，然后依次是B和C。</li><li>第二个条件v1.length - v2.length保证A会被放在A1和A2之后。</li><li>第三个条件v2.codePointAt(1) - v1.codePointAt(1)保证了A1会被放在A2前边。</li></ul><p>这是我挑的一个比较好的答案，更多解法可<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39" target="_blank" rel="noopener">在此</a>查看</p><h2 id="随机数-数字"><a href="#随机数-数字" class="headerlink" title="随机数 / 数字"></a>随机数 / 数字</h2><h3 id="如何获取0-9的随机数"><a href="#如何获取0-9的随机数" class="headerlink" title="如何获取0-9的随机数"></a>如何获取0-9的随机数</h3><ul><li><strong>Math.round(num)</strong>：将 <strong>num</strong> 四舍五入取整</li><li><strong>Math.floor(num)</strong>：将 <strong>num</strong> 向下取整，即返回 <strong>num</strong> 的整数部分。当然我们也可以使用 <strong>parseInt()</strong> 方法代替。</li><li><strong>Math.ceil(num)</strong>：向上取整</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (min, max)：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * (max - min - <span class="number">2</span>) + min + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// [min, max]：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * (max - min) + min)</span><br><span class="line"><span class="comment">// (n, m]：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * (max - min) + min)</span><br><span class="line"><span class="comment">// [n, m)：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min) + min)</span><br></pre></td></tr></table></figure><h3 id="随机获取数组中的元素"><a href="#随机获取数组中的元素" class="headerlink" title="随机获取数组中的元素"></a>随机获取数组中的元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"前端"</span>, <span class="string">"后端"</span>, <span class="string">"全栈"</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn(arr))</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打乱数组顺序"><a href="#打乱数组顺序" class="headerlink" title="打乱数组顺序"></a>打乱数组顺序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="string">'a'</span>,<span class="string">'dsfs'</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="string">'v'</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[randomIndex]</span><br><span class="line">    arr[randomIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保留指定小数位"><a href="#保留指定小数位" class="headerlink" title="保留指定小数位"></a>保留指定小数位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">4.345678</span></span><br><span class="line">num = num.toFixed(<span class="number">4</span>) <span class="comment">// 4.3457 第四位小数位以四舍五入计算</span></span><br></pre></td></tr></table></figure><h3 id="前端价格展示，保留2位小数。位数不够补零"><a href="#前端价格展示，保留2位小数。位数不够补零" class="headerlink" title="前端价格展示，保留2位小数。位数不够补零"></a>前端价格展示，保留2位小数。位数不够补零</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceFormat</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(<span class="built_in">Math</span>.round(price * <span class="number">100</span>) / <span class="number">100</span>).toFixed(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何将字符串转化为数字，例如’12-3b’？"><a href="#如何将字符串转化为数字，例如’12-3b’？" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’？"></a>如何将字符串转化为数字，例如’12.3b’？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.3b'</span>)</span><br><span class="line"><span class="comment">// 12.3</span></span><br></pre></td></tr></table></figure><h3 id="如何检查一个数字是否为整数？"><a href="#如何检查一个数字是否为整数？" class="headerlink" title="如何检查一个数字是否为整数？"></a>如何检查一个数字是否为整数？</h3><blockquote><p>将它对 1 进行取模，看看是否有余数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInt</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num % <span class="number">1</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">4</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">12.2</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isInt(<span class="number">0.3</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="为什么0-1-0-2不等于0-3？在什么场景下遇到这个问题，如何解决？"><a href="#为什么0-1-0-2不等于0-3？在什么场景下遇到这个问题，如何解决？" class="headerlink" title="为什么0.1+0.2不等于0.3？在什么场景下遇到这个问题，如何解决？"></a>为什么0.1+0.2不等于0.3？在什么场景下遇到这个问题，如何解决？</h3><blockquote><p>二进制模拟十进制进行计算时 的精度问题</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：ES6的 Number.EPSILON ，这个值无限接近于0。0.1 + 0.2的精度误差在这个值的范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersEqual</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>, b=<span class="number">0.3</span></span><br><span class="line"><span class="built_in">console</span>.log(numbersEqual(a,b))    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：parseFloat + 内置函数 toFixed</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span>(<span class="params">num, fixed = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// a.toFixed(fixed) 先转为小数点10位的字符串 "0.3000000000"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(a.toFixed(fixed)) <span class="comment">// 然后通过parseFloat转为浮点数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(formatNum(a)) <span class="comment">//0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：内置函数toPrecision(中文：精确，精度)</span></span><br><span class="line"><span class="comment">// 参数是精度.比如 5.1234 ，传 2 返回 5.1 ，传 1 返回 5 ；0.2 + 0.1 传 2 返回 0.30</span></span><br><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).toPrecision(<span class="number">10</span>) == <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://juejin.im/post/5b90e00e6fb9a05cf9080dff" target="_blank" rel="noopener">0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？</a></li><li><a href="https://blog.csdn.net/nineteen73/article/details/51184387" target="_blank" rel="noopener">JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3</a></li></ul><h2 id="对象-amp-原型-amp-原型链"><a href="#对象-amp-原型-amp-原型链" class="headerlink" title="对象 &amp; 原型 &amp; 原型链"></a>对象 &amp; 原型 &amp; 原型链</h2><h3 id="写一下浅-深拷贝"><a href="#写一下浅-深拷贝" class="headerlink" title="写一下浅/深拷贝"></a>写一下浅/深拷贝</h3><blockquote><p>深拷贝和浅拷贝针对的是引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型复制，则会进行地址的拷贝，最终两个变量指向同一份数据。对于引用类型，会导致a b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个，有时候这可能不是我们想要的结果。</p></blockquote><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个浅拷贝，就是遍历源对象，然后在将对象的属性的属性值都放到一个新对象里就ok了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newObj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="string">'bb'</span>, <span class="attr">c</span>: <span class="string">'cc'</span>,  <span class="attr">d</span>: &#123;<span class="attr">e</span>: <span class="string">'ee'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> b = copy(a)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123; b: 'bb', c: 'cc', d: &#123; e: 'ee' &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：原生方法 Object.assign</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span> : <span class="string">'old'</span>, <span class="attr">b</span> : &#123; <span class="attr">c</span> : <span class="string">'old'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">b.a = <span class="string">'new'</span></span><br><span class="line">b.b.c = <span class="string">'new'</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123; a: 'old', b: &#123; c: 'new' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123; a: 'new', b: &#123; c: 'new' &#125; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：转 JSON 再转回来</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">'小红'</span>&#125;, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line">obj1.a.name = <span class="string">'被修改了'</span></span><br><span class="line">obj2   <span class="comment">//&#123;"a":&#123;"name":"小红"&#125;,"b":2&#125;  《---没有被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON方法的缺点：</span></span><br><span class="line"><span class="comment">//  不能复制 function、正则、Symbol</span></span><br><span class="line"><span class="comment">//  循环引用报错</span></span><br><span class="line"><span class="comment">//  相同的引用会被重复复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：递归的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归退出条件</span></span><br><span class="line">    <span class="comment">// 拷贝对象不存在或不是数组或不是对象</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newObj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果是数组或者对象</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                newObj[key] = copy(obj[key])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则直接返回</span></span><br><span class="line">                newObj[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> old = &#123; <span class="attr">a</span>: <span class="string">'old'</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'old'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> newObj = copy(old)</span><br><span class="line">newObj.b.c = <span class="string">'new'</span></span><br><span class="line"><span class="built_in">console</span>.log(old) <span class="comment">// &#123; a: 'old', b: &#123; c: 'old' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj) <span class="comment">// &#123; a: 'old', b: &#123; c: 'new' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://segmentfault.com/a/1190000016970483" target="_blank" rel="noopener">浅探js深拷贝和浅拷贝</a></li><li><a href="http://www.cnblogs.com/zhangycun/p/9799787.html" target="_blank" rel="noopener">深拷贝的终极探索</a></li></ul><h3 id="JavaScript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#JavaScript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="JavaScript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>JavaScript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3><p><strong>hasOwnProperty</strong></p><p>hasOwnProperty 返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法不会检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</p><p>使用方法： object.hasOwnProperty(proName) 其中参数 object 是必选项，一个对象的实例；proName 是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么 JavaScript 中 hasOwnProperty 函数方法返回 true，反之则返回 false。</p><h3 id="instanceof-的实现原理"><a href="#instanceof-的实现原理" class="headerlink" title="instanceof 的实现原理"></a>instanceof 的实现原理</h3><blockquote><p>思路：只要右边变量的 prototype 在左边变量的原型链上即可。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span>(<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rightProto = rightValue.prototype <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftValue = leftValue.__proto__ <span class="comment">// 取左表达式的 __proto__ 值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftValue === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftValue === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        leftValue = leftValue.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a></p><h3 id="实现一个-new"><a href="#实现一个-new" class="headerlink" title="实现一个 new"></a>实现一个 new</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> ret instanceOf <span class="built_in">Object</span> ? ret : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_new(Person, <span class="string">'Lance'</span>, <span class="number">19</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Person(<span class="string">'Jerry'</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure><h3 id="实现一个单例"><a href="#实现一个单例" class="headerlink" title="实现一个单例"></a>实现一个单例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SingleTest = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _instance = <span class="literal">null</span></span><br><span class="line">    SingleInstance.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">ops</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> ops) &#123;</span><br><span class="line">            <span class="keyword">this</span>[i]=ops[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SingleInstance</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            _instance=<span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        _instance._init(args)</span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SingleInstance</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1=<span class="keyword">new</span> SingleTest(&#123;<span class="attr">name</span>:<span class="string">"lance1"</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> i2=<span class="keyword">new</span> SingleTest(&#123;<span class="attr">name</span>:<span class="string">"lance2"</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(i1===i2)  <span class="comment">// 结果是true</span></span><br><span class="line"><span class="built_in">console</span>.log(i1.name)  <span class="comment">// 结果是escapist3</span></span><br></pre></td></tr></table></figure><h2 id="Event-Loop-amp-setTimeout"><a href="#Event-Loop-amp-setTimeout" class="headerlink" title="Event Loop &amp; setTimeout"></a>Event Loop &amp; setTimeout</h2><h3 id="setTimeout-的机制"><a href="#setTimeout-的机制" class="headerlink" title="setTimeout 的机制"></a>setTimeout 的机制</h3><p>等到当前脚本的同步任务和 “任务队列” 中已有的事件，全部处理完以后，才会执行 setTimeout 指定的任务。</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>有关 Event Loop 相关的概念和面试题可参考我的博客：<a href="https://evestorm.github.io/posts/10505/" target="_blank" rel="noopener">Event Loop 学习笔记</a></p><h3 id="自我测验"><a href="#自我测验" class="headerlink" title="自我测验"></a>自我测验</h3><p>上面两篇文章阅读完毕后可以自我测验下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>题目出处和答案参考：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7" target="_blank" rel="noopener">从一道题浅说 JavaScript 的事件循环</a></p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="getElementsByClassName-和-querySelectorAll-的区别"><a href="#getElementsByClassName-和-querySelectorAll-的区别" class="headerlink" title="getElementsByClassName 和 querySelectorAll 的区别"></a>getElementsByClassName 和 querySelectorAll 的区别</h3><ul><li><p>参数上：querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.b1 .c'</span>)</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'c'</span>)</span><br><span class="line"><span class="keyword">var</span> c3 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'b2'</span>)[<span class="number">0</span>].getElementsByClassName(<span class="string">'c'</span>)</span><br></pre></td></tr></table></figure></li><li><p>返回值上：querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List</p></li></ul><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/24702250" target="_blank" rel="noopener">querySelectorAll 方法相比 getElementsBy 系列方法有什么区别？</a></li><li><a href="https://segmentfault.com/a/1190000008829267" target="_blank" rel="noopener">静态NodeList 和 动态NodeList的区别</a></li></ul><h3 id="原生-JS-添加类"><a href="#原生-JS-添加类" class="headerlink" title="原生 JS 添加类"></a>原生 JS 添加类</h3><ul><li>element.setAttribute(“class”, ‘Lance’)</li><li>element.className = “lance awesome”</li><li>追加类：element.setAttribute(“class”, element.getAttribute(“class”) + “ “ + “lance”)</li></ul><h3 id="编写一个可拖拽的-div"><a href="#编写一个可拖拽的-div" class="headerlink" title="编写一个可拖拽的 div"></a>编写一个可拖拽的 div</h3><blockquote><p>HTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sw"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>CSS</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sw</span> &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>JS</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> sw = <span class="built_in">document</span>.querySelector(<span class="string">"#sw"</span>)</span><br><span class="line">sw.addEventListener(<span class="string">"mousedown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    position = [e.clientX, e.clientY]</span><br><span class="line">    <span class="built_in">console</span>.log(e.clientX, e.clientY)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里监听 document ，如果监听 sw 则会有快速拖动导致鼠标「脱离」 div 的 bug</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"mousemove"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">var</span> x = e.clientX</span><br><span class="line">    <span class="keyword">var</span> y = e.clientY</span><br><span class="line">    <span class="keyword">var</span> moveX = x - position[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> moveY = y - position[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">var</span> left = <span class="built_in">parseInt</span>(sw.style.left || <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> top = <span class="built_in">parseInt</span>(sw.style.top || <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 注意 style.left 带 px 单位</span></span><br><span class="line">    sw.style.left = left + moveX + <span class="string">'px'</span></span><br><span class="line">    sw.style.top = top + moveY + <span class="string">'px'</span></span><br><span class="line">    position = [x, y]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"mouseup"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="预测执行结果"><a href="#预测执行结果" class="headerlink" title="预测执行结果"></a>预测执行结果</h2><h3 id="下面代码打印结果是什么？为什么"><a href="#下面代码打印结果是什么？为什么" class="headerlink" title="下面代码打印结果是什么？为什么?"></a>下面代码打印结果是什么？为什么?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>答案：</p><ul><li>非严格模式：[Function b]</li><li>严格模式：<code>Uncaught TypeError: Assignment to constant variable</code></li></ul><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值；</span></span><br><span class="line">   <span class="comment">// IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。</span></span><br><span class="line">  <span class="comment">// （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）</span></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// [Function b]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 10，不是20</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 严格模式下能看到错误：Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p>其他情况例子：</p><p>有<code>window</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b = 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">    window.b = 20; </span><br><span class="line">    console.log(b); // [Function b]</span><br><span class="line">    console.log(window.b); // 20是必然的</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>有<code>var</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b = 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">    var b = 20; // IIFE内部变量</span><br><span class="line">    console.log(b); // 20</span><br><span class="line">   console.log(window.b); // 10 </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/48#issuecomment-472695263" target="_blank" rel="noopener">解析来源 ←</a></p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>我面的都不是什么大公司，所以很少被问到算法，不过对于前端来说，了解一些基本的算法还是很有必要的，起码最常见的排序算法得掌握，例如冒泡和快排。这部分内容可参考我的博客：</p><ul><li><a href="https://evestorm.github.io/posts/59937/" target="_blank" rel="noopener">常见排序算法</a></li></ul><h2 id="非常规题"><a href="#非常规题" class="headerlink" title="非常规题"></a>非常规题</h2><h3 id="‘1’-‘2’-‘3’-map-parseInt-的结果"><a href="#‘1’-‘2’-‘3’-map-parseInt-的结果" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt)的结果"></a>[‘1’, ‘2’, ‘3’].map(parseInt)的结果</h3><p>正确答案：[1, NaN, NaN]</p><p>答案解析：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4" target="_blank" rel="noopener">[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</a></p><h1 id="JS面试题"><a href="#JS面试题" class="headerlink" title="JS面试题"></a>JS面试题</h1><h2 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h2><h3 id="let-const"><a href="#let-const" class="headerlink" title="let / const"></a>let / const</h3><h4 id="全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？"><a href="#全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？" class="headerlink" title="全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？"></a>全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？</h4><p>ES6规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let、const、class命令声明的全局变量，不属于顶层对象的属性。只在一个块级作用域（Script）中，获取时不加 <code>window/global</code> 就好：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bb); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>答案链接：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30" target="_blank" rel="noopener">关于 const 和 let 声明的变量不在 window 上</a></p><h2 id="讲一下-JS-垃圾回收机制"><a href="#讲一下-JS-垃圾回收机制" class="headerlink" title="讲一下 JS 垃圾回收机制"></a>讲一下 JS 垃圾回收机制</h2><p>这部分可参考我的博客：<a href="https://evestorm.github.io/posts/20229/" target="_blank" rel="noopener">JS垃圾回收机制</a></p><h2 id="那些操作会造成内存泄漏？❌"><a href="#那些操作会造成内存泄漏？❌" class="headerlink" title="那些操作会造成内存泄漏？❌"></a>那些操作会造成内存泄漏？❌</h2><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p><p>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><h3 id="写一个函数判断是否存在循环引用-❌"><a href="#写一个函数判断是否存在循环引用-❌" class="headerlink" title="写一个函数判断是否存在循环引用 ❌"></a>写一个函数判断是否存在循环引用 ❌</h3><h3 id="如何统计用户的点击量-❌"><a href="#如何统计用户的点击量-❌" class="headerlink" title="如何统计用户的点击量 ❌"></a>如何统计用户的点击量 ❌</h3><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="cookie-与-本地存储-相关"><a href="#cookie-与-本地存储-相关" class="headerlink" title="cookie 与 本地存储 相关"></a>cookie 与 本地存储 相关</h2><h3 id="cookie-的使用"><a href="#cookie-的使用" class="headerlink" title="cookie 的使用"></a>cookie 的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=16'</span> <span class="comment">// 每次只能设置一对cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="built_in">document</span>.cookie <span class="comment">// 获取全部cookie值，获取特定用循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=xiaoming; max-age=-1000'</span> <span class="comment">// 设置一个当前之前的时间即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'one_name'</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">exp.setTime(exp.getTime() + <span class="number">60</span> * <span class="number">2000</span>) <span class="comment">// 过期时间 2分钟</span></span><br><span class="line"><span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";expires="</span> + exp.toGMTString()</span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";expires="</span> + exp.toGMTString())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，</span></span><br><span class="line"><span class="comment">// 这种 cookie 简称会话 cookie。</span></span><br><span class="line"><span class="comment">// 如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，</span></span><br><span class="line"><span class="comment">// 关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。</span></span><br></pre></td></tr></table></figure><h3 id="cookie-localStorage-和-sessionStorage-的区别"><a href="#cookie-localStorage-和-sessionStorage-的区别" class="headerlink" title="cookie, localStorage 和 sessionStorage 的区别"></a>cookie, localStorage 和 sessionStorage 的区别</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul><li>cookie：是服务器发给浏览器保存的（字符串）数据，一般用来记录用户信息方便服务端确认用户身份</li><li>localStorage、sessionStorage：本地存储，可以保存一些不太重要的数据，例如当前用户坐标，购物车信息等</li></ul><h4 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h4><ul><li>cookie：4k</li><li>localStorage, sessionStorage：5M</li></ul><h4 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h4><ul><li>cookie：关闭浏览器失效（默认）</li><li>localStorage：永久，除非js手动删和清除浏览器缓存</li><li>sessionStorage：页面不关闭就不失效，包括重新加载或恢复页面也不失效。但在新标签或窗口打开一个页面，则会重新生成</li></ul><h3 id="cookie-与-session-区别"><a href="#cookie-与-session-区别" class="headerlink" title="cookie 与 session 区别"></a>cookie 与 session 区别</h3><p>都是用来确认用户身份的，区别在于 cookie 保存在客户端，session 保存在服务端。</p><p>另外，session 是基于 cookie 的。服务器端在生成 session 后，会让客户端的 cookie 代为保存 sessionID 。</p><div align="center">   <img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1550245038963-b61378bb-65db-411e-9069-cf7d2b7a2908.png" width="600" alt="cookie">   <img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1550245194054-9e6b0a42-c09e-4a8b-8e7e-93ba715e6e5a.png" width="600" alt="session"></div><p>阅读：</p><ul><li><a href="https://segmentfault.com/a/1190000017332168" target="_blank" rel="noopener">一文带你看懂cookie，面试前端不用愁</a></li><li><a href="https://juejin.im/post/5b18d322e51d4506cf10af7c" target="_blank" rel="noopener">聊一聊cookie</a></li><li><a href="https://segmentfault.com/q/1010000007715137" target="_blank" rel="noopener">Cookie禁用了，Session还能用吗？</a></li><li><a href="https://www.jianshu.com/p/cc951b6a75e3" target="_blank" rel="noopener">session,cookie,sessionStorage,localStorage的区别及应用场景</a></li></ul><h3 id="HTML5的离线储存使用，解释工作原理？❌"><a href="#HTML5的离线储存使用，解释工作原理？❌" class="headerlink" title="HTML5的离线储存使用，解释工作原理？❌"></a>HTML5的离线储存使用，解释工作原理？❌</h3><blockquote><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p></blockquote><p>如何使用：</p><ol><li>页面头部像下面一样加入一个manifest的属性</li><li>在 cache.manifest 文件的编写离线存储的资源</li><li>在离线状态时，操作 window.applicationCache 进行需求实现。</li></ol><p>详细的使用请参考：</p><ul><li><a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener">HTML5 离线缓存-manifest简介</a></li><li><a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></li></ul><h3 id="浏览器对-HTML5-离线储存资源的管理和加载？"><a href="#浏览器对-HTML5-离线储存资源的管理和加载？" class="headerlink" title="浏览器对 HTML5 离线储存资源的管理和加载？"></a>浏览器对 HTML5 离线储存资源的管理和加载？</h3><p>在线的情况下:</p><p>浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p><p>离线的情况下:</p><p>浏览器就直接使用离线存储的资源。</p><h3 id="用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用-cookie？"><a href="#用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用-cookie？" class="headerlink" title="用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用 cookie？"></a>用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用 cookie？</h3><ul><li>将购物车信息存在 localStorage</li><li>从 localStorage 中获取</li><li>用户禁用 cookie 时无法使用</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="经常遇到的浏览器的兼容性有哪些？"><a href="#经常遇到的浏览器的兼容性有哪些？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？"></a>经常遇到的浏览器的兼容性有哪些？</h3><ul><li>IE 浏览器不支持 Promise<ul><li>babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘./src/main.js’]</li></ul></li><li>各浏览器之间默认样式的差异<ul><li>normalize.css<ul><li>与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了）</li></ul></li></ul></li><li>html5 某些新增标签不被识别<ul><li>html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video标签不识别不显示）<ul><li>用法：<code>[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]</code></li></ul></li><li>通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。</li></ul></li><li>CSS3 媒体查询失效<ul><li>respond.js - 能解决 ie9 以下不支持媒体查询问题</li></ul></li><li>自动添加浏览器前缀<ul><li>posscss-loader+autoprefixer</li></ul></li><li>ie6 不支持 min-height/width<ul><li>添加额外的 <code>_min-height</code> ie6 识别</li></ul></li><li>常见hack（针对特定ie版本的样式控制）<ul><li>_color - ie6 识别</li><li>*color - ie6/7 识别</li><li>color: red\9; ie8及以下识别</li></ul></li><li>ie条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于)</li></ul><h3 id="移动端兼容性呢？"><a href="#移动端兼容性呢？" class="headerlink" title="移动端兼容性呢？"></a>移动端兼容性呢？</h3><ul><li>移动端点透问题<ul><li><a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html" target="_blank" rel="noopener">解决方案</a></li></ul></li><li>ios滚动卡顿<ul><li>使用 better-scroll 插件</li></ul></li><li>ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌</li><li>安卓 键盘遮挡输入框 ❌</li></ul><h4 id="position-fixed-在-android-下无效怎么处理？【❌待验证】"><a href="#position-fixed-在-android-下无效怎么处理？【❌待验证】" class="headerlink" title="position:fixed; 在 android 下无效怎么处理？【❌待验证】"></a>position:fixed; 在 android 下无效怎么处理？【❌待验证】</h4><p>原因：</p><p>fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ，<br>原来的网页还好好的在那，fixed 的内容也没有变过位置。</p><p>解决：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？❌"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？❌" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌</h4><p>click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。</p><h4 id="在做移动端项目时遇到过什么问题？"><a href="#在做移动端项目时遇到过什么问题？" class="headerlink" title="在做移动端项目时遇到过什么问题？"></a>在做移动端项目时遇到过什么问题？</h4><p>参考阅读：<a href="https://juejin.im/post/5aa8b00c51882555627cfa0e" target="_blank" rel="noopener">H5与APP混合开发遇到的问题总结</a></p><h3 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h3><h4 id="什么是-Polyfill"><a href="#什么是-Polyfill" class="headerlink" title="什么是 Polyfill"></a>什么是 Polyfill</h4><p>polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</p><p>例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，<br>所有这些都是 W3C 地理位置 API 定义的对象和函数。</p><p>因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，<br>一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</p><h4 id="做的项目中，有没有用过或自己实现一些-polyfill-方案（兼容性处理方案）？❌"><a href="#做的项目中，有没有用过或自己实现一些-polyfill-方案（兼容性处理方案）？❌" class="headerlink" title="做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌"></a>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌</h4><p>比如： html5shiv、Geolocation、Placeholder</p><h3 id="列举IE与其他浏览器不一样的特性？"><a href="#列举IE与其他浏览器不一样的特性？" class="headerlink" title="列举IE与其他浏览器不一样的特性？"></a>列举IE与其他浏览器不一样的特性？</h3><h4 id="事件目标对象"><a href="#事件目标对象" class="headerlink" title="事件目标对象"></a>事件目标对象</h4><p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性</p><h4 id="获取字符代码"><a href="#获取字符代码" class="headerlink" title="获取字符代码"></a>获取字符代码</h4><p>如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性</p><h4 id="阻止某个事件的默认行为"><a href="#阻止某个事件的默认行为" class="headerlink" title="阻止某个事件的默认行为"></a>阻止某个事件的默认行为</h4><p>IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法</p><h4 id="停止事件冒泡"><a href="#停止事件冒泡" class="headerlink" title="停止事件冒泡"></a>停止事件冒泡</h4><p>IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="如何实现浏览器内多个标签页之间的通信-阿里"><a href="#如何实现浏览器内多个标签页之间的通信-阿里" class="headerlink" title="如何实现浏览器内多个标签页之间的通信? (阿里)"></a>如何实现浏览器内多个标签页之间的通信? (阿里)</h3><p>WebSocket、SharedWorker；</p><p>也可以调用 localStorage 、cookies 等本地存储方式；</p><p>localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信；</p><p>注意：Safari 在无痕模式下设置localStorage 值时会抛出  QuotaExceededError 的异常；</p><h3 id="webSocket-如何兼容低浏览器？-阿里"><a href="#webSocket-如何兼容低浏览器？-阿里" class="headerlink" title="webSocket 如何兼容低浏览器？(阿里)"></a>webSocket 如何兼容低浏览器？(阿里)</h3><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p><h2 id="页面渲染与缓存"><a href="#页面渲染与缓存" class="headerlink" title="页面渲染与缓存"></a>页面渲染与缓存</h2><h3 id="从输入-URL-到页面展现中间发生了什么？"><a href="#从输入-URL-到页面展现中间发生了什么？" class="headerlink" title="从输入 URL 到页面展现中间发生了什么？"></a>从输入 URL 到页面展现中间发生了什么？</h3><ol><li>DNS 查询</li><li>建立 TCP 连接（三次握手）</li><li>发送 HTTP 请求</li><li>服务端web服务器对请求做处理（监听80端口 路由 渲染HTML模板 生成响应）</li><li>发送 HTTP 响应</li><li>关闭 TCP 连接（四次挥手）</li><li>浏览器解析HTML，CSS，图片，JS<ol><li>处理 HTML 标记并构建 DOM 树</li><li>处理 CSS 标记并构建 CSS 规则树</li><li>将 DOM树 与 CSS规则树 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上<blockquote><p>这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM</p></blockquote></li></ol></li></ol><p>阅读更多：</p><ul><li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li><li><a href="https://www.xuecaijie.com/it/157.html" target="_blank" rel="noopener">细说浏览器输入URL后发生了什么</a></li></ul><h3 id="style-标签写在-body-后与-body-前（head）有什么区别？"><a href="#style-标签写在-body-后与-body-前（head）有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前（head）有什么区别？"></a>style 标签写在 body 后与 body 前（head）有什么区别？</h3><p>style 标签放在 body 后，会导致当加载到此样式时，页面将停止之前的渲染。此样式表被解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p><p>所以不要写在 body 后，要把样式放在 head 中。</p><h3 id="缓存策略执行过程"><a href="#缓存策略执行过程" class="headerlink" title="缓存策略执行过程"></a>缓存策略执行过程</h3><div align="center">   <img src="https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1549091602173-872e7ae7-1532-4933-a7e6-4f53f2e9ceb8.jpeg" alt="http缓存策略"></div><h4 id="一个-Response-Header-示例"><a href="#一个-Response-Header-示例" class="headerlink" title="一个 Response Header 示例"></a>一个 Response Header 示例</h4><div align="center">   <img src="https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1549091477928-50957a41-1e84-437f-8f6e-992f430730f4.jpeg" alt="res header" width="500"></div><h3 id="强缓存与协商缓存的异同"><a href="#强缓存与协商缓存的异同" class="headerlink" title="强缓存与协商缓存的异同"></a>强缓存与协商缓存的异同</h3><ul><li>相同点：最终都是走的本地缓存</li><li>不同点：强缓存不发请求，直接读本地缓存。协商缓存发请求到服务器</li></ul><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li>1）浏览器在加载资源时，根据请求头的 <code>expires</code> 和 <code>cache-control</code> 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li><li>2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 <code>last-modified</code> 和 <code>Etag</code> 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</li><li>3）如果前面两者都没有命中，直接从服务器加载资源</li></ul><div align="center">   <img src="https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1550494473608-b1c458fe-f534-4674-ba30-32fc27deffd6.jpeg" alt="强缓存vs协商缓存" width="500"></div><h3 id="expires-和-cache-control-的区别"><a href="#expires-和-cache-control-的区别" class="headerlink" title="expires 和 cache-control 的区别"></a>expires 和 cache-control 的区别</h3><p>都是用的本地系统时间，但</p><ul><li>expires 存的是个服务端绝对时间，修改客户端系统时间会有影响</li><li>cache-control 是相对时间，即使客户端时间发生改变，相对时间也不会随之改变。例如设置 max-age = 10s，那么在 10s 以内，使用浏览器缓存的资源</li><li>cache-control 的优先级高于 expires</li></ul><h3 id="http-get-和-post-区别"><a href="#http-get-和-post-区别" class="headerlink" title="http get 和 post 区别"></a>http get 和 post 区别</h3><ol><li>语义：GET 用来读数据，POST 用来写数据</li><li>参数：GET 放在 url 里，POST 放消息体里</li><li>大小：GET 长度有限制，一般 1024 个字符。POST 4~10Mb 限制</li><li>缓存：GET 请求可以被浏览器缓存，POST 不能</li></ol><h3 id="cache-control-和-Etag-的区别"><a href="#cache-control-和-Etag-的区别" class="headerlink" title="cache-control 和 Etag 的区别"></a>cache-control 和 Etag 的区别</h3><p>一个不发请求，一个发请求。超过缓存时间，只要 if-None-Match 和服务器端 etag 相同，仍然缓存。并且 Etag 比 cache-control 的优先级更高。</p><h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h3><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><blockquote><p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><h4 id="HTTPS作用"><a href="#HTTPS作用" class="headerlink" title="HTTPS作用"></a>HTTPS作用</h4><ul><li>一种是建立一个信息安全通道，来保证数据传输的安全</li><li>另一种就是确认网站的真实性。</li></ul><h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><ul><li>https 协议需要到 ca 申请证书，有免费付费可选</li><li>http是明文传输，https 则是具有安全性的 ssl 加密传输协议。<ul><li>非对称加密</li></ul></li><li>性能问题：https 做了加密就意味着客户端服务端也需要附带解密步骤，相比来说，在通讯快捷上，性能有所不如 http 。</li></ul><h4 id="对非对称性加密的理解"><a href="#对非对称性加密的理解" class="headerlink" title="对非对称性加密的理解"></a>对非对称性加密的理解</h4><blockquote><p>不要去硬记。 你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出<strong>公钥负责加密，私钥负责解密</strong>；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出<strong>私钥负责签名，公钥负责验证</strong>。</p></blockquote><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/37738632" target="_blank" rel="noopener">非对称加密与HTTPS</a></li><li><a href="https://github.com/fi3ework/blog/issues/17" target="_blank" rel="noopener">完全理解 HTTPS 如何做到传输安全</a></li></ul><h3 id="HTTP1-1-与-HTTP2-的区别"><a href="#HTTP1-1-与-HTTP2-的区别" class="headerlink" title="HTTP1.1 与 HTTP2 的区别"></a>HTTP1.1 与 HTTP2 的区别</h3><ul><li>基于HTTPS的</li><li>多路复用</li><li>服务端推送</li></ul><h4 id="简单讲解一下-http2-的多路复用"><a href="#简单讲解一下-http2-的多路复用" class="headerlink" title="简单讲解一下 http2 的多路复用"></a>简单讲解一下 http2 的多路复用</h4><p>阅读更多：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14" target="_blank" rel="noopener">多路复用</a></p><p>HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。</p><p>多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。</p><p>HTTP2中：</p><ul><li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰。</li></ul><p>阅读更多：</p><ul><li><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li></ul><h2 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h2><h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><p>功能检测、userAgent特征检测</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：navigator.userAgent</span><br><span class="line"><span class="comment">//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36</span></span><br><span class="line">(KHTML, like Gecko) Chrome/<span class="number">41.0</span><span class="number">.2272</span><span class="number">.101</span> Safari/<span class="number">537.36</span><span class="string">"</span></span><br></pre></td></tr></table></figure><h3 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h3><p>主要分成两部分：</p><p>渲染引擎(Layout engineer 或Rendering Engine)和JS引擎。</p><ul><li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li><li>JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</li></ul><blockquote><p>详细文章：<a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank" rel="noopener">浏览器内核的解析和对比</a></p></blockquote><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>形象记忆：<a href="https://http.cat/" target="_blank" rel="noopener">https://http.cat/</a></p><ul><li>200 服务器成功返回请求</li><li>301 永久重定向，浏览器会记住 | 302 临时重定向 | 304 请求页面未修改</li><li>400 请求错误，服务器不理解 | 401 请求未授权 | 403 服务器拒绝请求 | 404 资源不存在 | 405 方法禁用</li><li>500 服务器内部错误 | 503 服务暂时不可用（超载or停机维护）</li></ul><h3 id="谈谈你对-TCP-三次握手和四次挥手的理解"><a href="#谈谈你对-TCP-三次握手和四次挥手的理解" class="headerlink" title="谈谈你对 TCP 三次握手和四次挥手的理解"></a>谈谈你对 TCP 三次握手和四次挥手的理解</h3><p><img src="https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png" alt="answer"></p><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15" target="_blank" rel="noopener">答案地址</a></p><h3 id="页面可见性-Page-Visibility-API-有哪些用途"><a href="#页面可见性-Page-Visibility-API-有哪些用途" class="headerlink" title="页面可见性(Page Visibility API)有哪些用途"></a>页面可见性(Page Visibility API)有哪些用途</h3><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</li></ul><h3 id="网页验证码干嘛的-是为了解决什么安全问题"><a href="#网页验证码干嘛的-是为了解决什么安全问题" class="headerlink" title="网页验证码干嘛的,是为了解决什么安全问题"></a>网页验证码干嘛的,是为了解决什么安全问题</h3><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p><h3 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p><h3 id="第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌"><a href="#第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌" class="headerlink" title="第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌"></a>第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌</h3><p>localStorage</p><h3 id="实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？"><a href="#实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？" class="headerlink" title="实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？"></a>实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？</h3><ul><li>onhashchange</li><li>window.history.pushState（添加新的历史记录）/replaceState(state,title, url)【改掉当前历史记录】<ul><li>配合 onpopstate 事件来监听历史记录的改变</li></ul></li></ul><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。</p><h4 id="与-HTTP-的区别"><a href="#与-HTTP-的区别" class="headerlink" title="与 HTTP 的区别"></a>与 HTTP 的区别</h4><ul><li>http 只能由客户端发起，而 webSocket 是双向的</li><li>webSocket 传输的数据包相对于 http 而言很小，很适合移动端使用</li><li>没有同源限制，可以跨域共享资源</li></ul><h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><h4 id="TCP（Transmission-Control-Protocol，传输控制协议）"><a href="#TCP（Transmission-Control-Protocol，传输控制协议）" class="headerlink" title="TCP（Transmission Control Protocol，传输控制协议）"></a>TCP（Transmission Control Protocol，传输控制协议）</h4><p>是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来</p><h5 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h5><ul><li>第一次握手：主机 A 通过向主机 B 发送一个含有同步序列号的标志位的数据段给主机 B ，向主机 B 请求建立连接，通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。</li><li>第二次握手：主机 B 收到主机 A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我</li><li>第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机 A 和主机B 就可以传输数据了。</li></ul><h4 id="TCP断开连接要进行4次"><a href="#TCP断开连接要进行4次" class="headerlink" title="TCP断开连接要进行4次"></a>TCP断开连接要进行4次</h4><ul><li>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；</li><li>第二次： 主机 B 收到 FIN 后对其作出响应，确认这一方向上的 TCP 连接将关闭,将ACK置1；</li><li>第三次： 由 B 端再提出反方向的关闭请求，将 FIN 置 1 ；</li><li>第四次： 主机 A 对主机 B 的请求进行确认，将 ACK 置 1 ，双方向的关闭结束。</li></ul><h4 id="UDP（User-Data-Protocol，用户数据报协议）"><a href="#UDP（User-Data-Protocol，用户数据报协议）" class="headerlink" title="UDP（User Data Protocol，用户数据报协议）"></a>UDP（User Data Protocol，用户数据报协议）</h4><p>UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</p><h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><p>1、TCP 面向连接；UDP 不面向连接；</p><p>2、TCP 传输可靠（三次握手），UDP 则不可靠，不保证正确性（UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发）；</p><p>3、UDP 开销小，传输快；</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>TCP：效率要求相对低，但对准确性要求相对高的场景（文件传输，邮件接收，远程登录）</li><li>UDP：效率要求相对高，但对准确性要求相对低的场景（在线视频，语音电话）</li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/24860273" target="_blank" rel="noopener">TCP 和 UDP 的区别</a></p><h3 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/260235/1550471555226-f1590db6-b11b-4e76-8eb5-9fed21299719.png" alt="七层模型.png"></p><p>参考：<a href="https://blog.csdn.net/taotongning/article/details/81352985" target="_blank" rel="noopener">OSI七层协议大白话解读</a></p><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p>Content Delivery Network，简称CDN，翻译成中文是内容分发网络。</p><p>CDN是通过在网络上的各个地方放置一定数量的节点服务器，构成在现有的互联网基础之上的一层智能虚拟网络，这层网络的主要功能是将信息（源站内容）分发至靠近用户的各个节点服务器上，让用户可以就近获取所需信息。</p><p>通过CDN，可以有效降低源站的访问压力，减轻骨干网络的拥塞，提升用户的访问速度，从而提升用户体验。还可在一定程度上保障源站的安全。</p><p>CDN 的用途可以说很窄，也可以说很广。说窄是因为CDN只是基于互联网之上的一种服务，只是给网络/网站加速的；说广是因为几乎所有的互联网业务（如网页、电商、APP、游戏、下载、影视点播、直播等等）都需要用到 CDN ，而如今互联网又无处不在。</p><p>来源：<a href="https://www.zhihu.com/question/282510029/answer/427307826" target="_blank" rel="noopener">https://www.zhihu.com/question/282510029/answer/427307826</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue购物车小球</title>
      <link href="/2019/06/28/0.tips/9.vue%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%B0%8F%E7%90%83%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/06/28/0.tips/9.vue%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%B0%8F%E7%90%83%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h1><ul><li>生成一个动画小球的div,并且生成五个小球,五个是为了生成一定数量的小球来作为操作使用,按照小球动画的速度,一般来说五个也可以保证有足够的小球数量来运行动画</li><li>动画的内容分别是外层和内层,外层控制动画小球的轨道和方向,内层控制动画小球的运行状态</li><li>动画使用<a href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-" target="_blank" rel="noopener">vue的js钩子实现</a></li><li>因为小球动画只有一个方向(只执行单方向从上到下滚落),所以只用了before-enter,enter,after-enter</li><li>用v-show控制小球的可见性,在动画执行期间可见,其余时候隐藏<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ball-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"ball in balls"</span>&gt;</span></span><br><span class="line">  //用了两种方式的动画,css和js钩子</span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"drop"</span> @<span class="attr">before-enter</span>=<span class="string">"beforeDrop"</span> @<span class="attr">enter</span>=<span class="string">"dropping"</span> @<span class="attr">after-enter</span>=<span class="string">"afterDrop"</span>&gt;</span></span><br><span class="line">    //外层动画</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ball"</span> <span class="attr">v-show</span>=<span class="string">"ball.show"</span>&gt;</span></span><br><span class="line">      //内层动画</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner inner-hook"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Js代码"><a href="#Js代码" class="headerlink" title="Js代码"></a>Js代码</h1><ul><li><p>设置了balls数组来代表五个小球</p></li><li><p>设置了dropBalls数组正在运行的小球</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        balls: [</span><br><span class="line">          &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        dropBalls: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>只要触发了drop事件,不止是drop事件里面的代码会执行,另外几个vue的js监听钩子也会一起按顺序执行</p><ul><li>触发了drop事件</li><li>beforeDrop开始执行</li><li>dropping开始执行</li><li>afterDrop开始执行</li></ul></li><li><p>drop事件的触发可以通过点击cartcontrol组件的添加小球按钮addCart事件触发使用<code>$emit</code>,也可以父组件 <code>this.$refs.shopcart.drop(target);</code>直接触发</p><ul><li>这么做的目的是实现,在子组件cartcontrol点击之后,可以将该dom传给父组件goods然后再传给子组件shopcart,(因为目前他们之间的通道就是这样,shopcart子组件并没有导入cartcontrol子组件,所以没有直接通讯)这样就实现了多个组件之间的通讯,从而可以实现需求,例如这里就是实现点击子组件cartcontrol后添加一个动画,将小球滑落到另外一个组件shopcart</li></ul></li><li><p><code>$emit</code>是触发当前实例上的事件。附加参数都会传给监听器回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">      drop(el) &#123; </span><br><span class="line">      <span class="comment">//触发一次事件就会将所有小球进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.balls.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> ball = <span class="keyword">this</span>.balls[i];</span><br><span class="line">          <span class="keyword">if</span> (!ball.show) &#123; <span class="comment">//将false的小球放到dropBalls</span></span><br><span class="line">            ball.show = <span class="literal">true</span>;</span><br><span class="line">            ball.el = el; <span class="comment">//设置小球的el属性为一个dom对象</span></span><br><span class="line">            <span class="keyword">this</span>.dropBalls.push(ball); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      beforeDrop(el)&#123; <span class="comment">//这个方法的执行是因为这是一个vue的监听事件</span></span><br><span class="line">        <span class="keyword">let</span> count = <span class="keyword">this</span>.balls.length;</span><br><span class="line">        <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">          <span class="keyword">let</span> ball = <span class="keyword">this</span>.balls[count];</span><br><span class="line">          <span class="keyword">if</span> (ball.show) &#123;</span><br><span class="line">            <span class="keyword">let</span> rect = ball.el.getBoundingClientRect(); <span class="comment">//获取小球的相对于视口的位移(小球高度)</span></span><br><span class="line">            <span class="keyword">let</span> x = rect.left - <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">let</span> y = -(<span class="built_in">window</span>.innerHeight - rect.top - <span class="number">22</span>); <span class="comment">//负数,因为是从左上角往下的的方向</span></span><br><span class="line">            el.style.display = <span class="string">''</span>; <span class="comment">//清空display</span></span><br><span class="line">            el.style.webkitTransform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span>; </span><br><span class="line">            el.style.transform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span>;</span><br><span class="line">            <span class="comment">//处理内层动画</span></span><br><span class="line">            <span class="keyword">let</span> inner = el.getElementsByClassName(<span class="string">'inner-hook'</span>)[<span class="number">0</span>]; <span class="comment">//使用inner-hook类来单纯被js操作</span></span><br><span class="line">            inner.style.webkitTransform = <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,0,0)`</span>;</span><br><span class="line">            inner.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,0,0)`</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      dropping(el, done) &#123; <span class="comment">//这个方法的执行是因为这是一个vue的监听事件</span></span><br><span class="line">        <span class="comment">/* eslint-disable no-unused-vars */</span></span><br><span class="line">        <span class="keyword">let</span> rf = el.offsetHeight; <span class="comment">//触发重绘html</span></span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//让动画效果异步执行,提高性能</span></span><br><span class="line">          el.style.webkitTransform = <span class="string">'translate3d(0,0,0)'</span>;</span><br><span class="line">          el.style.transform = <span class="string">'translate3d(0,0,0)'</span>;</span><br><span class="line">          <span class="comment">//处理内层动画</span></span><br><span class="line">          <span class="keyword">let</span> inner = el.getElementsByClassName(<span class="string">'inner-hook'</span>)[<span class="number">0</span>]; <span class="comment">//使用inner-hook类来单纯被js操作</span></span><br><span class="line">          inner.style.webkitTransform = <span class="string">'translate3d(0,0,0)'</span>;</span><br><span class="line">          inner.style.transform = <span class="string">'translate3d(0,0,0)'</span>;</span><br><span class="line">          el.addEventListener(<span class="string">'transitionend'</span>, done); <span class="comment">//Vue为了知道过渡的完成，必须设置相应的事件监听器。</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      afterDrop(el) &#123; <span class="comment">//这个方法的执行是因为这是一个vue的监听事件</span></span><br><span class="line">        <span class="keyword">let</span> ball = <span class="keyword">this</span>.dropBalls.shift(); <span class="comment">//完成一次动画就删除一个dropBalls的小球</span></span><br><span class="line">        <span class="keyword">if</span> (ball) &#123;</span><br><span class="line">          ball.show = <span class="literal">false</span>;</span><br><span class="line">          el.style.display = <span class="string">'none'</span>; <span class="comment">//隐藏小球</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于transitionend</p></li><li><p>关于drop方法,是实现每一个ball的show属性和el属性处理,并且点击一次会自动将一个小球放到dropBalls数组里面,放到里面就代表的是一个小球已经被开始执行动画,但是由于动画是异步的,所以先主动设置.</p></li><li><p>关于getBoundingClientRect(位移的计算是从左上角开始)</p><ul><li><p>使用getBoundingClientRect获取到当前元素的坐标,然后需要位移的left减去元素的宽获取真正的最终位移x坐标</p></li><li><p>使用getBoundingClientRect获取到当前元素的坐标,然后需要当前屏幕的高度减去元素的top再减去元素本身的高度获取到真正的最终位移y坐标,并且这个是负数,因为是从左上角往下的方向</p></li></ul></li><li><p>关于html重绘</p><ul><li><p>因为浏览器对于重绘是有要求并且是有队列完成的,这是主要为了性能,虽然动画隐藏了小球<code>display none</code>,但没有触发html重绘,或者说没有立即触发html重绘,所以需要手动</p></li><li><p><code>let rf = el.offsetHeight</code>; 这是一个手动触发html重绘的方法</p></li><li><p>网页性能管理详解</p></li><li><p>高性能JavaScript 重排与重绘</p></li></ul></li></ul><h1 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ball-container</span></span><br><span class="line">  <span class="selector-class">.ball</span></span><br><span class="line">    position: fixed //小球动画必须脱离html布局流</span><br><span class="line">    <span class="selector-tag">left</span>: 32<span class="selector-tag">px</span></span><br><span class="line">    <span class="selector-tag">bottom</span>: 22<span class="selector-tag">px</span></span><br><span class="line">    <span class="selector-tag">z-index</span>: 200 </span><br><span class="line">    <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 0<span class="selector-class">.4s</span> <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.49</span>, <span class="selector-tag">-0</span><span class="selector-class">.29</span>, 0<span class="selector-class">.75</span>, 0<span class="selector-class">.41</span>)</span><br><span class="line">    <span class="selector-class">.inner</span></span><br><span class="line">      <span class="selector-tag">width</span>: 16<span class="selector-tag">px</span></span><br><span class="line">      <span class="selector-tag">height</span>: 16<span class="selector-tag">px</span></span><br><span class="line">      <span class="selector-tag">border-radius</span>: 50%</span><br><span class="line">      <span class="selector-tag">background</span>: <span class="selector-tag">rgb</span>(0, 160, 220)</span><br><span class="line">      <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 0<span class="selector-class">.4s</span> <span class="selector-tag">linear</span></span><br></pre></td></tr></table></figure><ul><li>关于<code>cubic-bezier(0.49, -0.29, 0.75, 0.41)</code>,是动画抛物曲线(贝塞尔曲线)的配置,基于css3实现,<a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="noopener">http://cubic-bezier.com/#.17,.67,.83,.67</a>,参考<a href="http://www.zhangxinxu.com/wordpress/2013/08/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF-cubic-bezier-css3%E5%8A%A8%E7%94%BB-svg-canvas/" target="_blank" rel="noopener">贝塞尔曲线与CSS3动画、SVG和canvas的基情</a> ,至于抛物线放在外层就是为了控制内层的元素的轨道和方向的.</li></ul>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2019/06/01/11.vue/14.Vuex/"/>
      <url>/2019/06/01/11.vue/14.Vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Vuex概述"><a href="#一、Vuex概述" class="headerlink" title="一、Vuex概述"></a>一、Vuex概述</h1><h2 id="1-组件之间共享数据的方式"><a href="#1-组件之间共享数据的方式" class="headerlink" title="1.组件之间共享数据的方式"></a>1.组件之间共享数据的方式</h2><p>父向子传值 v-bind 属性绑定<br>子向父传值 v-on 事件绑定<br>兄弟组件 EventBus<br>$on 接收数据的组件<br>$emit 发送数组的组件</p><h2 id="2-VueX是什么"><a href="#2-VueX是什么" class="headerlink" title="2.VueX是什么"></a>2.VueX是什么</h2><p>实现组件全局状态（数据）管理的一种机制，方便的实现组件之间数组的共享<br>一般组件之间共享的数据才有必要存储到vuex中，组件的私有数据可以不存到vuex中</p><h2 id="3-使用vuex的优点"><a href="#3-使用vuex的优点" class="headerlink" title="3.使用vuex的优点"></a>3.使用vuex的优点</h2><p>集中管理共享的数据，易于开发和后期维护<br>高效的实现组件之间的数据共享，提高开发效率<br>存储在vuex里的数据都是响应式的，能够实时保持数据与页面的同步</p><h1 id="二、vuex的基本使用"><a href="#二、vuex的基本使用" class="headerlink" title="二、vuex的基本使用"></a>二、vuex的基本使用</h1><h2 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h2><p><code>npm i vuex -S</code></p><h2 id="2-导入并且use"><a href="#2-导入并且use" class="headerlink" title="2.导入并且use"></a>2.导入并且use</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h2 id="3-创建store对象"><a href="#3-创建store对象" class="headerlink" title="3.创建store对象"></a>3.创建store对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state:&#123;&#125;,</span><br><span class="line">mutations:&#123;&#125;,</span><br><span class="line">actions:&#123;&#125;,</span><br><span class="line">getters:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h2 id="4-将store对象挂载到vue实例中"><a href="#4-将store对象挂载到vue实例中" class="headerlink" title="4.将store对象挂载到vue实例中"></a>4.将store对象挂载到vue实例中</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">store,</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>使用脚手架创建的话会生成一个store.js，自动在main.js上挂载</p><h1 id="三、vuex的核心概念"><a href="#三、vuex的核心概念" class="headerlink" title="三、vuex的核心概念"></a>三、vuex的核心概念</h1><h2 id="1-state"><a href="#1-state" class="headerlink" title="1.state"></a>1.state</h2><p>提供唯一的公共数据源，所有共享数据都要放到store的state属性里</p><p>组件访问state的数据的方式</p><ul><li>方式1： <code>this.$store.state.数据变量名</code> 可以用插值表达式输出，不需要加this</li><li>方式2：<br>从vuex中导入mapState函数 <code>import {mapState} from &#39;vuex&#39;</code><br>通过计算属性，映射要使用的全局变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">...mapState([<span class="string">'变量名'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就可以把全局变量当做计算属性来使用</p><h2 id="2-mutations"><a href="#2-mutations" class="headerlink" title="2.mutations"></a>2.mutations</h2><p>vuex不允许组件直接修改store里面的数据，只能使用mutations修改数据<br>方便后期维护，不然不知道是哪个组件修改了数据</p><ul><li><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">add (state,num) &#123; <span class="comment">//这里的state就是store里面的state</span></span><br><span class="line">state.count+=num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发mutations方法：<br>方式1：<br><code>this.$store.commit(&#39;add&#39;,10)//add是mutation里定义的方法名,10是传递过去的参数</code><br>方式2：<br>从vuex中导入mapMutations函数<br><code>import {mapMutations} from &#39;vuex&#39;</code><br>将要触发的函数映射为当前组件的methods方法，可以直接this调用（也可以直接在按钮行内事件里调用映射的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">...mapMutations([<span class="string">'dec1'</span>]),<span class="comment">//dec1是在mutation里定义的方法名</span></span><br><span class="line">decone () &#123;</span><br><span class="line"><span class="keyword">this</span>.dec1(<span class="number">5</span>) <span class="comment">//5是传递的参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-actions"><a href="#3-actions" class="headerlink" title="3.actions"></a>3.actions</h2><p>mutations里面不能写异步方法，处理异步任务需要在actions里触发mutation<br>actions中不能直接修改state里的数据，需要使用<code>context.commit</code>触发mutations里的方法</p><ul><li><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; </span><br><span class="line"><span class="comment">// ...省略其他代码 </span></span><br><span class="line">mutations: &#123; </span><br><span class="line">addN(state, num) &#123; </span><br><span class="line">state.count += num </span><br><span class="line">&#125;</span><br><span class="line">&#125;, </span><br><span class="line">actions: &#123; </span><br><span class="line">addnAsync(context, num) &#123; </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">context.commit(<span class="string">'addN'</span>, num) </span><br><span class="line">&#125;, <span class="number">1000</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>触发actions里的方法：<br>方式1：<br><code>this.$store.dispatch(&#39;addNAsync&#39;, 5)</code><br>方式2：<br>从vuex中导入mapActions函数<br><code>import { mapActions } from &#39;vuex&#39;</code><br>将要触发的函数映射为当前组件的methods方法，可以直接在按钮里调用映射的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&apos;dec1&apos;&gt;&lt;/button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapActions([&apos;dec1&apos;]),//dec1是在actions里定义的方法名，也需要在Mutations里操作数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参数的传递过程： 组件的methods =&gt; actions的方法 =&gt; mutations的方法 </p><h2 id="4-getters"><a href="#4-getters" class="headerlink" title="4.getters"></a>4.getters</h2><p>用于对store中的数据进行加工处理生成新数据<br>不会修改源数据，类似Vue的计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'最新的num是'</span>+state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法<br>方式1：<code>this.$store.getters.名称</code><br>方式2：<br>在当前组件从vuex中导入mapGetters函数<br><code>import {mapState} from &#39;vuex&#39;</code><br>通过计算属性，映射要使用的全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">...mapGetters([<span class="string">'变量名'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把getters处理过的数据当做计算属性来使用，类似state</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue其他知识</title>
      <link href="/2019/06/01/11.vue/13.Vue%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/06/01/11.vue/13.Vue%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Vue双向绑定原理"><a href="#1-Vue双向绑定原理" class="headerlink" title="1.Vue双向绑定原理"></a>1.Vue双向绑定原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(对象,属性,&#123;</span><br><span class="line">get:function()&#123;&#125;,</span><br><span class="line">set:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>监听对象绑定的属性，获取或者设置值都会监听到<br>获取会触发get,设置会触发set</p><h1 id="2-自定义组件"><a href="#2-自定义组件" class="headerlink" title="2.自定义组件"></a>2.自定义组件</h1><p>创建一个XX.vue就是一个自定义组件，添加路由就可以访问到这个组件<br>1.全局组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Ceshi <span class="keyword">from</span> <span class="string">'./components/ceshi.vue'</span></span><br><span class="line">Vue.component(<span class="string">"el-ceshi"</span>,Ceshi)</span><br></pre></td></tr></table></figure><p>2.局部组件<br>在组件内部的components里面添加自定义组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">ceshi:Ceshi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>Vue.use()</code>使用<br>参考<a href="https://blog.csdn.net/wang729506596/article/details/81018270" target="_blank" rel="noopener">https://blog.csdn.net/wang729506596/article/details/81018270</a><br>其实本质也是使用全局注册</p><h1 id="3-vue的keep-alive组件"><a href="#3-vue的keep-alive组件" class="headerlink" title="3.vue的keep-alive组件"></a>3.vue的keep-alive组件</h1><p>当在组件之间切换的时候，有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。<br>可以使用keep-alive标签把要保持状态的组件包裹起来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"current"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，被切换到的组件都要有自己的名字，不论是通过组件的 name选项还是局部/全局注册。<br>使用<code>&lt;keep-alive&gt;</code>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。<br>被包含在<code>&lt;keep-alive&gt;</code> 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated<br>　　activated：在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。<br>　　deactivated：在组件被停用时调用。<br>　　注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。<br>什么时候获取数据？<br>　　当引入keep-alive 的时候，页面第一次进入，钩子的触发顺序<code>created-&gt; mounted-&gt; activated</code>，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。</p><h1 id="4-虚拟DOM和diff算法"><a href="#4-虚拟DOM和diff算法" class="headerlink" title="4.虚拟DOM和diff算法"></a>4.虚拟DOM和diff算法</h1><p>虚拟DOM：虚拟DOM就是为了解决浏览器性能问题而被设计出来的；用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制</p><p>Diff算法只是为了更高效的更新虚拟DOM，通过Diff算法得到结果数据表(需要进行哪些操作记录表)。原本要操作的DOM在vue这边还是要操作的，只不过用到了js的DOM fragment来操作dom（统一计算出所有变化后统一更新一次DOM）进行浏览器DOM一次性更新</p><h1 id="5-hash模式和history模式"><a href="#5-hash模式和history模式" class="headerlink" title="5.hash模式和history模式"></a>5.hash模式和history模式</h1><p>vue-router有hash模式和history模式</p><ul><li>hash： 比如url类似<code>http://www.abv.com/#/hello</code><br>hash值是<code>#/hello</code>，特点是不会被包括在http请求中，改变hash不会重新加载页面</li><li>history：利用了html5新增的<code>pushState()</code>和<code>replaceState()</code>方法，应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能，当他们执行修改时，虽然改变了url但浏览器不会立即向后端发送请求</li></ul><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如<code>http://www.abc.com</code>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <code>http://www.abc.com/book/id</code>。如果后端缺少对<code>/book/id</code> 的路由处理，将返回 404 错误。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue后台管理系统</title>
      <link href="/2019/06/01/11.vue/12.Vue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/06/01/11.vue/12.Vue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-登录-退出"><a href="#1-登录-退出" class="headerlink" title="1.登录/退出"></a>1.登录/退出</h1><h2 id="保持登录状态方法："><a href="#保持登录状态方法：" class="headerlink" title="保持登录状态方法："></a>保持登录状态方法：</h2><p>客户端cookie，服务器session 或者 token<br>不存在跨域使用cookie和session<br>存在跨域使用token，token原理：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/token.jpg" alt></p><h2 id="创建login组件"><a href="#创建login组件" class="headerlink" title="创建login组件"></a>创建login组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&apos;less&apos; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>导入组件<br><code>import Login from &#39;./components/Login.vue&#39;</code></p><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">routes: [&#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    redirect: &apos;/login&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/login&apos;,</span><br><span class="line">    component: Login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><h2 id="App-vue里添加占位符"><a href="#App-vue里添加占位符" class="headerlink" title="App.vue里添加占位符"></a>App.vue里添加占位符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:app</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&apos;less&apos; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="书写全局样式"><a href="#书写全局样式" class="headerlink" title="书写全局样式"></a>书写全局样式</h2><p>添加一个全局样式文件global.css 在main.js里引入，因为main是入口文件<br><code>import &#39;./assets/css/global.css&#39;</code></p><h2 id="登录表单的数据绑定："><a href="#登录表单的数据绑定：" class="headerlink" title="登录表单的数据绑定："></a>登录表单的数据绑定：</h2><p>给form元素添加Model   <code>:model=&quot;loginForm&quot;</code><br>给输入框绑定属性   <code>v-model = &quot;loginForm.username&quot;</code>  <code>v-model = &quot;loginForm.password&quot;</code><br>在组件的script里绑定数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">return &#123; </span><br><span class="line">loginForm:&#123;</span><br><span class="line">username:&apos;123&apos;,</span><br><span class="line">password:&apos;123&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表单的前台验证"><a href="#表单的前台验证" class="headerlink" title="表单的前台验证"></a>表单的前台验证</h2><p>给form元素绑定 <code>:rules=&quot;loginFormRules&quot;</code><br>给form-item添加<code>prop=&#39;username&#39;</code><br>在data里绑定规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loginFormRules:&#123;</span><br><span class="line">username:[</span><br><span class="line">&#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'请输入用户名'</span>, <span class="attr">trigger</span>: <span class="string">'blur'</span>&#125;,</span><br><span class="line">&#123;规则<span class="number">2</span>&#125;</span><br><span class="line">],</span><br><span class="line">password:[&#123;&#125;,&#123;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h2><p>给表单Form添加<code>ref=&quot;loginFormRef&quot;</code><br>给重置按钮添加点击事件，点击后执行以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里的this就是vue的组件，通过this.$refs可以获取到表单引用对象 vue内置对象</span><br><span class="line">this.$refs.loginFormRef.resetFields();</span><br></pre></td></tr></table></figure><p>表单的引用对象的方法 <code>resetFields()</code>将所有字段值重置为初始值并移除校验结果</p><h2 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h2><p>在入口文件main.js里引入axios </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">//一般把axios添加到Vue的原型上 这样this.$http就相当于axios</span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line">axios.defaults.baseURL = &quot;http://127.0.0.1:8888/api/private/v1/&quot;</span><br></pre></td></tr></table></figure><h2 id="登录前预验证"><a href="#登录前预验证" class="headerlink" title="登录前预验证"></a>登录前预验证</h2><p>使用 表单的引用对象 的方法validate  这些表单的方法都是elementui自带的，验证规则就是上面定义的验证规则rules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line"><span class="keyword">this</span>.$refs.loginFormRef.validate( <span class="keyword">async</span> valid =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(!valid) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(<span class="string">'输入验证失败'</span>); <span class="comment">//valid如果是false验证失败</span></span><br><span class="line"><span class="comment">//如果验证成功，使用axios发送ajax</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.post(<span class="string">'login'</span>,<span class="keyword">this</span>.loginForm)</span><br><span class="line"><span class="keyword">if</span>(res.meta.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.$message.error(<span class="string">'登录失败'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.$message.success(<span class="string">'登录失败'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功后 保存token到sessionStorage，跳转到home页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'token'</span>,res.data.token);</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">"/home"</span>)<span class="comment">//路由式导航</span></span><br></pre></td></tr></table></figure><h2 id="Vue路由导航守卫"><a href="#Vue路由导航守卫" class="headerlink" title="Vue路由导航守卫"></a>Vue路由导航守卫</h2><p>可以用来控制页面访问权限<br>有些页面只有在登录后才允许访问。 在router.js里修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(...)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//to:将要访问的路径，from:从哪个路径跳转，next是一个放行函数，里面可以写路径强制跳转</span></span><br><span class="line"><span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) <span class="keyword">return</span> next();</span><br><span class="line"><span class="comment">//获取token</span></span><br><span class="line"><span class="keyword">const</span> tokenStr = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line"><span class="comment">//如果token不存在，强制跳转到登录页</span></span><br><span class="line"><span class="keyword">if</span> (!tokenStr) <span class="keyword">return</span> next(<span class="string">'/login'</span>);</span><br><span class="line"><span class="comment">//如果token存在，放行</span></span><br><span class="line">next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h2 id="elementUI的提示信息框"><a href="#elementUI的提示信息框" class="headerlink" title="elementUI的提示信息框"></a>elementUI的提示信息框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$message.error(&apos;出错了&apos;)</span><br><span class="line">this.$message.success(&apos;成功了&apos;)</span><br></pre></td></tr></table></figure><h1 id="2-导航菜单页面"><a href="#2-导航菜单页面" class="headerlink" title="2.导航菜单页面"></a>2.导航菜单页面</h1><p>接口文档规定：需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌<br>在入口文件index.js设置axios的请求拦截器；<br>登录之后再调用其他接口时都会带着这个请求拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取菜单数据"><a href="#获取菜单数据" class="headerlink" title="获取菜单数据"></a>获取菜单数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> getMenuList () &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.$http.get(<span class="string">'menus'</span>)</span><br><span class="line"><span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) <span class="keyword">return</span> <span class="keyword">this</span>.$message.error(res.meta.msg)</span><br><span class="line"><span class="keyword">this</span>.menulist = res.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环数据渲染导航菜单"><a href="#循环数据渲染导航菜单" class="headerlink" title="循环数据渲染导航菜单"></a>循环数据渲染导航菜单</h2><p>elementui导航菜单的index属性需要是唯一值，不然点击一个菜单，所有同Index的都会折叠</p><p>添加一个对象存放不同Id下的图标信息</p><p>实现侧边栏折叠功能</p><p>实现欢迎界面，嵌套到home页面，写组件和子路由</p><p>为二级导航添加路由链接<br>给<code>el-menu</code>添加router字段，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</p><h1 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3.用户管理"></a>3.用户管理</h1><p>渲染用户列表<br>elementui的表格元素el-table<br>使用<code>:data</code>接收数据<br>给它的表头元素设置 <code>prop=&quot;数组里对象的属性名&quot;</code> 就能遍历数据生成表格结构 </p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>scope.row就是数据里的每一个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">"scope.row.mg_state"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在一个组件内部写其他组件或者标签，需要使用template</p><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><ul><li>更改用户状态功能</li><li>搜索用户功能</li><li>搜索框自带一个clearable属性可以显示清空按钮，触发点击清空事件是<code>@clear</code></li><li>添加用户功能</li></ul><h2 id="自定义验证规则"><a href="#自定义验证规则" class="headerlink" title="自定义验证规则"></a>自定义验证规则</h2><p>先在data里定义验证规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkMobile = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(1[3-9][0-9]&#123;9&#125;)$/</span></span><br><span class="line"><span class="keyword">if</span> (!reg.test(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'手机号格式不正确'</span>))</span><br><span class="line">&#125;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在FormRule里使用规则：<br><code>email: [{validator: checkEmail,trigger: &#39;blur&#39;}]</code></p><ul><li>编辑和删除用户功能</li></ul><h1 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4.权限管理"></a>4.权限管理</h1><ul><li>实现权限列表渲染<br>使用树形控件渲染el-tree</li><li>权限分配 </li></ul><h1 id="5-商品管理"><a href="#5-商品管理" class="headerlink" title="5.商品管理"></a>5.商品管理</h1><p>分类列表渲染 使用插件 <code>vue-table-with-tree-grid</code></p><ul><li><p>安装并引入：<br><code>import ZkTable from &#39;vue-table-with-tree-grid&#39;</code><br><code>Vue.component(&#39;tree-table&#39;, ZkTable)</code></p></li><li><p>添加标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-table</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"treeTable"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:data</span>=<span class="string">"catelist"</span>  显示的表格数据数组</span></span><br><span class="line"><span class="tag"><span class="attr">:columns</span>=<span class="string">"columns"</span> 设置表头和显示的数据名字</span></span><br><span class="line"><span class="tag"><span class="attr">:selection-type</span>=<span class="string">"false"</span> 是否需要复选框</span></span><br><span class="line"><span class="tag"><span class="attr">:expand-type</span>=<span class="string">"false"</span> 是否展开</span></span><br><span class="line"><span class="tag"><span class="attr">show-index</span> 是否显示索引</span></span><br><span class="line"><span class="tag"><span class="attr">index-text</span>=<span class="string">"#"</span> 索引文字</span></span><br><span class="line"><span class="tag"><span class="attr">border</span> 是否有竖边框</span></span><br><span class="line"><span class="tag"><span class="attr">:show-row-hover</span>=<span class="string">"false"</span> 是否显示鼠标移入效果</span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">tree-table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>插件里使用自定义模板列<br>columns里面的对象添加type为template，template为模板名字<br>模板在tree-table标签内部定义  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"isok"</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-success"</span> <span class="attr">style</span>=<span class="string">"color:lightgreen"</span> <span class="attr">v-if</span>=<span class="string">"scope.row.cat_deleted==false"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-failed"</span> <span class="attr">style</span>=<span class="string">"color:red"</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="nextTick-方法"><a href="#nextTick-方法" class="headerlink" title="$nextTick()方法"></a>$nextTick()方法</h2><p>是页面的元素被重新渲染之后，才会执行它的回调函数<br>新增标签时，一开始没有输入框，点击+New Tag显示出来，才能获取焦点，所以要使用$nextTick</p><h1 id="6-订单管理和统计分析"><a href="#6-订单管理和统计分析" class="headerlink" title="6.订单管理和统计分析"></a>6.订单管理和统计分析</h1><p>1.引入echarts<br>2.准备一个div并初始化<br><code>var mychart = echarts.init(div)</code><br>3.准备配置数据option，是一个对象，里面是配置项<br>4.<code>mychart.setOption(option)</code>生成图表</p><p>threes.js 图表 是3D图表<br>白鹭引擎 cocos2d 做游戏</p><h1 id="7-Nprogress加载进度条"><a href="#7-Nprogress加载进度条" class="headerlink" title="7.Nprogress加载进度条"></a>7.Nprogress加载进度条</h1><p>安装包Nprogress<br>在main.js导入包和css文件<br>在axios的请求拦截器显示进度条<code>NProgress.start()</code><br>在axios的响应拦截器隐藏进度条 <code>NProgress.done()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">NProgress.done()</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实element自带一个loading效果，也自带进度条效果</p><h1 id="8-在项目build期间移除所有的console"><a href="#8-在项目build期间移除所有的console" class="headerlink" title="8.在项目build期间移除所有的console"></a>8.在项目build期间移除所有的console</h1><p>npm run build时会报错提示不允许使用console.log，使用以下方法移除<br>安装插件 <code>babel-plugin-transform-remove-console</code><br>在babel.config.js里使用插件： plugins里面添加插件名字<code>transform-remove-console</code></p><p>如何只在发布阶段移除console：<br>定义一个只在发布阶段使用的插件数组<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/buildconsole.jpg" alt></p><h1 id="9-查看build构建报告"><a href="#9-查看build构建报告" class="headerlink" title="9.查看build构建报告"></a>9.查看build构建报告</h1><p>在package.json里<code>&quot;build&quot;: &quot;vue-cli-service build --report&quot;</code>添加report字段<br>打包后生成打包报告report.html</p><h1 id="10-使用vue-config-js修改webpack的默认配置"><a href="#10-使用vue-config-js修改webpack的默认配置" class="headerlink" title="10.使用vue.config.js修改webpack的默认配置"></a>10.使用vue.config.js修改webpack的默认配置</h1><p>在项目根目录创建vue.config.js，module.exports导出配置对象<br>具体的配置项参考官方文档，类似webpack.config.js的配置<br>如配置启动项目默认打开浏览器，配置端口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8899</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="为开发模式和发布模式配置不同的打包入口"><a href="#为开发模式和发布模式配置不同的打包入口" class="headerlink" title="为开发模式和发布模式配置不同的打包入口"></a>为开发模式和发布模式配置不同的打包入口</h2><p>开发模式入口文件： main-dev.js<br>发布模式入口文件： main-prod.js<br>在vue.config.js文件里，使用configureWebpack或者chainWebpack修改打包入口<br>两种方式作用相同，实现方式不同，chain 是通过链式编程的方式，config是通过操作对象的方式修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'production'</span>, config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)<span class="comment">//清除默认的打包入口，添加新的</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'development'</span>, config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过externals加载外部CDN资源"><a href="#通过externals加载外部CDN资源" class="headerlink" title="通过externals加载外部CDN资源"></a>通过externals加载外部CDN资源</h2><p>默认import引入的js文件，生成的js文件合并后体积过大，可以使用CDN加载外部资源<br>使用webpack的externals节点，可以在打包时忽略某些包，用到包时去 window全局查找对象并使用</p><p>修改vue.config.js，只在发布阶段修改即可：（以vue这个js文件举例）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'production'</span>, config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-prod.js'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    config.set(<span class="string">'externals'</span>), &#123;</span><br><span class="line">      vue: <span class="string">'Vue'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    config.when(process.env.NODE_ENV === <span class="string">'development'</span>, config =&gt; &#123;</span><br><span class="line">      config.entry(<span class="string">'app'</span>).clear().add(<span class="string">'./src/main-dev.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>public/index.html</code>文件引入js文件和css文件 都是cdn链接的形式<br><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></p><h1 id="11-路由懒加载"><a href="#11-路由懒加载" class="headerlink" title="11.路由懒加载"></a>11.路由懒加载</h1><p>把不同路由对应的组件分割成不同的代码块，当路由被访问才加载对应的组件，更加高效<br>1）安装<code>@babel/plugin-syntax-dynamic-import</code>包2）在babel.config.js配置此插件,在plugin里添加此插件名<code>‘@babel/plugin-syntax-dynamic-import’</code><br>3）将router.js里面的路由改成按需加载的格式，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "login_home_welcome" */</span> <span class="string">'./components/Login.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "login_home_welcome" */</span> <span class="string">'./components/Home.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "login_home_welcome" */</span> <span class="string">'./components/Welcome.vue'</span>)</span><br></pre></td></tr></table></figure><p>webpackChunckName是组件的分组名称，上面代码把login,home,welcome三个组件分在同一个组内，这样打包时会把这三个组件放入同一个文件里面。这样就实现了路由的懒加载</p><h1 id="12-项目上线"><a href="#12-项目上线" class="headerlink" title="12.项目上线"></a>12.项目上线</h1><h2 id="1-连接远程服务器，使用node创建web服务器"><a href="#1-连接远程服务器，使用node创建web服务器" class="headerlink" title="1.连接远程服务器，使用node创建web服务器"></a>1.连接远程服务器，使用node创建web服务器</h2><p>创建node项目，安装express，创建web服务器，将dist文件夹托管为静态资源（生成的dist是纯前端代码）<br><code>npm init</code> 初始化项目；创建app.js；启动服务器 <code>node app.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>) </span><br><span class="line"><span class="comment">// 创建 web 服务器 </span></span><br><span class="line"><span class="keyword">const</span> app = express() </span><br><span class="line"><span class="comment">// 托管静态资源 </span></span><br><span class="line">app.use(express.static(<span class="string">'./dist'</span>)) </span><br><span class="line"><span class="comment">// 启动 web 服务器 </span></span><br><span class="line">app.listen(<span class="number">80</span>, () =&gt; &#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'web server running at http://127.0.0.1'</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-开启gzip压缩"><a href="#2-开启gzip压缩" class="headerlink" title="2.开启gzip压缩"></a>2.开启gzip压缩</h2><p>gzip压缩可以减小网络传输的文件体积<br>通过服务器使用express做gzip压缩<br>在项目根目录安装包：npm i compression -S<br>require导入并且app.use这个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const compression = require(&apos;compression&apos;)</span><br><span class="line">app.use(compression()) //必须写在托管静态文件之前</span><br></pre></td></tr></table></figure><h2 id="3-开启HTTPS协议"><a href="#3-开启HTTPS协议" class="headerlink" title="3.开启HTTPS协议"></a>3.开启HTTPS协议</h2><p>传统的http协议是明文传输的，不太安全<br>申请SSL证书并下载公钥.pem 私钥文件.key，放到服务器上配置一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>); </span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"><span class="keyword">const</span> options = &#123; </span><br><span class="line">cert: fs.readFileSync(<span class="string">'./full_chain.pem'</span>), </span><br><span class="line">key: fs.readFileSync(<span class="string">'./private.key'</span>) </span><br><span class="line">&#125; </span><br><span class="line">https.createServer(options, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><h2 id="4-使用PM2管理项目"><a href="#4-使用PM2管理项目" class="headerlink" title="4.使用PM2管理项目"></a>4.使用PM2管理项目</h2><p>安装pm2：<code>npm i pm2 -g</code><br><code>pm2 start app.js --name 自定义名称</code> 启动项目<br><code>pm2 ls</code> 查看运行的项目<br><code>pm2 restart 项目名称</code> 重启项目<br><code>pm2 stop 项目名称</code> 停止项目<br><code>pm2 delete 项目名称</code> 删除项目<br>启动项目后，即使关掉终端也可以访问项目</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI</title>
      <link href="/2019/05/31/11.vue/11.ElementUI/"/>
      <url>/2019/05/31/11.vue/11.ElementUI/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Element-UI: 一套为开发者、设计师和产品经理准备的基于vue 2.0的桌面端组件库<br><a href="http://element-cn.eleme.io/#/zh-CH" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CH</a> </p></blockquote><p>ElementUI的基本使用</p><h2 id="1-使用命令行手动安装"><a href="#1-使用命令行手动安装" class="headerlink" title="1.使用命令行手动安装"></a>1.使用命令行手动安装</h2><p><code>npm i element-ui -S</code> //安装依赖包<br><code>import ElementUI from &#39;element-ui&#39;</code>//在main.js 导入组件库<br><code>import &#39;element-ui/lib/theme-chalk/index.css&#39;</code>//导入样式<br><code>Vue.use(ElementUI)</code>//这样导入是全部导入</p><p>运行<code>npm run serve</code></p><h2 id="2-基于图形化界面自动安装"><a href="#2-基于图形化界面自动安装" class="headerlink" title="2.基于图形化界面自动安装"></a>2.基于图形化界面自动安装</h2><p>vue ui 打开图形化界面<br>进入vue项目管理器：选择某个项目或者新建项目<br>插件-&gt;添加插件-&gt;搜索 <code>vue-cli-plugin-element</code>并安装<br>配置插件： 导入方式 选择<code>import on demand</code> 按需导入 用到的组件才会被导入，减少项目体积</p><p>选择 启动app</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue脚手架</title>
      <link href="/2019/05/30/11.vue/10.vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2019/05/30/11.vue/10.vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、vue脚手架的基本用法"><a href="#一、vue脚手架的基本用法" class="headerlink" title="一、vue脚手架的基本用法"></a>一、vue脚手架的基本用法</h1><p>vue 脚手架用于快速生成vue项目基础架构，简化了项目的创建流程<br><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/</a> </p><h2 id="1-安装步骤"><a href="#1-安装步骤" class="headerlink" title="1.安装步骤"></a>1.安装步骤</h2><p><code>npm i -g @vue/cli</code><br>推荐安装的是3.x的版本，支持创建新版和旧版的vue项目<br><code>vue -V</code>查看版本号</p><h2 id="2-创建vue项目的三种方式"><a href="#2-创建vue项目的三种方式" class="headerlink" title="2.创建vue项目的三种方式"></a>2.创建vue项目的三种方式</h2><p>前两种必须掌握</p><h3 id="1-基于交互式命令行的方式创建"><a href="#1-基于交互式命令行的方式创建" class="headerlink" title="1) 基于交互式命令行的方式创建"></a>1) 基于交互式命令行的方式创建</h3><p><code>vue create my-project</code><br>通过上下箭头选择，空格选定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 手动还是自动manually select features</span><br><span class="line">- 选择特性Router babel linter</span><br><span class="line">- 历史路由？ n 安装hash路由</span><br><span class="line">- eslint 版本 standard </span><br><span class="line">- 什么时候校验语法 Lint on save</span><br><span class="line">- 配置文件创建方式 单独创建 in dedicated </span><br><span class="line">- 是否保存配置为模板 y/n</span><br></pre></td></tr></table></figure><p>完成后打开项目根目录，输入npm run serve 就可以启动vue项目了</p><h3 id="2）基于图形化界面的方式创建"><a href="#2）基于图形化界面的方式创建" class="headerlink" title="2）基于图形化界面的方式创建"></a>2）基于图形化界面的方式创建</h3><p>输入vue ui进入webui界面，点击创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 设置项目名称</span><br><span class="line">- 初始化git 输入init project</span><br><span class="line">- 选择预设方案，可以手动选择，打开以下选项 babel router linter 使用配置文件</span><br><span class="line">- 历史路由 不打开</span><br><span class="line">- linter选择standard，选择lint on save</span><br></pre></td></tr></table></figure><p>任务面板里面可以启动项目 serve选项卡里运行；<br>点击启动app可以看到项目界面</p><h3 id="3-基于2-x的旧模板创建"><a href="#3-基于2-x的旧模板创建" class="headerlink" title="3) 基于2.x的旧模板创建"></a>3) 基于2.x的旧模板创建</h3><p><code>npm i -g @vue/cli-init</code><br><code>vue init webpack my-project</code><br>选择步骤里注意以下几点：<br>选择<code>runtime-only</code>版本<br>选择<code>npm</code></p><h2 id="3-vue脚手架项目文件结构"><a href="#3-vue脚手架项目文件结构" class="headerlink" title="3.vue脚手架项目文件结构"></a>3.vue脚手架项目文件结构</h2><p>node_modules 依赖包目录<br>public 静态资源目录<br>src 组件源码目录/程序员写的代码<br>assets 静态文件<br>components 组件<br>views 视图组件<br>App.vue 根组件<br>main.js 打包入口文件<br>router.js 路由文件<br>babel.config.js babel的配置文件</p><h2 id="4-vue脚手架的自定义配置"><a href="#4-vue脚手架的自定义配置" class="headerlink" title="4.vue脚手架的自定义配置"></a>4.vue脚手架的自定义配置</h2><ul><li><p>方式1 通过package.json配置项目  不推荐使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"vue"</span>:&#123;</span><br><span class="line"><span class="string">"devServer"</span>: &#123;</span><br><span class="line"><span class="string">"port"</span>:<span class="number">8888</span>, <span class="comment">//更改端口号</span></span><br><span class="line"><span class="string">"open"</span>:<span class="literal">true</span> <span class="comment">//设置自动打开浏览器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2 单独定义vue.config.js文件配置项目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">devServer: &#123;</span><br><span class="line">port:<span class="number">8888</span>, <span class="comment">//更改端口号</span></span><br><span class="line">open:<span class="literal">true</span> <span class="comment">//设置自动打开浏览器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue单文件组件</title>
      <link href="/2019/05/29/11.vue/9.vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/05/29/11.vue/9.vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、传统组件的问题和解决方案"><a href="#一、传统组件的问题和解决方案" class="headerlink" title="一、传统组件的问题和解决方案"></a>一、传统组件的问题和解决方案</h1><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>1)全局定义的组件不可以重名<br>2)字符串模板没有语法高亮，html多行时需要用到\转义<br>3)不支持CSS<br>4)没有构建步骤限制，只能使用html和es5，不能使用预处理器如babel</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>使用Vue单文件组件</p><h1 id="二、单文件组件基本使用"><a href="#二、单文件组件基本使用" class="headerlink" title="二、单文件组件基本使用"></a>二、单文件组件基本使用</h1><h2 id="1-单文件组件的组成结构"><a href="#1-单文件组件的组成结构" class="headerlink" title="1.单文件组件的组成结构"></a>1.单文件组件的组成结构</h2><p>文件以.vue结尾，由三部分组成<br>template 组件的模板区域<br>script 业务逻辑区域<br>style 样式区域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;-- 这里定义vue组件的模板内容 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;-- 这里定义vue组件的业务逻辑 --&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data() &#123; return &#123;&#125; &#125;,//私有数据</span><br><span class="line">methods:&#123;&#125; //处理函数</span><br><span class="line">//其他业务逻辑</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"> /*这里定义组件的样式，scoped防止样式冲突*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="2-webpack中配置vue组件的加载器"><a href="#2-webpack中配置vue组件的加载器" class="headerlink" title="2.webpack中配置vue组件的加载器"></a>2.webpack中配置vue组件的加载器</h2><p>webpack默认无法处理vue文件，需要安装loader<br>①<code>npm i vue-loader vue-template-compiler -D</code><br>②在webpack.config.js文件中添加vue-loader的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">rules:[&#123;<span class="attr">test</span>:<span class="regexp">/\.vue$/</span>,<span class="attr">loader</span>: <span class="string">'vue-loader'</span>&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">new</span> VueloaderPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-在webpack项目中使用vue"><a href="#3-在webpack项目中使用vue" class="headerlink" title="3.在webpack项目中使用vue"></a>3.在webpack项目中使用vue</h2><p>① 运行<code>npm i vue -S</code> 安装vue<br>② 在<code>src-&gt;index.js</code>入口文件中<br>通过<code>import Vue from &#39;vue&#39;</code> 导入构造函数<br>通过<code>import App from &#39;./components/App.vue&#39;</code> 导入Vue组件<br>③ 创建vue 实例，指定vue控制的el区域<br>④ 通过render函数渲染app根组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.vue'</span> <span class="comment">//导入写好的单文件组件</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">"#app"</span>, </span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//webpack下面只支持render渲染vue组件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-webpack打包发布"><a href="#4-webpack打包发布" class="headerlink" title="4.webpack打包发布"></a>4.webpack打包发布</h2><p>使用webpack将项目进行整体打包，修改package.json配置打包命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="comment">// 用于打包的命令</span></span><br><span class="line"><span class="string">"build"</span>: <span class="string">"webpack -p"</span>,</span><br><span class="line"><span class="comment">// 用于开发调试的命令</span></span><br><span class="line"><span class="string">"dev"</span>:<span class="string">"webpack-dev-server --open --host 127.0.0.1 --post 3000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>npm run build</code> 命令进行打包<br>生成的dist文件夹就是打包后的项目了。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2019/05/28/11.vue/8.webpack/"/>
      <url>/2019/05/28/11.vue/8.webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="1-webpack作用"><a href="#1-webpack作用" class="headerlink" title="1.webpack作用"></a>1.webpack作用</h1><p>当前web开发的问题：<br>文件依赖关系错综复杂<br>静态资源请求效率低<br>模块化支持不友好<br>浏览器对高级 Javascript 特性兼容程度较低<br>etc…<br>webpack 是一个流行的<strong>前端项目构建工具（打包工具）</strong>，可以解决当前 web 开发中所面临的困境。<br>webpack 提供了友好的<strong>模块化支持</strong>，以及<strong>代码压缩混淆、处理 js 兼容问题、性能优化</strong>等强大的功能，从而让程序员把工作的重心放到具体的功能实现上，提高了开发效率和项目的可维护性。<br>目前绝大多数企业中的前端项目，都是基于 webpack 进行打包构建的。 </p><p>1.把浏览器不认识的高级语法转成低级语法<br>2.把less转换成css<br>3.压缩代码体积<br>4.混淆代码 打乱代码 功能不受影响</p><h1 id="2-webpack基本使用"><a href="#2-webpack基本使用" class="headerlink" title="2.webpack基本使用"></a>2.webpack基本使用</h1><h2 id="1-打开项目目录终端，输入命令"><a href="#1-打开项目目录终端，输入命令" class="headerlink" title="1)打开项目目录终端，输入命令:"></a>1)打开项目目录终端，输入命令:</h2><p><code>npm install webpack webpack-cli -D</code><br>js文件导入jQuery <code>import $ from &#39;jquery&#39;</code></p><h2 id="2-然后在项目根目录中，创建一个-webpack-config-js-用来配置webpack"><a href="#2-然后在项目根目录中，创建一个-webpack-config-js-用来配置webpack" class="headerlink" title="2)然后在项目根目录中，创建一个 webpack.config.js 用来配置webpack"></a>2)然后在项目根目录中，创建一个 webpack.config.js 用来配置webpack</h2><p>文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">"development"</span><span class="comment">//可以设置为development(开发模式)，production(发布模式)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：mode设置的是项目的编译模式。<br>如果设置为development则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些<br>如果设置为production则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些</p><h2 id="3-修改项目中的package-json文件添加运行脚本dev，如下："><a href="#3-修改项目中的package-json文件添加运行脚本dev，如下：" class="headerlink" title="3)修改项目中的package.json文件添加运行脚本dev，如下："></a>3)修改项目中的package.json文件添加运行脚本dev，如下：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">    <span class="string">"dev"</span>:<span class="string">"webpack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：scripts节点下的脚本，可以通过 npm run 运行，如：<br>运行终端命令：<code>npm run dev</code> 将会启动webpack进行项目打包</p><h2 id="4-在页面中引入项目打包生成的js文件"><a href="#4-在页面中引入项目打包生成的js文件" class="headerlink" title="4)在页面中引入项目打包生成的js文件"></a>4)在页面中引入项目打包生成的js文件</h2><p>等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。<br>浏览页面查看效果。</p><h1 id="3-配置webpack的入口和出口"><a href="#3-配置webpack的入口和出口" class="headerlink" title="3.配置webpack的入口和出口"></a>3.配置webpack的入口和出口</h1><p>默认入口：<code>src/index.js</code><br>默认出口：<code>dist/main.js</code><br>修改入口和出口：在webpack.config.js中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">mode: <span class="string">"development"</span>,</span><br><span class="line">entry: path.join(__dirname, <span class="string">'./src/index.js'</span>),<span class="comment">//入口</span></span><br><span class="line">output: &#123;</span><br><span class="line">path: path.join(__dirname, <span class="string">'./dist'</span>), <span class="comment">//出口</span></span><br><span class="line">filename: <span class="string">'my.js'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-配置自动打包"><a href="#4-配置自动打包" class="headerlink" title="4.配置自动打包"></a>4.配置自动打包</h1><p>①运行 <code>npm install webpack-dev-server –D</code> 命令，安装支持项目自动打包的工具<br>②修改 <code>package.json -&gt; scripts</code> 中的 dev 命令如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123; </span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span> <span class="comment">// script 节点下的脚本，可以通过 npm run 执行 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③将 <code>src -&gt; index.html</code> 中，script 脚本的引用路径，修改为 <code>&quot;/buldle.js“</code><br><code>webpack-dev-server</code>直接在根目录中托管了js文件<br>④运行 <code>npm run dev</code> 命令，重新进行打包<br>⑤在浏览器中访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 地址，查看自动打包效果 </p><p>修改自动打包的相关参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json中的配置 </span></span><br><span class="line"><span class="comment">// --open 打包完成后自动打开浏览器页面 </span></span><br><span class="line"><span class="comment">// --host 配置 IP 地址 </span></span><br><span class="line"><span class="comment">// --port 配置端口 </span></span><br><span class="line"><span class="string">"scripts"</span>: &#123; </span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 8888"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-生成预览页面"><a href="#5-生成预览页面" class="headerlink" title="5.生成预览页面"></a>5.生成预览页面</h1><p>默认打开网站根目录时，显示的是一些文件路径，可以修改默认页面：</p><p>① 运行 <code>npm install html-webpack-plugin –D</code> 命令，安装生成预览页面的插件<br>② 修改 <code>webpack.config.js</code> 文件头部区域，添加如下配置信息： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入生成预览页面的插件，得到一个构造函数 </span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>) </span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="comment">// 创建插件的实例对象 </span></span><br><span class="line">template: <span class="string">'./src/index.html'</span>, <span class="comment">// 指定要用到的模板文件 </span></span><br><span class="line">filename: <span class="string">'index.html'</span> <span class="comment">// 指定生成的文件的名称，该文件存在于内存中，在目录中不显示 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>③ 修改 <code>webpack.config.js</code> 文件中向外暴露的配置对象，新增如下配置节点： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">plugins: [ htmlPlugin ] <span class="comment">// plugins 数组是 webpack 打包期间会用到的一些插件列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只要打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 就能显示index.html</p><h1 id="6-webpack中的加载器"><a href="#6-webpack中的加载器" class="headerlink" title="6.webpack中的加载器"></a>6.webpack中的加载器</h1><p>webpack默认只能打包 js模块；打包其他类型的模块需要调用Loader加载器：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vue-loader.jpg" alt></p><h2 id="1）打包CSS"><a href="#1）打包CSS" class="headerlink" title="1）打包CSS"></a>1）打包CSS</h2><p>① 运行 <code>npm i style-loader css-loader -D</code> 命令，安装处理 css 文件的 loader<br>② 在 <code>webpack.config.js</code> 的 <code>module.exports</code>中，添加如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [&#123;</span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，test 表示匹配的文件类型， use 表示对应要调用的 loader<br>注意：<br>use 数组中指定的 loader 顺序是固定的<br>多个 loader 的调用顺序是：从后往前调用</p><h2 id="2-打包less"><a href="#2-打包less" class="headerlink" title="2) 打包less"></a>2) 打包less</h2><p><code>npm i less-loader -D</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h2 id="3-打包sass"><a href="#3-打包sass" class="headerlink" title="3) 打包sass"></a>3) 打包sass</h2><p>sass和less语法相同<br><code>npm i  sass-loader node-sass -D</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h2 id="4-使用postcss插件处理CSS兼容性问题"><a href="#4-使用postcss插件处理CSS兼容性问题" class="headerlink" title="4) 使用postcss插件处理CSS兼容性问题"></a>4) 使用postcss插件处理CSS兼容性问题</h2><p>自动生成不同浏览器下的前缀<br>①运行 <code>npm i postcss-loader autoprefixer -D</code> 安装插件<br>②在项目根目录创建postcss.config.js，初始化配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) <span class="comment">//导入自动添加前缀的插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">plugins:[autoprefixer]<span class="comment">//挂载插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③在webpack.config.js的<code>module -&gt; rules</code>数组中，修改css的loader规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules:[ </span><br><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$, use:['style-loader','css-loader','postcss-loader']&#125;</span></span><br><span class="line"><span class="regexp">]</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-打包样式表中的图片和字体文件"><a href="#5-打包样式表中的图片和字体文件" class="headerlink" title="5) 打包样式表中的图片和字体文件"></a>5) 打包样式表中的图片和字体文件</h2><p>webpack默认情况下不能处理图片和字体文件，需要loader</p><p>①运行 <code>npm i url-loader file-loader -D</code> 安装插件<br>②在<code>webpack.config.js</code>的<code>module -&gt; rules</code>数组中，添加css的loader规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules:[</span><br><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>, <span class="attr">use</span>:<span class="string">'url-loader?limit=16940'</span>&#125;</span><br><span class="line"><span class="comment">//use后面如果只有一个Loader可以不用写成数组</span></span><br><span class="line"><span class="comment">//limit是图片大小,只有小于limit才会被转成base64格式，加载速度更快</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-打包js里的高级语法"><a href="#6-打包js里的高级语法" class="headerlink" title="6) 打包js里的高级语法"></a>6) 打包js里的高级语法</h2><p>webpack默认情况下不能处理js的高级语法<br>①安装babel转换器相关包<br><code>npm i babel-loader @babel/core @babel/runtime -D</code><br>②安装babel 语法插件相关的包：<br><code>npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D</code><br>③在项目根目录创建babel配置文件babel.config.js并初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">presets:[<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">plugins:[<span class="string">'@babel/plugin-transform-runtime'</span>,<span class="string">'@babel/plugin-proposal-class-properties'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④在<code>webpack.config.js</code>的<code>module -&gt; rules</code>数组中，添加loader规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules:[</span><br><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>, <span class="attr">use</span>:<span class="string">'babel-loader'</span>,<span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化-模块化规范</title>
      <link href="/2019/05/25/11.vue/7.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96_%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <url>/2019/05/25/11.vue/7.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96_%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-模块化概述"><a href="#1-模块化概述" class="headerlink" title="1.模块化概述"></a>1.模块化概述</h2><p>方便代码重用 提升开发效率 方便后期维护</p><h2 id="2-浏览器端的模块化规范"><a href="#2-浏览器端的模块化规范" class="headerlink" title="2.浏览器端的模块化规范"></a>2.浏览器端的模块化规范</h2><p>AMD require.js<br>CMD sea.js</p><h2 id="3-服务器端的模块化规范"><a href="#3-服务器端的模块化规范" class="headerlink" title="3.服务器端的模块化规范"></a>3.服务器端的模块化规范</h2><p>CommonJs<br>require,exports,module.exports</p><h2 id="4-ES6模块化规范"><a href="#4-ES6模块化规范" class="headerlink" title="4.ES6模块化规范"></a>4.ES6模块化规范</h2><p>以上规范不是浏览器和服务器通用模块化标准，ES6是通用的</p><p>每个 js 文件都是一个独立的模块<br>导入模块成员使用 import 关键字<br>暴露模块成员使用 export 关键字 </p><p>node通过babel体验ES6模块化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">babel把高级语法转换成浏览器识别的低级语法</span><br><span class="line">①npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node</span><br><span class="line">②npm install --save @babel/polyfill</span><br><span class="line">③项目跟目录创建文件 babel.config.js</span><br><span class="line">④babel.config.js 文件内容如下方代码</span><br><span class="line">⑤通过 npx babel-node index.js 执行js代码</span><br><span class="line"><span class="keyword">const</span> presets = [ </span><br><span class="line">[<span class="string">"@babel/env"</span>, </span><br><span class="line">&#123; <span class="attr">targets</span>: </span><br><span class="line">&#123; <span class="attr">edge</span>: <span class="string">"17"</span>, <span class="attr">firefox</span>: <span class="string">"60"</span>, <span class="attr">chrome</span>: <span class="string">"67"</span>, <span class="attr">safari</span>: <span class="string">"11.1"</span> &#125; </span><br><span class="line">&#125;</span><br><span class="line">] </span><br><span class="line">]; </span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure><h2 id="5-ES6模块化基本语法"><a href="#5-ES6模块化基本语法" class="headerlink" title="5.ES6模块化基本语法"></a>5.ES6模块化基本语法</h2><p>默认导出： <code>export default { 成员 }</code><br>默认导入：<code>import 接收名称 from &#39;文件&#39;</code></p><p>按需导出 <code>export let s1 =10</code><br>按需导入<code>import  { s1 } from &#39;文件&#39;</code></p><p>默认导入的接收变量，不会接收按需导出的值<br>只能用一次默认导出，但可以用多次按需导出</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由</title>
      <link href="/2019/05/22/11.vue/6.vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/05/22/11.vue/6.vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、路由的概念和原理"><a href="#一、路由的概念和原理" class="headerlink" title="一、路由的概念和原理"></a>一、路由的概念和原理</h1><p>路由就是对应关系</p><h2 id="1-路由分类"><a href="#1-路由分类" class="headerlink" title="1.路由分类"></a>1.路由分类</h2><ul><li>后端路由：根据不同的URL请求，返回不同的内容；<br>本质：URL与服务器资源之间的对应关系</li><li>前端路由：根据不同用户事件，显示不同的页面<br>本质：用户事件与事件处理函数之间的对应关系</li></ul><p>后端路由渲染页面的方式称为后端渲染（存在性能问题，整页刷新）<br>Ajax前端渲染（局部刷新提高性能，但是不支持浏览器的前进后退操作） </p><p>SPA（Single Page Application）单页面应用程序：整个网站只有一个页面，内容的变化通过Ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作<br>SPA实现原理之一：基于URL地址的hash（hash的变化会导致浏览器记录访问历史的变化、但是<strong>hash的变化不会触发新的URL请求</strong>） 在实现SPA过程中，最核心的技术点就是前端路由。vue,react,angular都实现了SPA。</p><h2 id="2-简易前端路由-实现原理"><a href="#2-简易前端路由-实现原理" class="headerlink" title="2.简易前端路由/实现原理"></a>2.简易前端路由/实现原理</h2><p>基于URL的hash变化控制组件切换<br><code>location.hash</code>: 地址栏上#开头的值，锚点也属于hash<br><code>window.onhashchange</code> hash变化时触发的事件</p><p><code>&lt;component :is=&#39;zhuye&#39;&gt;&lt;/component&gt;</code>是组件的占位符<br>例如is里的值是zhuye时，相当于使用了组件<zhuye></zhuye></p><h1 id="二、Vue-Router"><a href="#二、Vue-Router" class="headerlink" title="二、Vue Router"></a>二、Vue Router</h1><p>vue官方的路由管理器，和vue.js深度集成</p><h2 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h2><p>支持HTML5 历史模式或 hash 模式<br>支持嵌套路由<br>支持路由参数<br>支持编程式路由<br>支持命名路由 </p><h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h2><h3 id="1）引入文件："><a href="#1）引入文件：" class="headerlink" title="1）引入文件："></a>1）引入文件：</h3><p>先引入vue，再引入vueRouter。会生成一个VueRouter构造</p><h3 id="2）添加路由链接："><a href="#2）添加路由链接：" class="headerlink" title="2）添加路由链接："></a>2）添加路由链接：</h3><p><code>&lt;router-link to=&quot;/user&quot;&gt;XXX&lt;/router-link&gt;</code><br>会解析为<code>&lt;a href=&quot;#/user&quot;&gt;XXX&lt;/a&gt;</code></p><h3 id="3）路由填充位（路由占位符）"><a href="#3）路由填充位（路由占位符）" class="headerlink" title="3）路由填充位（路由占位符）"></a>3）路由填充位（路由占位符）</h3><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><h3 id="4）路由组件"><a href="#4）路由组件" class="headerlink" title="4）路由组件"></a>4）路由组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123; </span><br><span class="line">template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）配置路由规则创建路由实例"><a href="#5）配置路由规则创建路由实例" class="headerlink" title="5）配置路由规则创建路由实例"></a>5）配置路由规则创建路由实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123; </span><br><span class="line">routes: [ </span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/user'</span>,<span class="attr">component</span>: User&#125;, </span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>: Register&#125; </span><br><span class="line">] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>routes是路由规则数组<br>每个路由规则都是一个配置对象，其中至少包含 path 和 component 两个属性：<br><code>//path 表示当前路由规则匹配的 hash 地址</code><br><code>//component 表示当前路由规则对应要展示的组件</code></p><h3 id="6）挂载路由"><a href="#6）挂载路由" class="headerlink" title="6）挂载路由"></a>6）挂载路由</h3><p>在new Vue实例时挂载router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">"#app"</span>,</span><br><span class="line">router:router <span class="comment">//可以简写为router</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-路由重定向"><a href="#3-路由重定向" class="headerlink" title="3.路由重定向"></a>3.路由重定向</h2><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 B ，从而展示特定的组件页面<br>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>,<span class="attr">redirect</span>: <span class="string">'/login'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/user'</span>,<span class="attr">component</span>: User &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="4-嵌套路由"><a href="#4-嵌套路由" class="headerlink" title="4.嵌套路由"></a>4.嵌套路由</h2><p>父级路由组件里面再添加 router-link，router-view<br>父级路由的路由规则里添加children属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:<span class="string">'/user'</span>,</span><br><span class="line">component:User,</span><br><span class="line">children:[</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/user/tab1'</span>,<span class="attr">component</span>:Tab1&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h2 id="5-动态路由匹配"><a href="#5-动态路由匹配" class="headerlink" title="5.动态路由匹配"></a>5.动态路由匹配</h2><p>例如有多个路由链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/1'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/2'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/3'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>路由规则可以这样匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>:<span class="string">"/user/:id"</span>,<span class="attr">component</span>: User&#125;</span><br></pre></td></tr></table></figure><p>路由组件里可以这样输出id： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$routes.params.id&#125;&#125;</span><br></pre></td></tr></table></figure><p>使用$routes传递参数，会有耦合性问题，传递参数还有以下方法：</p><ul><li><p>props是bool值：(只能获取id)<br>路由规则：<code>{ path:&quot;/user/:id&quot;,component: User,props:true}</code><br>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'id'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;id&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>props是对象： (无法获取id)<br>路由规则：<code>{ path:&quot;/user/:id&quot;,component: User,props:{uname:&quot;lx&quot;,age:20}}</code><br>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'uname'</span>,<span class="string">'age'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;uname&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>props是函数：(既可以获取id，也可以传递其他参数)<br>路由规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">path:<span class="string">"/user/:id"</span>,</span><br><span class="line">component: User,</span><br><span class="line">props:<span class="function"><span class="params">route</span>=&gt;</span>(&#123;<span class="attr">id</span>:route.params.id,<span class="attr">uname</span>:<span class="string">"lx"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;) <span class="comment">//ES6函数传参写法，route是形参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'id'</span>,<span class="string">'uname'</span>,<span class="string">'age'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;id&#125;&#125;&#123;&#123;uname&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-命名路由"><a href="#6-命名路由" class="headerlink" title="6.命名路由"></a>6.命名路由</h2><p>可以给路由规则起别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">path:<span class="string">'/user/:id'</span>,</span><br><span class="line">name: <span class="string">'user'</span>,</span><br><span class="line">component: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写路由链接时就不用写路径了,改成动态绑定的，使用params传递参数：<br><code>&lt;router-link :to=&quot;{name:&#39;user&#39;,params:{id:123}}&quot;&gt;User&lt;/router-link&gt;</code></p><h2 id="7-编程式导航"><a href="#7-编程式导航" class="headerlink" title="7.编程式导航"></a>7.编程式导航</h2><p>页面导航的两种方式：<br>声明式导航：点击链接跳转<br>编程式导航：使用jsAPI跳转，如location.href</p><p>Vue里的编程式导航：<br>比如在点击事件里写以下代码：<br><code>this.$router.push(&#39;hash地址&#39;)</code><br><code>this.$router.go(n)   n=1前进一个页面 n=-1后退一个页面</code></p><p>push参数传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串（路径名称）</span></span><br><span class="line">router.push(<span class="string">'/home'</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/home'</span> &#125;)</span><br><span class="line"><span class="comment">//传递参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>:<span class="string">'/user'</span>,<span class="attr">params</span>:&#123;<span class="attr">userId</span>:<span class="number">123</span>&#125; &#125;)</span><br><span class="line">router.push(&#123; <span class="attr">name</span>:<span class="string">'user'</span>,<span class="attr">params</span>:&#123;<span class="attr">userId</span>:<span class="number">123</span>&#125; &#125;)</span><br><span class="line"><span class="comment">//带查询参数变成 /register?uname=lisi</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">query</span>:&#123; <span class="attr">uname</span>: <span class="string">'lisi'</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口调用三种用法fetch;axios;async/await</title>
      <link href="/2019/05/21/11.vue/5.%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/21/11.vue/5.%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1、fetch用法"><a href="#1、fetch用法" class="headerlink" title="1、fetch用法"></a>1、fetch用法</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h2><p>fetch是原生JS基于promise实现的数据获取方式，功能更强大、灵活</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>).then(funciton(data)&#123;</span><br><span class="line"><span class="keyword">return</span> data.text(); <span class="comment">//data.text是一个promise实例</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">//这里才是实际的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-fetch传递参数"><a href="#3-fetch传递参数" class="headerlink" title="3.fetch传递参数"></a>3.fetch传递参数</h2><p>method默认是get</p><h3 id="1）GET-DELETE请求："><a href="#1）GET-DELETE请求：" class="headerlink" title="1）GET/DELETE请求："></a>1）GET/DELETE请求：</h3><ul><li><p>传统URL:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url?id=1'</span>,&#123;</span><br><span class="line">method:<span class="string">'get/delete'</span></span><br><span class="line">&#125;).then...          注意后台接收使用/url  req.query.id</span><br></pre></td></tr></table></figure></li><li><p>Restful URL:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url/1'</span>,&#123;</span><br><span class="line">method:<span class="string">'get/delete'</span></span><br><span class="line">&#125;).then...          注意后台接收使用/url/:id  req.params.id</span><br></pre></td></tr></table></figure></li></ul><h3 id="2）POST请求："><a href="#2）POST请求：" class="headerlink" title="2）POST请求："></a>2）POST请求：</h3><p>两种参数传递格式，对应两种方式</p><ul><li><p>方式1 urlencoded：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>,&#123;</span><br><span class="line">method:<span class="string">'post'</span>,</span><br><span class="line">body:<span class="string">'name=lx&amp;age=18'</span>,</span><br><span class="line">headers: &#123;</span><br><span class="line"> <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;).then...          注意后台接收使用bodyParser  req.body.uname</span><br></pre></td></tr></table></figure></li><li><p>方式2 json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;url&apos;,&#123;</span><br><span class="line">method:&apos;post&apos;,</span><br><span class="line">body:JSON.stringify(&#123;</span><br><span class="line">uname:&apos;lx&apos;,</span><br><span class="line">age:18</span><br><span class="line">&#125;),</span><br><span class="line">headers: &#123;</span><br><span class="line"> &apos;Content-Type&apos;:&apos;application/json&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then...          注意后台接收使用bodyParser  req.body.uname</span><br></pre></td></tr></table></figure></li></ul><h3 id="3）PUT请求"><a href="#3）PUT请求" class="headerlink" title="3）PUT请求"></a>3）PUT请求</h3><p>和POST类似，url后面加上要修改的id即可。也支持两种形式的参数</p><h2 id="4-fetch响应结果"><a href="#4-fetch响应结果" class="headerlink" title="4.fetch响应结果"></a>4.fetch响应结果</h2><p>fetch的第一个then里的返回结果不止有data.text()，还有data.json()更常用<br>注意后台返回结果时，使用<code>res.json({uname:&quot;lx&quot;,age:18})</code>，不再是res.send</p><hr><h1 id="二、axios用法"><a href="#二、axios用法" class="headerlink" title="二、axios用法"></a>二、axios用法</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>也是封装了promise实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> axios = &#123;</span><br><span class="line"><span class="keyword">get</span>: function(myurl)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:myurl,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">resolve(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h2><p>引入axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) <span class="comment">//这里的data是固定的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><h3 id="1）GET-DELETE传递参数："><a href="#1）GET-DELETE传递参数：" class="headerlink" title="1）GET/DELETE传递参数："></a>1）GET/DELETE传递参数：</h3><ul><li>根据Url有两种形式，后台也需要相应修改</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url?id=123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)<span class="comment">//后台接收用req.query</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url/123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)<span class="comment">//后台解析用:id，接收用req.params</span></span><br></pre></td></tr></table></figure><ul><li>也可以使用params属性传递get参数，后台使用req.query.id接收，本质也是使用\？拼接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url'</span>,&#123;</span><br><span class="line">params: &#123; <span class="attr">id</span>:<span class="number">123</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2）POST和PUT传递参数："><a href="#2）POST和PUT传递参数：" class="headerlink" title="2）POST和PUT传递参数："></a>2）POST和PUT传递参数：</h3><ul><li>方式1：可以直接写参数对象，不需要加params字段。axios会自动以json格式传递参数<strong>最常用</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'url'</span>,&#123;</span><br><span class="line">name:<span class="string">'lx'</span>,</span><br><span class="line">age:<span class="number">18</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>方式2：使用<code>URLSearchParams()</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'name'</span>,<span class="string">'lx'</span>);</span><br><span class="line">params.append(<span class="string">'age'</span>,<span class="number">18</span>);</span><br><span class="line">axios.post(<span class="string">'url'</span>,params).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>PUT的处理只是URL里面传递了id等参数，其他和POST类似<br>tips：axios有可能会发送一次预请求，类型为OPTIONS</p></blockquote><h2 id="4-响应结果和全局配置"><a href="#4-响应结果和全局配置" class="headerlink" title="4.响应结果和全局配置"></a>4.响应结果和全局配置</h2><ul><li><p>响应结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret.data 实际的数据 </span><br><span class="line">后台如果使用res.json返回，前台可以直接使用，不用再处理</span><br><span class="line">ret.status 响应状态码</span><br></pre></td></tr></table></figure></li><li><p>全局配置：<br>1.配置公共的请求地址 会和调用接口时的url自动拼接<br><code>axios.defaults.baseURL = &#39;https://api.example.com&#39;;</code><br>2.配置 超时时间<br><code>axios.defaults.timeout = 2500;</code><br>3.自定义请求头（跨域的话需要后台相应的配置）<br><code>axios.defaults.headers[&#39;请求头名字&#39;] = &#39;值&#39;;</code> 请求头名字不是随便起的，由后台确定<br>4.配置公共的 post 的 Content-Type<br><code>axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></p></li></ul><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h2><p>在axios发送请求或者得到响应之前一定会执行的代码</p><h3 id="1）请求拦截器"><a href="#1）请求拦截器" class="headerlink" title="1）请求拦截器"></a>1）请求拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//一般在这里设置请求头</span></span><br><span class="line">config.headers.mytoken = <span class="string">'nihao'</span>;</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-响应拦截器"><a href="#2-响应拦截器" class="headerlink" title="2)响应拦截器"></a>2)响应拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//这个res是Promise对象，不是实际的数据res.data</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、async-await用法"><a href="#三、async-await用法" class="headerlink" title="三、async/await用法"></a>三、async/await用法</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><p>ES7引入的新语法，代码风格更简洁(不必写then)，更加方便的进行异步操作<br>async用于函数上，函数返回的是一个promise实例，配合响应拦截器可以让它直接返回数据<br>await用于async函数中</p><p><strong>用同步的思想解决异步问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> ret1 = <span class="keyword">await</span> axios.get(<span class="string">'/axios'</span>)</span><br><span class="line"><span class="keyword">var</span> ret2 = <span class="keyword">await</span> axios.get(<span class="string">'/axios-json'</span>) <span class="comment">//执行顺序是先ret1再ret2,类似同步</span></span><br><span class="line"><span class="built_in">console</span>.log(ret1, ret2); <span class="comment">//这里打印的仍然是Promise对象，但是配合下面的拦截器就是打印数据</span></span><br><span class="line">&#125;</span><br><span class="line">queryData()</span><br></pre></td></tr></table></figure><p>可以配合响应拦截器直接拿数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> data = response.data;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise语法</title>
      <link href="/2019/05/20/11.vue/4.promise%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/20/11.vue/4.promise%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前后端交互模式"><a href="#一、前后端交互模式" class="headerlink" title="一、前后端交互模式"></a>一、前后端交互模式</h1><h2 id="1-接口调用方式"><a href="#1-接口调用方式" class="headerlink" title="1.接口调用方式"></a>1.接口调用方式</h2><p>原生ajax，基于jq的ajax，原生js新方法fetch，第三方封装的axios</p><h2 id="2-URL地址格式"><a href="#2-URL地址格式" class="headerlink" title="2.URL地址格式"></a>2.URL地址格式</h2><ul><li>传统形式：<br>  <code>schema://host:port/path?query#fragment</code></li><li>Restful形式：<br>根据HTTP提交方式区分 get/post/put/delete<br><code>使用</code>/参数<code>传递参数：http://www.shanwliu.fun/books/123</code></li></ul><h1 id="二、promise"><a href="#二、promise" class="headerlink" title="二、promise"></a>二、promise</h1><h2 id="1-为什么要使用promise"><a href="#1-为什么要使用promise" class="headerlink" title="1.为什么要使用promise"></a>1.为什么要使用promise</h2><p>ajax发送请求是异步的，不能确定请求发送的顺序，如果需要按照顺序发送，可以使用多层嵌套ajax解决，但是会形成<code>回调地狱</code><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line"><span class="comment">//promise里面可以写任何代码，一般写ajax</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type:<span class="string">""</span>,</span><br><span class="line">url:<span class="string">""</span>,</span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">resolve(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//resolve() 是成功的回调，reject() 是失败的回调</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//第一个是resolve,第二个是reject</span></span><br><span class="line"><span class="comment">//必须使用then才能拿到结果</span></span><br></pre></td></tr></table></figure><h2 id="3-promise其他方法："><a href="#3-promise其他方法：" class="headerlink" title="3.promise其他方法："></a>3.promise其他方法：</h2><p>实例的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.catch(function()&#123; console.log(&quot;promise发生异常&quot;) &#125;)</span><br><span class="line">p.finally(function()&#123; console.log(&quot;不管结果如何都会执行&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>Promise的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1,p2,p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;) <span class="comment">//集合多个promise对象的返回结果</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;) <span class="comment">//只要拿到一个promise对象的结果就返回</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件化开发</title>
      <link href="/2019/05/19/11.vue/3.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2019/05/19/11.vue/3.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一、组件化开发思想"><a href="#一、组件化开发思想" class="headerlink" title="一、组件化开发思想"></a>一、组件化开发思想</h1><h2 id="1-现实中的组件化思想"><a href="#1-现实中的组件化思想" class="headerlink" title="1.现实中的组件化思想"></a>1.现实中的组件化思想</h2><p>标准、分治、重用、组合</p><h2 id="2-编程中的组件化思想"><a href="#2-编程中的组件化思想" class="headerlink" title="2.编程中的组件化思想"></a>2.编程中的组件化思想</h2><p>组件就是将一段UI样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种整体化的思想就是组件化</p><h2 id="3-组件化规范web-components"><a href="#3-组件化规范web-components" class="headerlink" title="3.组件化规范web components"></a>3.组件化规范web components</h2><p>目的：尽可能多的重用代码<br>通过创建封装好功能的定制元素解决组件化不容易实现的问题<br>vue部分实现了上述规范<br>根组件：new Vue可以看做一个最大的组件 app</p><h1 id="二、组件注册"><a href="#二、组件注册" class="headerlink" title="二、组件注册"></a>二、组件注册</h1><h2 id="1-全局注册"><a href="#1-全局注册" class="headerlink" title="1.全局注册"></a>1.全局注册</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(组件名称, &#123;</span><br><span class="line">data: 组件数据</span><br><span class="line">template: 组件模板内容</span><br><span class="line">methods: &#123;&#125;，</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>1.组件命名方式使用 小写字母+短横线 或者 驼峰式<br>如果使用驼峰式，只能在模板内容里使用驼峰式<br>但是在vue容器里使用，只能用短横线形式 最好只用短横线</li><li>2.组件数据是一个函数 要return一个对象，对象里写数据</li><li>3.组件模板内容是一个字符串，根元素只能有一个<br>支持插值表达式<br>支持ES6模板字符串``增加可读性</li></ul><p>用法： 写在vue容器里，当做普通标签使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">组件名称</span>&gt;</span><span class="tag">&lt;/<span class="name">组件名称</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以重复使用，并且每个组件的数据是独立的</p><h2 id="2-局部组件注册"><a href="#2-局部组件注册" class="headerlink" title="2.局部组件注册"></a>2.局部组件注册</h2><p>写在vue的实例里，只能在注册它的父组件里使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line"><span class="string">'组件名称'</span> ： 组件内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件内容可以在外部用对象的形式定义</p><h1 id="三、组件间数据传递"><a href="#三、组件间数据传递" class="headerlink" title="三、组件间数据传递"></a>三、组件间数据传递</h1><h2 id="1-父子和兄弟组件"><a href="#1-父子和兄弟组件" class="headerlink" title="1.父子和兄弟组件"></a>1.父子和兄弟组件</h2><p>父组件： <code>#app</code><br>子组件： 自己定义的组件<br>兄弟组件：子组件之间互称为兄弟组件<br>可以传递任何类型的值</p><h2 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h2><p>子组件用props接收父组件传递过来的数据，props是一个数组；<br>父组件在标签里用 <code>属性=&#39;属性值&#39;</code> 的形式传递，可以使用v-bind动态绑定<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian1.jpg" alt></p><p>结果：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian2.jpg" alt></p><h2 id="3-子组件向父组件传值："><a href="#3-子组件向父组件传值：" class="headerlink" title="3.子组件向父组件传值："></a>3.子组件向父组件传值：</h2><p>props传递数据是单向数据流，不能实现从子到父传值，使用自定义事件实现<br>父组件在使用子组件时，给标签绑定自定义事件<br>        <code>@自定义事件=&#39;父组件自己的函数&#39;</code><br>子组件 在自己的普通事件里<br>        <code>this.$emit(&#39;父自定义事件名称&#39;,参数)</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian3.jpg" alt></p><h2 id="4-兄弟组件之间传值"><a href="#4-兄弟组件之间传值" class="headerlink" title="4.兄弟组件之间传值"></a>4.兄弟组件之间传值</h2><p>通过事件中心交互<br><code>var hub = new Vue()</code><br>监听事件：<code>$on(&#39;事件名称&#39;，触发函数)</code><br>销毁事件：<code>$off(&#39;事件名称&#39;)</code><br>触发事件：<code>$emit(&#39;事件名称&#39;，可选参数)</code></p><h2 id="5-组件插槽"><a href="#5-组件插槽" class="headerlink" title="5.组件插槽"></a>5.组件插槽</h2><p>在使用组件时，之前标签内没有写值，如果要写内容并传递，需要使用组件插槽<br>1）基本使用<br>slot标签<code>&lt;slot&gt;&lt;/slot&gt;</code>写在子组件的模板中 ；<br>使用组件时在标签之间填写内容</p><p>2）具名插槽<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuechacao1.jpg" alt><br>解析出来是<code>&lt;header&gt;</code>标签和<code>&lt;footer&gt;</code>标签<br>3）作用域插槽<br>父组件对子组件的内容进行加工和处理<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuechacao2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue常用特性</title>
      <link href="/2019/05/18/11.vue/2.vue%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2019/05/18/11.vue/2.vue%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>表单操作、自定义指令、计算属性、侦听器、过滤器、生命周期</p></blockquote><h1 id="一、表单操作"><a href="#一、表单操作" class="headerlink" title="一、表单操作"></a>一、表单操作</h1><h2 id="1-单选框radio"><a href="#1-单选框radio" class="headerlink" title="1.单选框radio"></a>1.单选框radio</h2><p>先给表单元素设置不同的value<br>v-model设置为同一个,如gender<br><code>data: { gender: 1 }</code></p><h2 id="2-复选框checkbox"><a href="#2-复选框checkbox" class="headerlink" title="2.复选框checkbox"></a>2.复选框checkbox</h2><p>先给表单元素设置不同的value<br>v-model设置为同一个,如hobby<br><code>data: { hobby: [1,2,3] }</code></p><h2 id="3-下拉列表select"><a href="#3-下拉列表select" class="headerlink" title="3.下拉列表select"></a>3.下拉列表select</h2><p>分为单选和多选<br>单选： 给select设置<code>v-model</code> ，给 option设置value<br>多选： select元素设置multiple 数据写成数组</p><h2 id="4-表单域修饰符"><a href="#4-表单域修饰符" class="headerlink" title="4.表单域修饰符"></a>4.表单域修饰符</h2><p>使用方法 <code>v-model.修饰符 = &quot;&quot;</code><br>修饰符可以为以下：<br>number 将表单输入转换为数字<br>trim 将表单输入去掉开始和结尾的空格<br>lazy 将input事件切换为change事件(失去焦点才会触发)</p><h1 id="二、自定义指令directive"><a href="#二、自定义指令directive" class="headerlink" title="二、自定义指令directive"></a>二、自定义指令directive</h1><h2 id="1-为什么需要自定义指令"><a href="#1-为什么需要自定义指令" class="headerlink" title="1.为什么需要自定义指令"></a>1.为什么需要自定义指令</h2><p>内置的13个指令不满足需求时，需要自定义指令<br>v-cloak v-if v-show v-else-if v-else v-for v-once v-html v-text v-pre v-model v-bind v-on</p><h2 id="2-语法规则"><a href="#2-语法规则" class="headerlink" title="2.语法规则"></a>2.语法规则</h2><ul><li>不带参数的自定义指令<br>例如自定义一个获取焦点的指令v-focus：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">el.focus(); <span class="comment">//el表示指令绑定的元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>inserted是钩子函数，关于钩子函数：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/custom-directive.html</a><br>常用的钩子函数： inserted,bind只触发一次；update 可以触发多次<br>钩子函数的参数： el,binding,vnode,oldVnode</p><ul><li><p>带参数的自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">"msg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>,&#123;</span><br><span class="line">bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line"><span class="comment">//binding是一个对象 存放了指令相关的信息 如binding.value就是指令等号后面的值msg</span></span><br><span class="line">el.style.backgroundColor = binding.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">data:&#123; <span class="attr">msg</span>:<span class="string">'red'</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>局部指令<br>是vue实例的一个属性，只在当前实例内可以使用<br>用法也是给元素添加v-focus;<br>可以定义多个指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives： &#123;</span><br><span class="line">focus: &#123;</span><br><span class="line">inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、计算属性computed"><a href="#三、计算属性computed" class="headerlink" title="三、计算属性computed"></a>三、计算属性computed</h1><h2 id="1-为何需要计算属性"><a href="#1-为何需要计算属性" class="headerlink" title="1.为何需要计算属性"></a>1.为何需要计算属性</h2><p>插值表达式的计算逻辑可能比较复杂，计算属性可以使模板更加简洁</p><h2 id="2-计算属性的语法"><a href="#2-计算属性的语法" class="headerlink" title="2.计算属性的语法"></a>2.计算属性的语法</h2><p>computed是vue实例的一个属性，调用方法时不加<code>()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   Hello</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;reverseStr&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  olleH</span><br><span class="line"></span><br><span class="line">data:&#123; msg:"Hello" &#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">reverseStr: function()&#123;</span><br><span class="line">return this.msg.split('').reverse().join('');</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-计算属性和方法的区别"><a href="#3-计算属性和方法的区别" class="headerlink" title="3.计算属性和方法的区别"></a>3.计算属性和方法的区别</h2><p>methods方法不存在缓存；只要调用一次就会执行一次<br>插值表达式调用methods里的方法的语法：Add()</p><p>computed计算属性是基于数据依赖进行缓存的，输出多次也只计算一次<br>调用computed内部的方法时不需要加<code>()</code><br>如果计算逻辑比较复杂，可以节省时间<br>一般在算总价，总数时使用</p><h1 id="四、侦听器watch"><a href="#四、侦听器watch" class="headerlink" title="四、侦听器watch"></a>四、侦听器watch</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><p>数据变化时执行异步或开销较大的操作；极少情况下使用<br>侦听属性值的变化</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">要侦听的data属性名: function(val)&#123;</span><br><span class="line">//val是变化后的属性值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、过滤器filter"><a href="#五、过滤器filter" class="headerlink" title="五、过滤器filter"></a>五、过滤器filter</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>格式化数据。比如格式化字符串，格式化日期时间等</p><h2 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'过滤器名称'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//value是要处理的数据</span></span><br><span class="line"><span class="keyword">return</span>  xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; msg | 过滤器名称 &#125;&#125;&lt;/div&gt;    （|： 管道符）</span><br><span class="line">可以级联过滤</span><br><span class="line">&lt;div&gt;&#123;&#123; msg | 过滤器1 | 过滤器2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">可以在绑定属性时添加过滤器</span><br><span class="line">&lt;div v-bind:pp=&quot; msg | 过滤器 &quot;&gt;&lt;/div&gt;</span><br><span class="line">局部过滤器：</span><br><span class="line">和局部指令相似，写在Vue的实例里</span><br><span class="line">过滤器可以传递参数</span><br><span class="line">&lt;div&gt;&#123;&#123; msg | format(1,2,3) &#125;&#125;&lt;/div&gt;  </span><br><span class="line">msg就是value </span><br><span class="line">1,2,3 就是function(value,a,b,c)里的a,b,c</span><br></pre></td></tr></table></figure><h1 id="六、实例的生命周期"><a href="#六、实例的生命周期" class="headerlink" title="六、实例的生命周期"></a>六、实例的生命周期</h1><h2 id="1-实例的不同阶段"><a href="#1-实例的不同阶段" class="headerlink" title="1.实例的不同阶段"></a>1.实例的不同阶段</h2><ul><li>挂载阶段<br>①beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用。<br>②created 在实例创建完成后被立即调用。 一般提前获取数据，在这发ajax<br>③beforeMount 在挂载开始之前被调用。<br>④mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。挂载数据时在这发ajax</li><li>更新阶段<br>⑤beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。<br>⑥updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。</li><li>销毁阶段<br>⑦beforeDestroy 实例销毁之前调用。<br>⑧destroyed 实例销毁后调用。</li></ul><p>方法写在vm的属性里。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">el:<span class="string">"#app"</span>,</span><br><span class="line">data:&#123;...&#125;,</span><br><span class="line">methods:&#123; ... &#125;,</span><br><span class="line">created()&#123;</span><br><span class="line"><span class="comment">//发送ajax请求获取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、vue里的数组API"><a href="#七、vue里的数组API" class="headerlink" title="七、vue里的数组API"></a>七、vue里的数组API</h1><h2 id="1-变异方法-会修改原有数组"><a href="#1-变异方法-会修改原有数组" class="headerlink" title="1.变异方法 会修改原有数组"></a>1.变异方法 会修改原有数组</h2><p><code>push,pop,shift,unshift,splice,sort,reverse</code></p><h2 id="2-替换数组-生成新数组"><a href="#2-替换数组-生成新数组" class="headerlink" title="2.替换数组 生成新数组"></a>2.替换数组 生成新数组</h2><p><code>filter,concat,slice</code></p><h2 id="数组响应式变化"><a href="#数组响应式变化" class="headerlink" title="数组响应式变化"></a>数组响应式变化</h2><p>用索引修改数组，不是响应式的，可以用下面的方式修改<br><code>Vue.set(vm.list,index,&#39;value&#39;)</code><br><code>vm.$set(vm.list,index,&#39;value&#39;)</code><br>第一个参数是要修改的数组，第二个是要修改元素的索引，第三个是想要修改成的值</p><p>对象也有类似的情况。直接给对象添加属性，也不是响应式的；也可以用上面方法处理</p><h1 id="八、图书管理案例："><a href="#八、图书管理案例：" class="headerlink" title="八、图书管理案例："></a>八、图书管理案例：</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuebook.jpg" alt><br>过滤器 时间<br>自定义指令 边框颜色<br>侦听器 判断书名重复<br>生命周期 模拟拿数据<br>计算属性 算总数</p><blockquote><p>附：vue实例的生命周期图<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue实例的生命周期"> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue语法基础</title>
      <link href="/2019/05/16/11.vue/1.vue%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/16/11.vue/1.vue%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>渐进式js框架 <a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/index.html</a><br>渐进式： 声明式渲染-&gt;组件系统-&gt;客户端路由-&gt;集中式状态管理vuex-&gt;项目构建</p></blockquote><h1 id="一、vue概述"><a href="#一、vue概述" class="headerlink" title="一、vue概述"></a>一、vue概述</h1><p>易用：熟悉HTML,CSS,JS就可以快速上手<br>灵活：在一个库和一套框架之间自如伸缩<br>高效：20kb运行大小，超快虚拟DOM<br>数据驱动，一切以数据为中心，较少DOM操作</p><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;1 + 2&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">el: <span class="string">"#app"</span>,</span></span><br><span class="line">data: &#123; </span><br><span class="line"><span class="javascript">msg: <span class="string">"Hello world"</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>插值语法可以进行简单计算，还可以写三元表达式，但不能写if,for</li><li>el是element的缩写，值为DOM元素或者CSS选择器</li><li>data:模型数据，是一个对象</li></ul><h1 id="三、Vue模板语法"><a href="#三、Vue模板语法" class="headerlink" title="三、Vue模板语法"></a>三、Vue模板语法</h1><h2 id="1-模板语法概述"><a href="#1-模板语法概述" class="headerlink" title="1.模板语法概述"></a>1.模板语法概述</h2><h3 id="1）前端渲染："><a href="#1）前端渲染：" class="headerlink" title="1）前端渲染："></a>1）前端渲染：</h3><p><code>模板 + 数据 =&gt; 静态HTML</code></p><h3 id="2）前端渲染方式："><a href="#2）前端渲染方式：" class="headerlink" title="2）前端渲染方式："></a>2）前端渲染方式：</h3><p>原生js拼接字符串：较麻烦，不同程序员代码差异性大<br>模板引擎：提供了规范语法，但没有提供事件处理机制<br>Vue模板语法解决了以上问题<br>vue默认具有数据响应式，数据变化会导致页面内容同步变化<br>数据绑定： 将数据填充到标签中</p><h3 id="3）语法组成概览"><a href="#3）语法组成概览" class="headerlink" title="3）语法组成概览"></a>3）语法组成概览</h3><p>插值表达式<br>指令<br>事件绑定<br>属性绑定<br>样式绑定<br>分支循环结构</p><h2 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h2><p>实质： 以v-开始的自定义属性<br><code>&lt;div v-cloak&gt; Hello World! &lt;/div&gt;</code></p><h3 id="1-v-cloak"><a href="#1-v-cloak" class="headerlink" title="1) v-cloak"></a>1) v-cloak</h3><p>此属性保持在元素上，直到关联实例结束编译<br>给插值表达式所在的标签添加此指令(属性)，然后CSS配合<code>[v-cloak]{display:none}</code><br>可以解决插值表达式闪动的问题</p><h3 id="2-数据填充指令"><a href="#2-数据填充指令" class="headerlink" title="2) 数据填充指令"></a>2) 数据填充指令</h3><p><code>v-text=&quot;msg&quot;</code> 填充纯文本 需要赋值 没有闪动问题<br><code>v-html=&quot;msg&quot;</code> 填充HTML 存在安全问题XSS攻击 第三方数据不可使用<br><code>v-pre</code> 填充原始信息 不进行编译</p><h3 id="3-v-once"><a href="#3-v-once" class="headerlink" title="3) v-once"></a>3) v-once</h3><p>v-once只会编译一次，内容确定之后不会响应式变化</p><h2 id="3-双向数据绑定"><a href="#3-双向数据绑定" class="headerlink" title="3.双向数据绑定"></a>3.双向数据绑定</h2><p>使用的指令：v-model<br>双向数据绑定： 数据和页面内容互相影响，同步变化。主要体现在表单输入域中<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/v1.jpg" alt></p><p><code>页面修改数据--&gt; js里面的msg也会变化;js里的msg修改了--&gt;页面数据也会变化</code></p><blockquote><p>MVVM思想：MVVM定义MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。<br>【模型】指的是后端传递的数据。<br>【视图】指的是所看到的页面。<br>【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：<br>一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。<br>二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。<br>总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。</p></blockquote><h2 id="4-事件绑定"><a href="#4-事件绑定" class="headerlink" title="4. 事件绑定"></a>4. 事件绑定</h2><p>使用的指令：v-on: 简写 @</p><h3 id="1）vue事件绑定方式"><a href="#1）vue事件绑定方式" class="headerlink" title="1）vue事件绑定方式"></a>1）vue事件绑定方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">'事件处理逻辑'</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">简写：<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'事件处理逻辑'</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是事件处理逻辑写在标签内不合适。可以通过函数的形式写在vm的methods里</p><h3 id="2）事件调用方式"><a href="#2）事件调用方式" class="headerlink" title="2）事件调用方式"></a>2）事件调用方式</h3><p>绑定函数名字：<code>&lt;button @click=&#39;add&#39;&gt;点击&lt;/button&gt;</code><br>调用函数：<code>&lt;button @click=&#39;add()&#39;&gt;点击&lt;/button&gt;</code></p><h3 id="3）传递参数"><a href="#3）传递参数" class="headerlink" title="3）传递参数"></a>3）传递参数</h3><p>1.如果是绑定函数名字，默认会传递一个<code>$event</code>作为第一个参数（隐式）<br>2.如果是调用函数，可以手动传递参数<code>$event</code>，只能放在最后（显式）<br>    <code>&lt;button @click=&#39;add(p1,p2,$event)&#39;&gt;点击&lt;/button&gt;</code></p><p><code>此处this指向vm，可以直接拿到data里的数据</code><br><code>methods里的函数不能写箭头函数，有this指向问题</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/v2.jpg" alt></p><h3 id="4）事件修饰符"><a href="#4）事件修饰符" class="headerlink" title="4）事件修饰符"></a>4）事件修饰符</h3><p>阻止事件冒泡： <code>v-on:click.stop=&#39;handle&#39;</code><br>阻止默认行为： <code>v-on:click.prevent=&#39;handle&#39;</code><br>只有本身触发事件才会执行函数： <code>v-on:click.self=&#39;handle&#39;</code><br>可以链式书写，注意有顺序问题<br><code>先prevent后self  v-on:click.prevent.self 会阻止所有的点击事件</code><br><code>先self后prevent  v-on:click.self.prevent 会阻止对元素自身的点击事件</code></p><h3 id="5）按键修饰符"><a href="#5）按键修饰符" class="headerlink" title="5）按键修饰符"></a>5）按键修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tab键： .tab</span><br><span class="line">ESC键： .esc</span><br><span class="line">空格键：.space</span><br><span class="line">方向键：.up .down .left .right</span><br><span class="line">回车键：&lt;input v-on:keyup.enter=&apos;submit&apos;&gt;</span><br><span class="line">delete键：&lt;input v-on:keyup.delete=&apos;handle&apos;&gt;</span><br><span class="line">也可以直接加按键的keycode值</span><br></pre></td></tr></table></figure><h3 id="6）自定义按键修饰符"><a href="#6）自定义按键修饰符" class="headerlink" title="6）自定义按键修饰符"></a>6）自定义按键修饰符</h3><p><code>Vue.config.keyCodes.aaa = 65 //实际上就是给按键起名字</code></p><h2 id="5-属性绑定"><a href="#5-属性绑定" class="headerlink" title="5.属性绑定"></a>5.属性绑定</h2><p>使用的指令 <code>v-bind:</code> 简写 <code>:</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">'url'</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">'url'</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-model双向数据绑定实现原理分析</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span> <span class="attr">v-on:input</span>=<span class="string">"msg=$event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-样式绑定"><a href="#6-样式绑定" class="headerlink" title="6.样式绑定"></a>6.样式绑定</h2><p>使用的指令 <code>v-bind:</code> 简写 <code>:</code></p><h3 id="1）class样式处理："><a href="#1）class样式处理：" class="headerlink" title="1）class样式处理："></a>1）class样式处理：</h3><p>不需要进行样式动态变化时，不用写成这种形式</p><ul><li><p>对象形式：最常用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.active &#123; border: 1px solid #000 &#125;   //css</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //html</span><br><span class="line">data: &#123; isActive : true &#125;   //vue js</span><br></pre></td></tr></table></figure></li><li><p>数组形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.active &#123; border: 1px solid #000 &#125; //css</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //html</span><br><span class="line">data: &#123; activeClass : 'active' &#125;   //vue js</span><br></pre></td></tr></table></figure></li></ul><p>不会覆盖正常写法的类名<br>两种形式可以结合使用，把{}放到[]里<br>简化写法 可以把多个类名定义一个数组存储 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classArr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //html</span><br><span class="line">data: &#123; classArr = ['active','error'] &#125;</span><br></pre></td></tr></table></figure><h3 id="2）style样式处理-行内样式-不常用"><a href="#2）style样式处理-行内样式-不常用" class="headerlink" title="2）style样式处理 (行内样式 不常用)"></a>2）style样式处理 (行内样式 不常用)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">'&#123;border: borderStyle&#125;'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; borderStyle:'1px solid #000' &#125;</span><br></pre></td></tr></table></figure><p>当有多个样式时，可以简化写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">'objStyles'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; objStyles:&#123; border:1px solid #000, width:100px &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以放多个对象<code>&lt;div v-bind:style=&#39;[objStyles,objStyles1]&#39;&gt;&lt;/div&gt;</code></p><h2 id="7-分支循环结构"><a href="#7-分支循环结构" class="headerlink" title="7.分支循环结构"></a>7.分支循环结构</h2><h3 id="1）分支结构"><a href="#1）分支结构" class="headerlink" title="1）分支结构"></a>1）分支结构</h3><p>v-if v-else v-else-if    控制元素是否渲染 不一定在DOM里</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"score&gt;90"</span>&gt;</span> 优秀 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; score: 99 &#125;</span><br></pre></td></tr></table></figure><p>v-show 控制元素是否显示 和display作用相同 已经渲染到DOM</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">'flag'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //此div会隐藏</span><br><span class="line">data:&#123; flag:false &#125;</span><br></pre></td></tr></table></figure><p>v-if和v-show都是看等号后面是true还是false，区别是if会对DOM元素进行增加删除，show只是改变display的值<br>v-show的效率高，不涉及DOM元素的增删操作</p><h3 id="2）循环结构-v-for"><a href="#2）循环结构-v-for" class="headerlink" title="2）循环结构 v-for"></a>2）循环结构 v-for</h3><ul><li>遍历数组 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">'index'</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in arr"</span>&gt;</span>&#123;&#123;item +'---'+ index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">data: &#123;arr：["a","b","c"]&#125;</span><br></pre></td></tr></table></figure></li></ul><p>key:唯一标识 一般是id 方便vue区分元素 提高性能 必须加上</p><ul><li>遍历对象 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">'i'</span> <span class="attr">v-for</span>=<span class="string">"(v,k,i) in obj"</span>&gt;</span>&#123;&#123;v+'---'+k+'---'+i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">data: &#123;obj：&#123;name:"liu",age:18&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>v:值 liu,18<br>k:键 name,age<br>i:索引 0,1</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的安装和使用</title>
      <link href="/2019/05/15/10.git/Git/"/>
      <url>/2019/05/15/10.git/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基础"><a href="#1-Git基础" class="headerlink" title="1. Git基础"></a>1. Git基础</h2><h3 id="1-1-版本管理"><a href="#1-1-版本管理" class="headerlink" title="1.1 版本管理"></a>1.1 版本管理</h3><h4 id="1-1-1-什么是版本管理"><a href="#1-1-1-什么是版本管理" class="headerlink" title="1.1.1 什么是版本管理"></a>1.1.1 什么是版本管理</h4><p>版本管理是一种记录文件变化的方式，以便将来查阅特定版本的文件内容。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/01.png" alt></p><h4 id="1-1-2-人为维护文档版本的问题"><a href="#1-1-2-人为维护文档版本的问题" class="headerlink" title="1.1.2 人为维护文档版本的问题"></a>1.1.2 人为维护文档版本的问题</h4><ol><li><p>文档数量多且命名不清晰导致文档版本混乱</p></li><li><p>每次编辑文档需要复制，不方便</p></li><li><p>多人同时编辑同一个文档，容易产生覆盖</p></li></ol><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/04.png" alt></p><h3 id="1-2-Git-是什么"><a href="#1-2-Git-是什么" class="headerlink" title="1.2 Git 是什么"></a>1.2 Git 是什么</h3><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/19.png" alt></p><h3 id="1-3-Git-安装"><a href="#1-3-Git-安装" class="headerlink" title="1.3 Git 安装"></a>1.3 Git 安装</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a> </p><p>在安装的过程中，所有选项使用默认值即可。</p><h3 id="1-4-Git-基本工作流程"><a href="#1-4-Git-基本工作流程" class="headerlink" title="1.4 Git 基本工作流程"></a>1.4 Git 基本工作流程</h3><table><thead><tr><th>git仓库</th><th>暂存区</th><th>工作目录</th></tr></thead><tbody><tr><td>用于存放提交记录</td><td>临时存放被修改文件</td><td>被Git管理的项目目录</td></tr></tbody></table><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/05.png" alt></p><h3 id="1-5-Git-的使用"><a href="#1-5-Git-的使用" class="headerlink" title="1.5 Git 的使用"></a>1.5 Git 的使用</h3><h4 id="1-5-1-Git-使用前配置"><a href="#1-5-1-Git-使用前配置" class="headerlink" title="1.5.1 Git 使用前配置"></a>1.5.1 Git 使用前配置</h4><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：<code>git config --global user.name 提交人姓名</code></li><li>配置提交人姓名：<code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息：<code>git config --list</code>   </li></ol><p><strong>注意</strong></p><ol><li><p>如果要对配置信息进行修改，重复上述命令即可。</p></li><li><p>配置只需要执行一次。</p></li></ol><h4 id="1-5-2-提交步骤（重要）"><a href="#1-5-2-提交步骤（重要）" class="headerlink" title="1.5.2 提交步骤（重要）"></a>1.5.2 提交步骤（重要）</h4><ol><li><code>git init</code> 初始化git仓库 （只需要一次就行）</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件</li><li><code>git commit -m 提交信息(注释)</code>  向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><h4 id="1-5-2-每次提交必须要做的事"><a href="#1-5-2-每次提交必须要做的事" class="headerlink" title="1.5.2 每次提交必须要做的事"></a>1.5.2 每次提交必须要做的事</h4><ol><li>git add .       添加要提交的文件</li><li>git commit -m ‘登录功能完成’  提交到仓库</li><li>git remote add origin <a href="https://gitee.com/xx/xx.git" target="_blank" rel="noopener">https://gitee.com/xx/xx.git</a>  给仓库取个名字叫 origin</li><li>git push -u origin master   提交到远程仓库</li></ol><h4 id="1-5-3-撤销-了解"><a href="#1-5-3-撤销-了解" class="headerlink" title="1.5.3 撤销(了解)"></a>1.5.3 撤销(了解)</h4><ul><li><p>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code></p></li><li><p>将文件从暂存区中删除： <code>git rm --cached 文件</code></p></li><li><p>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<br><code>git rest --hard commitID(一段乱码)</code> </p></li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/07.png" alt></p><h2 id="2-Git进阶"><a href="#2-Git进阶" class="headerlink" title="2. Git进阶"></a>2. Git进阶</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><p>为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。</p><p>使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/08.png" alt></p><h4 id="2-1-1-分支命令"><a href="#2-1-1-分支命令" class="headerlink" title="2.1.1 分支命令"></a>2.1.1 分支命令</h4><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git checkout -b 分支名称</code> 直接创建并且切换分支</li><li><code>git merge 来源分支</code> 合并分支 在master下执行 合并其他分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><h4 id="2-1-2-分支细分"><a href="#2-1-2-分支细分" class="headerlink" title="2.1.2 分支细分"></a>2.1.2 分支细分</h4><ol><li>主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/06.png" alt></p><ol start="2"><li>开发分支（develop）：作为开发的分支，基于 master 分支创建。</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/09.png" alt></p><ol start="3"><li>功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/10.png" alt></p><p><strong>功能分支 -&gt; 开发分支 -&gt; 主分支</strong></p><h3 id="2-2-暂时保存更改"><a href="#2-2-暂时保存更改" class="headerlink" title="2.2 暂时保存更改"></a>2.2 暂时保存更改</h3><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。</p><p>使用场景：分支临时切换</p><ul><li>存储临时改动：<code>git stash</code></li><li>恢复改动：<code>git stash pop</code></li></ul><h2 id="3-Github（gitee中国）"><a href="#3-Github（gitee中国）" class="headerlink" title="3. Github（gitee中国）"></a>3. Github（gitee中国）</h2><p>在版本控制系统中，大约90%的操作都是在本地仓库中进行的：暂存，提交，查看状态或者历史记录等等。除此之外，如果仅仅只有你一个人在这个项目里工作，你永远没有机会需要设置一个远程仓库。</p><p>只有当你需要和你的开发团队共享数据时，设置一个远程仓库才有意义。你可以把它想象成一个 “文件管理服务器”，利用这个服务器可以与开发团队的其他成员进行数据交换。</p><h3 id="3-1-注册"><a href="#3-1-注册" class="headerlink" title="3.1 注册"></a>3.1 注册</h3><ol><li><p>访问<a href="https://github.com/" target="_blank" rel="noopener">github</a>首页，点击 Sign up 连接。（注册）</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/11.png" alt></p></li><li><p>填写用户名、邮箱地址、GitHub登陆密码</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/12.png" alt></p></li><li><p>选择计划</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/13.png" alt></p></li><li><p>填写 GitHub 问题</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/14.png" alt></p></li><li><p>验证邮箱</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/15.png" alt></p></li><li><p>GitHub 个人中心</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/16.png" alt></p></li></ol><h3 id="3-2-多人协作开发流程"><a href="#3-2-多人协作开发流程" class="headerlink" title="3.2 多人协作开发流程"></a>3.2 多人协作开发流程</h3><ul><li>A在自己的计算机中创建本地仓库</li><li>A在github中创建远程仓库</li><li>A将本地仓库推送到远程仓库</li><li>B克隆远程仓库到本地进行开发</li><li>B将本地仓库中开发的内容推送到远程仓库</li><li>A将远程仓库中的最新内容拉去到本地</li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/20.png" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/21.png" alt></p><h3 id="3-3-创建仓库"><a href="#3-3-创建仓库" class="headerlink" title="3.3 创建仓库"></a>3.3 创建仓库</h3><ol><li><p>填写仓库基本信息</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/17.png" alt></p></li><li><p>将本地仓库推送到远程仓库</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/18.png" alt></p><ol><li><p>git push 远程仓库地址 分支名称</p></li><li><p>git push 远程仓库地址别名 分支名称</p></li><li><p>git push -u 远程仓库地址别名 分支名称</p><p> -u 记住推送地址及分支，下次推送只需要输入git push即可</p></li><li><p>git remote add 远程仓库地址别名 远程仓库地址</p></li></ol></li></ol><h3 id="3-4-拉取操作"><a href="#3-4-拉取操作" class="headerlink" title="3.4 拉取操作"></a>3.4 拉取操作</h3><h4 id="3-4-1-克隆仓库"><a href="#3-4-1-克隆仓库" class="headerlink" title="3.4.1 克隆仓库"></a>3.4.1 克隆仓库</h4><p>克隆远端数据仓库到本地：<code>git clone 仓库地址</code></p><h4 id="3-4-2-拉取远程仓库中最新的版本"><a href="#3-4-2-拉取远程仓库中最新的版本" class="headerlink" title="3.4.2 拉取远程仓库中最新的版本"></a>3.4.2 拉取远程仓库中最新的版本</h4><p>拉取远程仓库中最新的版本：<code>git pull 远程仓库地址 分支名称</code></p><h3 id="3-5-解决冲突"><a href="#3-5-解决冲突" class="headerlink" title="3.5 解决冲突"></a>3.5 解决冲突</h3><p>在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。</p><h3 id="3-6-跨团队协作"><a href="#3-6-跨团队协作" class="headerlink" title="3.6 跨团队协作"></a>3.6 跨团队协作</h3><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h3 id="3-7-ssh免登陆"><a href="#3-7-ssh免登陆" class="headerlink" title="3.7 ssh免登陆"></a>3.7 ssh免登陆</h3><p>码云配置ssh文档：<a href="https://gitee.com/help/articles/4181" target="_blank" rel="noopener">https://gitee.com/help/articles/4181</a><br>配置ssh公钥私钥<br>   https协议仓库地址：<a href="https://github.com/itcast-frontEnd/git-demo.git" target="_blank" rel="noopener">https://github.com/itcast-frontEnd/git-demo.git</a></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/22.png" alt></p><p>生成秘钥：<code>ssh-keygen</code></p><p>秘钥存储目录：C:\Users\用户\.ssh</p><p>公钥名称：id_rsa.pub</p><p>私钥名称：id_rsa</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/23.png" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/24.png" alt></p><h3 id="3-8-GIT忽略清单"><a href="#3-8-GIT忽略清单" class="headerlink" title="3.8 GIT忽略清单"></a>3.8 GIT忽略清单</h3><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>文件名称：<strong>.gitignore</strong></p><p>将工作目录中的文件全部添加到暂存区：<code>git add .</code></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6常用语法</title>
      <link href="/2019/05/13/9.nodeJs/2.ES6%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/13/9.nodeJs/2.ES6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-let和const声明变量"><a href="#1-let和const声明变量" class="headerlink" title="1.let和const声明变量"></a>1.let和const声明变量</h2><p>使用var定义的变量存在 预解析 变量提升 的问题；<br>使用var定义的变量没有块级{}作用域，容易造成变量污染</p><p>用let定义的变量 不会产生变量提升 只能先定义再使用；会产生块级作用域，在{}之外不能访问<br>用const声明的常量 除了具有let的特点外 必须要给初始值 且不能被重新赋值 </p><h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><ul><li><p>从对象中把属性解放出来，当做变量来使用。语法：    <code>let {属性名1, 属性名2} = 对象名</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">name = <span class="string">"liuxiao"</span>,</span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:username,age&#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(username)  <span class="comment">//name可以重命名为username</span></span><br></pre></td></tr></table></figure></li><li><p>数组的解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h2><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形参) =&gt; &#123;函数体&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数实际上是一个匿名函数，没有函数名，没有function关键字<br>箭头函数内部的this永远指向外部的this<br>也可以给箭头函数起名字： let Add = (形参) =&gt; {函数体};</p><p>箭头函数的变体： </p><ul><li>1.如果左侧形参只有一个，左侧的 () 可以省略</li><li>2.如果右侧函数体代码只有一行，右侧的 {} 可以省略，默认会返回执行结果，不能再添加return</li><li>3.如果满足上面两个条件，可以同时省略 () 和 {}</li></ul><h2 id="4-定义对象中的属性和方法的快捷方式"><a href="#4-定义对象中的属性和方法的快捷方式" class="headerlink" title="4.定义对象中的属性和方法的快捷方式"></a>4.定义对象中的属性和方法的快捷方式</h2><p>语法： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"zs"</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;name,age,show,say()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>对象的属性名 和 变量名相同时，不用再写一次变量名，相当于”name”:name 省略成name ; 方法同理<br>对象内定义方法时 <code>say(){}</code> 相当于<code>say: function(){}</code></p><h2 id="5-对象Object的方法"><a href="#5-对象Object的方法" class="headerlink" title="5.对象Object的方法"></a>5.对象Object的方法</h2><ul><li><p>assign合并对象，返回新对象。如果属性名有重复，括号内 后面的会覆盖前面的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj1,obj2...)</span><br></pre></td></tr></table></figure></li><li><p>获取新数组，keys是对象属性的数组，values是对象属性值的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6.数组的方法"></a>6.数组的方法</h2><p><code>let arr = [1,2,3,4];</code></p><ul><li><p>forEach遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>map遍历数组，且返回值是数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//newArr=[2,4,6,8]</span></span><br></pre></td></tr></table></figure></li><li><p>filter遍历数组，且返回值是满足return后面条件的元素组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//newArr=[3,4]</span></span><br></pre></td></tr></table></figure></li><li><p>some遍历数组，且返回值是bool，遇到return true就停止循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = arr.some(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item==<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//bool=true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-扩展运算符"><a href="#7-扩展运算符" class="headerlink" title="7. 扩展运算符"></a>7. 扩展运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr,...arr2] <span class="comment">//[1,2,3,'a','b','c']</span></span><br></pre></td></tr></table></figure><p>对象同样适用</p><h2 id="8-ES6模板字符串"><a href="#8-ES6模板字符串" class="headerlink" title="8.ES6模板字符串"></a>8.ES6模板字符串</h2><p>之前使用JavaScript拼接字符串时，需要使用大量的引号和 + 来拼接才能得到我们需要的模版。<br>ES6中提供了模版字符串，用<code>`</code>（反引号）标识，用${变量}将变量括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`I am $&#123;name&#125;.`</span><br></pre></td></tr></table></figure><p>由于反引号是模版字符串的标识，如果需要在字符串中使用反引号，就要对其进行转义，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`No matter\` what you do,</span><br><span class="line">I trust you.`</span><br></pre></td></tr></table></figure><p>注意：模板字符串中的换行和空格都会原样输出</p><ul><li><p>在${}中的大括号里可以放入任意的JavaScript表达式，还可以进行运算，以及引用对象属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x=88;</span><br><span class="line">var y=100;</span><br><span class="line">console.log(`x=$&#123;++x&#125;,y=$&#123;x+y&#125;`);</span><br></pre></td></tr></table></figure></li><li><p>更强大的是：模版字符串还可以调用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function string()&#123;</span><br><span class="line">return &quot;i likes es6!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(`你想说什么? </span><br><span class="line">嗯，$&#123;string()&#125;`);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExpressCRUD博客项目</title>
      <link href="/2019/05/12/9.nodeJs/8.ExpressCRUD%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/05/12/9.nodeJs/8.ExpressCRUD%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MVC开发思想"><a href="#1-MVC开发思想" class="headerlink" title="1.MVC开发思想"></a>1.MVC开发思想</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/mvc.jpg" alt="MVC架构"></p><h2 id="2-nodejs引入公共模块语法"><a href="#2-nodejs引入公共模块语法" class="headerlink" title="2.nodejs引入公共模块语法"></a>2.nodejs引入公共模块语法</h2><p><code>&lt;%- include(&#39;./layout/header.ejs&#39;)%&gt;</code><br>引入后是html片段</p><h2 id="3-格式化日期模块moment"><a href="#3-格式化日期模块moment" class="headerlink" title="3.格式化日期模块moment"></a>3.格式化日期模块moment</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i moment -S</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="keyword">const</span> time = moment.format(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>);</span><br></pre></td></tr></table></figure><h2 id="4-session模块"><a href="#4-session模块" class="headerlink" title="4.session模块"></a>4.session模块</h2><p>可用于判断登录状态和存储用户信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i express-session -S</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">secret: <span class="string">"加密字段"</span>,</span><br><span class="line">resave: <span class="literal">false</span>,</span><br><span class="line">saveUninitialized: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="5-markdown富文本编辑器Mditor"><a href="#5-markdown富文本编辑器Mditor" class="headerlink" title="5.markdown富文本编辑器Mditor"></a>5.markdown富文本编辑器Mditor</h2><ul><li><p>1.安装npm包：<br><code>npm i mditor -S</code></p></li><li><p>2.引入css和js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/node_modules/mditor/dist/css/mditor.min.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"/node_modules/mditor/dist/js/mditor.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>3.html里添加textarea标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"editor"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>4.初始化编辑器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mditor = Mditor.fromTextarea(<span class="built_in">document</span>.getElementById(<span class="string">"editor"</span>));</span><br><span class="line"><span class="comment">//获取或设置编辑器的默认值，非必须步骤</span></span><br><span class="line">mditor.on(<span class="string">'ready'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(mditor.value);</span><br><span class="line">mditor.value = <span class="string">' ** hello ** '</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-使用隐藏域存放用户Id"><a href="#6-使用隐藏域存放用户Id" class="headerlink" title="6.使用隐藏域存放用户Id"></a>6.使用隐藏域存放用户Id</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在进入文章添加页面的一瞬间，就立即把 文章的 作者Id，保存到 一个隐藏域中，防止 session 失效的问题 --&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;authorId&quot; value=&quot;&lt;%= user.id %&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>存放要发送的属性可以使用以下方法： 存在隐藏域一起发ajax，session，自定义属性，localStorage</p><h2 id="7-把markdown转换为html"><a href="#7-把markdown转换为html" class="headerlink" title="7.把markdown转换为html"></a>7.把markdown转换为html</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i marked -S</span><br><span class="line">cosnt marked = <span class="built_in">require</span>(<span class="string">"marked"</span>)</span><br><span class="line"><span class="keyword">const</span> html = marked(<span class="string">"文本内容"</span>)</span><br></pre></td></tr></table></figure><h2 id="8-ejs模板引擎里输出语句"><a href="#8-ejs模板引擎里输出语句" class="headerlink" title="8.ejs模板引擎里输出语句"></a>8.ejs模板引擎里输出语句</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 识别文本 %&gt;</span><br><span class="line">&lt;%- 识别HTML标签 %&gt;</span><br></pre></td></tr></table></figure><h2 id="9-模板引擎输出的特性"><a href="#9-模板引擎输出的特性" class="headerlink" title="9.模板引擎输出的特性"></a>9.模板引擎输出的特性</h2><p>模板引擎渲染页面时，只要看到输出语句就会输出，无论输出语句的位置在哪，就算在点击事件里，不点击时也会输出</p><h2 id="10-开启执行多条sql语句的功能"><a href="#10-开启执行多条sql语句的功能" class="headerlink" title="10.开启执行多条sql语句的功能"></a>10.开启执行多条sql语句的功能</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="keyword">const</span> conn = mysql.createConnection(&#123;</span><br><span class="line">host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">user: <span class="string">"root"</span>,</span><br><span class="line">password: <span class="string">"root"</span>,</span><br><span class="line">database: <span class="string">"mysql_001"</span>,</span><br><span class="line">multipleStatements: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="11-分页公式"><a href="#11-分页公式" class="headerlink" title="11.分页公式"></a>11.分页公式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$offset = ($currentPage<span class="number">-1</span>)*$pageSize</span><br><span class="line">select * <span class="keyword">from</span> posts limit $offset,$pageSize</span><br></pre></td></tr></table></figure><h2 id="12-加密算法"><a href="#12-加密算法" class="headerlink" title="12.加密算法"></a>12.加密算法</h2><p>md5/sha1/bcryptjs<br>使用bcryptjs</p><ul><li><ol><li>运行 <code>npm i node-pre-gyp -g</code> </li></ol></li><li><ol start="2"><li>在项目根目录中，打开终端，运行 <code>cnpm install bcrypt -S</code></li></ol></li><li><ol start="3"><li>导入 <code>bcrypt</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入加密的模块</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="4"><li>定义幂次：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 幂次</span></span><br><span class="line"><span class="keyword">const</span> saltRounds = <span class="number">10</span>    <span class="comment">// 2^10</span></span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="5"><li>调用 <code>bcrypt.hash()</code> 加密：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密的方法</span></span><br><span class="line">bcrypt.hash(<span class="string">'123'</span>, saltRounds, (err, pwdCryped) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(pwdCryped)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="6"><li>调用<code>bcrypt.compare()</code>对比密码是否正确：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 对比 密码的方法</span></span><br><span class="line">bcrypt.compare(<span class="string">'123'</span>,<span class="string">'$2b$10$i1ufUKnC9fXTsF9oqqvLMeDnpNfYIvhyqKRG03adiebNFPkjW3HPW'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="comment">// 内部对比的过程：</span></span><br><span class="line">     <span class="comment">// 1. 先获取 输入的明文</span></span><br><span class="line">     <span class="comment">// 2. 获取输入的密文</span></span><br><span class="line">     <span class="comment">// 2.1 从密文中，解析出来  bcrypt 算法的 版本号</span></span><br><span class="line">     <span class="comment">// 2.2 从密文中，解析出来 幂次</span></span><br><span class="line">     <span class="comment">// 2.3 从密文中，解析出来前 22 位 这个随机盐</span></span><br><span class="line">     <span class="comment">// 3. compare 方法内部，调用 类似于 hash 方法 把 明文，幂次，随机盐 都传递进去     最终得到正向加密后的密文</span></span><br><span class="line">     <span class="comment">// 4. 根据最新得到的密文，和 compare 提供的密文进行对比，如果相等，则 返回 true ，否则返回 false;</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于node的Express框架</title>
      <link href="/2019/05/04/9.nodeJs/7.Express%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/05/04/9.nodeJs/7.Express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>使用基于nodejs的web开发框架搭建web应用，常用的nodejs框架有Express,koa,egg</p><h1 id="一、express的安装和使用"><a href="#一、express的安装和使用" class="headerlink" title="一、express的安装和使用"></a>一、express的安装和使用</h1><h2 id="1-安装方法"><a href="#1-安装方法" class="headerlink" title="1.安装方法"></a>1.安装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y //初始化npm</span><br><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure><h2 id="2-创建基本Express-web服务器"><a href="#2-创建基本Express-web服务器" class="headerlink" title="2.创建基本Express web服务器"></a>2.创建基本Express web服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//处理get请求</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// res.send('你好，世界'); //express封装的，可以输出中文</span></span><br><span class="line">    res.sendFile(path.join(__dirname, <span class="string">'./views/home.html'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(<span class="string">'./views'</span>));</span><br><span class="line"><span class="comment">//处理post请求</span></span><br><span class="line"><span class="comment">// app.post('/login', (req, res) =&gt; &#123;&#125;)</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sever running at http://localhost:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>地址栏和get里的路径一一对应即可，不一定要加后缀名</p><h2 id="3-express快捷方法"><a href="#3-express快捷方法" class="headerlink" title="3.express快捷方法"></a>3.express快捷方法</h2><h3 id="1-res-send"><a href="#1-res-send" class="headerlink" title="1. res.send()"></a>1. res.send()</h3><ol><li>支持 发送 字符串 Content-Type: text/html;</li><li>支持 发送 对象 或 数组 Content-Type: application/json</li><li>支持 发送 Buffer 此时会当作文件下载</li></ol><h3 id="2-res-sendFile"><a href="#2-res-sendFile" class="headerlink" title="2. res.sendFile()"></a>2. res.sendFile()</h3><p>   用法1：<code>res.sendFile(path.join(__dirname, &#39;./view/index.html&#39;)</code><br>   用法2：<code>res.sendFile(&#39;./view/movie.html&#39;, { root: __dirname })</code><br>   可以用于向浏览器发送静态页面</p><h3 id="3-res-redirect"><a href="#3-res-redirect" class="headerlink" title="3.res.redirect()"></a>3.res.redirect()</h3><p>重定向页面</p><h1 id="二、使用express-static托管静态文件"><a href="#二、使用express-static托管静态文件" class="headerlink" title="二、使用express.static托管静态文件"></a>二、使用express.static托管静态文件</h1><h2 id="1-为什么要托管静态文件："><a href="#1-为什么要托管静态文件：" class="headerlink" title="1.为什么要托管静态文件："></a>1.为什么要托管静态文件：</h2><p>当有很多静态页面时，使用res.sendFile返回页面比较麻烦</p><h2 id="2-托管方法"><a href="#2-托管方法" class="headerlink" title="2.托管方法"></a>2.托管方法</h2><p>app.use() 方法，是专门用来注册中间件；<br>express.static 是express的内置中间件；</p><p>语法1：不加虚拟目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&apos;./views&apos;))</span><br></pre></td></tr></table></figure><p>语法2：加虚拟目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(&apos;/虚拟目录&apos;,express.static(&apos;./views&apos;))</span><br></pre></td></tr></table></figure><p>这样访问的时候要在目录之前加上虚拟目录的名字</p><h1 id="三、express使用ejs模板引擎渲染页面"><a href="#三、express使用ejs模板引擎渲染页面" class="headerlink" title="三、express使用ejs模板引擎渲染页面"></a>三、express使用ejs模板引擎渲染页面</h1><h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h2><ol><li>安装 ejs 模板引擎 npm i ejs -S</li><li>配置模板引擎类型 app.set(‘view engine’, ‘ejs’)</li><li>配置模板文件的存放路径 app.set(‘views’, ‘./ejs_pages’)</li><li>在请求处理函数里，使用 res.render() 来渲染模板页面<br> res.render(‘index.ejs’, { 要渲染的数据对象 })<br> 注意，模板页面的 后缀名，可以省略不写<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>); <span class="comment">//设置模板引擎类型</span></span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./ejs_pages'</span>); <span class="comment">//设置模板文件目录</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(<span class="string">'index.ejs'</span>, &#123;</span><br><span class="line">        name: <span class="string">'liuxiao'</span>,</span><br><span class="line">        age: <span class="number">19</span>,</span><br><span class="line">        hobby: [<span class="string">'吃饭'</span>, <span class="string">'睡觉'</span>, <span class="string">'打豆豆'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/abc'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(<span class="string">'abc.ejs'</span>, &#123;</span><br><span class="line">        food: <span class="string">'^(*￣(oo)￣)^'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server is running at http://localhost:3000/`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>ejs页面里可以直接使用传递过来的数据，语法和art-template的原生语法相同</p><h1 id="四、使用express路由分发请求"><a href="#四、使用express路由分发请求" class="headerlink" title="四、使用express路由分发请求"></a>四、使用express路由分发请求</h1><p>请求地址到处理函数之间的对应关系就称为后端路由</p><h2 id="1-使用路由模块分发请求"><a href="#1-使用路由模块分发请求" class="headerlink" title="1.使用路由模块分发请求"></a>1.使用路由模块分发请求</h2><p>新建一个router.js路由模块，负责创建路由对象并导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 封装单独的 router.js 路由模块文件</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/movie'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/about'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>需要使用路由的文件引入router.js模块并且 app.use(router)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入自己的路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'./router.js'</span>)</span><br><span class="line"><span class="comment">// 使用 app.use() 来注册路由</span></span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure><h1 id="五、express中间件的概念"><a href="#五、express中间件的概念" class="headerlink" title="五、express中间件的概念"></a>五、express中间件的概念</h1><p>之前说到app.use是注册中间件用的，什么是中间件呢？</p><h2 id="1-什么是中间件"><a href="#1-什么是中间件" class="headerlink" title="1.什么是中间件"></a>1.什么是中间件</h2><p>中间件就是一个处理函数，形参包含三个参数： req,res,next<br>req:请求对象，res:响应对象，next:调用下一个中间件</p><ul><li>只要地址栏发送了请求就会执行中间件</li><li>想要继续执行中间件，必须在函数内调用next()方法</li><li>req,res在nodejs不同的中间件里都是同一个对象</li></ul><h2 id="2-express中间件的分类"><a href="#2-express中间件的分类" class="headerlink" title="2.express中间件的分类"></a>2.express中间件的分类</h2><p>1) 应用级别的中间件：挂载到 app 上的中间件<br>    <code>app.get(&#39;url地址&#39;, （req, res, next）=&gt; {})</code><br>2) 路由级别的中间件：挂载到 router 对象上的中间件<br>    <code>router.get(&#39;url地址&#39;, (req, res, next)=&gt;{})</code><br>3) 错误级别的中间件：回调函数中，有四个参数<br>    <code>app.use((err, req, res, next)=&gt;{})</code><br>4) 唯一内置的中间件： <code>express.static()</code>托管静态文件使用<br>5) 第三方中间件：非express框架提供的，需要程序员手动安装才能使用的中间件； –最常用<br>    <code>body-parser</code> 解析post 表单数据</p><blockquote><p>中间件的概念，了解即可，因为实际开发中，我们都直接使用第三方现成的</p></blockquote><h1 id="六、express操作mysql数据库"><a href="#六、express操作mysql数据库" class="headerlink" title="六、express操作mysql数据库"></a>六、express操作mysql数据库</h1><p>使用express对mysql数据进行增删改查</p><h2 id="1-安装数据库模块"><a href="#1-安装数据库模块" class="headerlink" title="1.安装数据库模块"></a>1.安装数据库模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mysql --save</span><br></pre></td></tr></table></figure><h2 id="2-导入mysql模块"><a href="#2-导入mysql模块" class="headerlink" title="2.导入mysql模块"></a>2.导入mysql模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;)</span><br></pre></td></tr></table></figure><h2 id="3-创建连接对象"><a href="#3-创建连接对象" class="headerlink" title="3.创建连接对象"></a>3.创建连接对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const conn  = mysql.createConnection(&#123;</span><br><span class="line">host:&apos;主机名&apos;</span><br><span class="line">user:&apos;用户名&apos;</span><br><span class="line">password:&apos;密码&apos;</span><br><span class="line">database:&apos;数据库名&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-执行Sql语句"><a href="#4-执行Sql语句" class="headerlink" title="4.执行Sql语句"></a>4.执行Sql语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.query(&apos;sql语句&apos;,(err,result)&#123;</span><br><span class="line">console.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>新增语句<br>使用？占位符 + 数据对象实现：只在node的mysql语句支持（但是以前的sql语句也可以使用）<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express1.jpg" alt></p></li><li><p>修改语句<br>如果有多个？占位符；数据对象有多个，要使用数组形式传递<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express2.jpg" alt></p></li></ul><h1 id="七、Express获取参数"><a href="#七、Express获取参数" class="headerlink" title="七、Express获取参数"></a>七、Express获取参数</h1><p>获取地址栏参数：例如 <code>http://127.0.0.1:3000?name=liu&amp;age=18/</code></p><h2 id="1-使用req-query获取参数"><a href="#1-使用req-query获取参数" class="headerlink" title="1.使用req.query获取参数"></a>1.使用req.query获取参数</h2><p>req.query获取查询参数（查询参数：直接在地址栏后面拼接的参数）<br>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express3.jpg" alt><br>获取到查询参数：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express4.jpg" alt></p><h2 id="2-使用req-params获取参数"><a href="#2-使用req-params获取参数" class="headerlink" title="2.使用req.params获取参数"></a>2.使用req.params获取参数</h2><p>req.params获取路径参数<br>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express5.jpg" alt></p><p>获取到参数： 加：表示此处是一个参数<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express6.jpg" alt></p><h2 id="3-从post表单获取提交的数据"><a href="#3-从post表单获取提交的数据" class="headerlink" title="3.从post表单获取提交的数据"></a>3.从post表单获取提交的数据</h2><p>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express7.jpg" alt></p><p>1）需要借助body-parser中间件，先安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i body-parser -S</span><br></pre></td></tr></table></figure><p>2）在处理post请求之前注册中间件：<br>3）在请求处理函数里使用req.body获取post提交的数据：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用node构建web服务器</title>
      <link href="/2019/05/04/9.nodeJs/6.%E4%BD%BF%E7%94%A8node%E6%9E%84%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/05/04/9.nodeJs/6.%E4%BD%BF%E7%94%A8node%E6%9E%84%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建基本的web服务器"><a href="#一、创建基本的web服务器" class="headerlink" title="一、创建基本的web服务器"></a>一、创建基本的web服务器</h1><h2 id="1-引用http模块"><a href="#1-引用http模块" class="headerlink" title="1.引用http模块"></a>1.引用http模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure><h2 id="2-创建服务器"><a href="#2-创建服务器" class="headerlink" title="2.创建服务器"></a>2.创建服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br></pre></td></tr></table></figure><h2 id="3-绑定监听事件"><a href="#3-绑定监听事件" class="headerlink" title="3.绑定监听事件"></a>3.绑定监听事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">//设置编码格式</span></span><br><span class="line">res.writeHeader(<span class="number">200</span>, &#123;</span><br><span class="line"><span class="string">'content-type'</span>: <span class="string">"text/html;charset=utf-8"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//服务器返回结果，结束本次响应</span></span><br><span class="line">res.end(<span class="string">'你好，世界'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>req存储了用户请求时发送的相关参数；<br>  req.url : 客户端访问的url，获取的是端口号之后的，包括/</li><li>res是服务器返回使用的对象；<br>  res.writeHeader里面可以设置浏览器解析结果的格式。mime类型<br>  content type可以为以下值<ul><li>text/html 浏览器把结果当做html解析</li><li>text/css 浏览器把结果当做css解析</li><li>text/plain 浏览器把结果当做普通文本解析<br>res.end()里面要进行相应的修改</li></ul></li></ul><h2 id="4-开启服务器"><a href="#4-开启服务器" class="headerlink" title="4.开启服务器"></a>4.开启服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"server running at http://localhost:3000/"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="二、根据请求URL返回不同页面"><a href="#二、根据请求URL返回不同页面" class="headerlink" title="二、根据请求URL返回不同页面"></a>二、根据请求URL返回不同页面</h1><p>nodejs返回页面必须手动写代码，读取并返回</p><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>req.url可以得到客户端访问的url<br>根据url返回不同的页面<br>可以借助fs.readFile读文件返回页面内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.url === <span class="string">'/'</span> || req.url === <span class="string">'/index.html'</span>) &#123;</span><br><span class="line">fs.readFile(path.join(__dirname, <span class="string">'views/index.html'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以不写utf-8，因为res.end可以接收二进制<br>当接收二进制时，就不需要设置writeHeader了<br>res.end接收两种数据类型： string和二进制类型</p><h2 id="2-服务器处理CSS和js文件"><a href="#2-服务器处理CSS和js文件" class="headerlink" title="2.服务器处理CSS和js文件"></a>2.服务器处理CSS和js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/css/1.css'</span>) &#123;</span><br><span class="line">fs.readFile(path.join(__dirname, <span class="string">'/css/1.css'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/js/1.js'</span>) &#123;</span><br><span class="line">        fs.readFile(path.join(__dirname, <span class="string">'/js/1.js'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-简化改造"><a href="#3-简化改造" class="headerlink" title="3.简化改造"></a>3.简化改造</h2><p>path.join直接和req.url拼接，不再去单独判断。但是这样做客户端访问时必须在相应目录下有文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改造之后访问的地址必须在相应目录下有文件</span></span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/'</span>) req.url = <span class="string">'/views/index.html'</span></span><br><span class="line">    fs.readFile(path.join(__dirname, req.url), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'404'</span> + err.message)</span><br><span class="line">        res.end(buf);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm</title>
      <link href="/2019/05/03/9.nodeJs/5.NPM/"/>
      <url>/2019/05/03/9.nodeJs/5.NPM/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm-的两层含义"><a href="#1-npm-的两层含义" class="headerlink" title="1.npm 的两层含义"></a>1.npm 的两层含义</h2><ol><li>NPM 是一个 第三方模块的托管网站，指的就是<code>https://www.npmjs.com/</code></li><li>NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具</li></ol><h2 id="2-安装和卸载全局包"><a href="#2-安装和卸载全局包" class="headerlink" title="2.安装和卸载全局包"></a>2.安装和卸载全局包</h2><ol><li>什么是全局的包：安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问</li><li>如何安装全局包：运行 <code>npm install 包名 -g</code> 即可；其中 <code>-g</code> 参数，表示 把包安装到全局目录中的意思</li><li>全局包的安装目录：<code>C:\Users\用户目录\AppData\Roaming\npm</code></li><li>什么样的包适合安装到全局：工具性质的包，适合安装到全局</li><li>如何卸载全局包：运行<code>npm uninstall 包名 -g</code>即可<br>例如 i5ting_toc：把markdown转成Html文件的工具</li></ol><h2 id="3-安装和卸载本地包"><a href="#3-安装和卸载本地包" class="headerlink" title="3. 安装和卸载本地包"></a>3. 安装和卸载本地包</h2><ol><li>什么是本地包：跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下；</li><li>注意：如果拿到一个空项目，必须在当前项目根目录中，先运行 <code>npm init</code>或者<code>npm init -y</code> 命令，初始化一个<code>package.json</code>的配置文件，否则包无法安装到本地项目中；</li><li>如何安装本地包：运行<code>npm i 包名 --save</code> 即可安装本地包；<ul><li>如果大家用的是npm 5.x的版本，可以不指定<code>--save</code>命令，如果用的是 npm 3.x 的版本，则需要手动指定 <code>--save</code>；</li></ul></li><li><code>package-lock.json</code>文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验；</li><li>如何卸载本地包：使用 <code>npm uninstall/remove 包名 -S/-D</code>即可卸载指定的本地包；</li></ol><h2 id="4-其它常用命令"><a href="#4-其它常用命令" class="headerlink" title="4. 其它常用命令"></a>4. 其它常用命令</h2><ol><li><code>--save</code> 的缩写是 <code>-S</code> 在dependencies下记录 代码开发和上线都要用</li><li><code>--save-dev</code>的缩写是 <code>-D</code> 在devDependencies下记录 开发阶段用</li><li><code>install</code> 的缩写是 <code>i</code> </li><li>注意：当使用 <code>npm i</code>快速装包的时候，npm会检查<code>package.json</code>文件中，所有的依赖项，然后都为我们安装到项目中</li><li><code>--production</code> 表示只安装 <code>dependencies</code> 节点下记录的包，不安装<code>devDependencies</code>节点下的包；当项目要上线了，才会使用<code>--production</code>命令</li></ol><h2 id="5-解决-npm-下载慢问题"><a href="#5-解决-npm-下载慢问题" class="headerlink" title="5. 解决 npm 下载慢问题"></a>5. 解决 npm 下载慢问题</h2><ol><li>默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以全局安装一个的工具，叫做 <code>cnpm</code></li><li>如何安装<code>cnpm</code>：运行 <code>npm i cnpm -g</code> 即可；</li><li>如何使用<code>cnpm</code>：在装包的时候，只需要把 <code>npm</code> 替换成 <code>cnpm</code> 即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node模块和包介绍</title>
      <link href="/2019/05/03/9.nodeJs/4.node%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/03/9.nodeJs/4.node%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、模块成员的分类"><a href="#一、模块成员的分类" class="headerlink" title="一、模块成员的分类"></a>一、模块成员的分类</h1><h2 id="1-核心模块"><a href="#1-核心模块" class="headerlink" title="1.核心模块"></a>1.核心模块</h2><ol><li><strong>什么是核心模块：</strong><ul><li>随着Node.js的安装包，一同安装到本地的模块，叫做核心模块；</li><li>例如：<code>fs</code>，<code>path</code>等模块，都是由Node.js官方提供的核心模块；</li><li>只要安装了Node这个应用程序，那么就已经安装了所有的 核心模块；</li></ul></li><li><strong>如何使用核心模块</strong>：<ul><li><code>require(&#39;核心模块标识符&#39;)</code></li></ul></li></ol><h2 id="2-第三方模块"><a href="#2-第三方模块" class="headerlink" title="2.第三方模块"></a>2.第三方模块</h2><ol><li><strong>什么是第三方模块：</strong><ul><li>一些非官方提供的模块，叫做第三方模块；</li><li>注意，第三方模块，并不在我们的计算机上；</li><li>如果需要使用某些第三方模块，必须去<code>NPM</code> 的网站上搜索并下载才能使用；</li></ul></li><li><strong>如何使用第三方模块：</strong><ul><li>先从 npm 官网上下载指定的第三方模块</li><li>使用 <code>require(&#39;第三方模块的名称标识符&#39;)</code>来导入这个模块</li><li>根据 第三方模块的 官方文档使用</li></ul></li></ol><h2 id="3-用户自定义模块"><a href="#3-用户自定义模块" class="headerlink" title="3.用户自定义模块"></a>3.用户自定义模块</h2><ol><li><strong>什么是用户模块：</strong><ul><li>程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块；</li></ul></li><li><strong>如何使用用户模块：</strong><ul><li><code>require(&#39;路径标识符&#39;)</code></li></ul></li></ol><h1 id="二、包的定义和使用"><a href="#二、包的定义和使用" class="headerlink" title="二、包的定义和使用"></a>二、包的定义和使用</h1><h2 id="1-什么是包"><a href="#1-什么是包" class="headerlink" title="1.什么是包"></a>1.什么是包</h2><ol><li>英文名叫做 <code>Packages</code>，包是在模块基础上更深一步的抽象；</li><li>包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库；</li><li>包可以看作是 <strong>模块</strong>、<strong>代码</strong> 和 <strong>其它资源</strong> 组合起来形成的 独立作用域；</li></ol><h2 id="2-规范的包结构"><a href="#2-规范的包结构" class="headerlink" title="2.规范的包结构"></a>2.规范的包结构</h2><p>前三个必须遵守</p><ol><li><strong>包都要以一个单独的目录而存在</strong>；</li><li><strong><code>package.json</code> 必须在包的顶层目录下</strong>；</li><li><code>package.json</code> 文件必须符合 JSON 格式，并且必须包含如下三个属性：<ul><li><strong>name</strong>:  包的名字</li><li><strong>version</strong>: 包的版本号</li><li><strong>main</strong>: 表示包的入口文件</li></ul></li><li>二进制文件应该在<strong>bin目录</strong>下;</li><li>javaScript代码应该在<strong>lib目录</strong>下;</li><li>文档应该在<strong>doc目录</strong>下;</li><li>单元测试应该在<strong>test目录</strong>下;</li><li>Node.js对包要求并没有那么严格，只要顶层目录下有<code>package.json</code>，并<strong>符合基本规范</strong>即可;</li></ol><h2 id="3-package-json文件常见内容（了解）"><a href="#3-package-json文件常见内容（了解）" class="headerlink" title="3.package.json文件常见内容（了解）"></a>3.package.json文件常见内容（了解）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name：包的名称，必须是唯一</span><br><span class="line">description：包的简要说明</span><br><span class="line">version：符合语义化版本识别规范的版本字符串</span><br><span class="line">keywords：关键字数据，通常用于搜索</span><br><span class="line">maintainers：维护者数组，每个元素要包含name、email、web可选字段</span><br><span class="line">contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素</span><br><span class="line">bugs：提交bug的地址，可以是网址或者电子邮件地址</span><br><span class="line">licenses：许可证数组，每个元素要包含type和url字段</span><br><span class="line">repositories：仓库托管地址数组，每个元素要包含type、url和path字段</span><br><span class="line">dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</span><br><span class="line">devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项</span><br></pre></td></tr></table></figure><h1 id="三、模块的加载机制"><a href="#三、模块的加载机制" class="headerlink" title="三、模块的加载机制"></a>三、模块的加载机制</h1><h2 id="1-优先从缓存中加载"><a href="#1-优先从缓存中加载" class="headerlink" title="1.优先从缓存中加载"></a>1.优先从缓存中加载</h2><ul><li>当一个模块初次被 <code>require</code> 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块</li><li>好处：提高模块的加载速度；不需要每次都重新执行并加载模块</li></ul><h2 id="2-核心模块的加载机制"><a href="#2-核心模块的加载机制" class="headerlink" title="2.核心模块的加载机制"></a>2.核心模块的加载机制</h2><ul><li>先查找缓存；如果缓存中没有，再去加载核心模块；</li></ul><h2 id="3-用户模块的加载机制"><a href="#3-用户模块的加载机制" class="headerlink" title="3. 用户模块的加载机制"></a>3. 用户模块的加载机制</h2><ul><li>先查找缓存；</li><li>如果缓存中没有则尝试加载用户模块；</li><li>如果在加载用户模块时候省略了后缀名，则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先，严格按照指定的名称去查找</span><br><span class="line">其次，尝试加载后缀名是 .js 的文件</span><br><span class="line">如果没有.js的文件，则尝试加载 .json 结尾的文件</span><br><span class="line">如果没有 .json 的文件，则尝试加载 .node 结尾的文件</span><br><span class="line">查找规则：index  -&gt;  index.js   -&gt;   index.json   -&gt;  index.node</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-第三方模块的加载机制【了解】"><a href="#4-第三方模块的加载机制【了解】" class="headerlink" title="4.第三方模块的加载机制【了解】"></a>4.第三方模块的加载机制【了解】</h2><ol><li>先在项目根目录中查找<code>node_modules</code>文件夹</li><li>在<code>node_modules</code>文件夹下，查找模块相关的文件夹</li><li>在对应的文件夹下，查找<code>package.json</code>的文件</li><li>查找<code>package.json</code>文件中的<code>main</code>属性（指定了模块的入口文件）</li><li>如果找到了<code>main</code>属性，同时，<code>main</code>属性指定的文件路径存在，那么尝试加载指定的文件模块</li><li>假如没有<code>main</code>属性，或者<code>main</code>属性对应的文件不存在，或者没有<code>package.json</code>,那么会依次尝试加载<code>index.js</code>，<code>index.json</code>,<code>index.node</code>;</li><li>如果没有<code>index</code>相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有<code>node_modules</code>文件夹，则向上一层目录中查找<code>node_modules</code>，查找规则同上！</li><li>最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：<code>cannot find module</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化思想介绍</title>
      <link href="/2019/05/03/9.nodeJs/3.%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/03/9.nodeJs/3.%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1.什么是模块化"></a>1.什么是模块化</h1><p>是一种开发思想，一种约定和规范，按照相同的约定写代码，减少沟通成本，方便模块之间的调用</p><h1 id="2-CommonJS规范"><a href="#2-CommonJS规范" class="headerlink" title="2.CommonJS规范"></a>2.CommonJS规范</h1><p>CommonJS规范是一套js的模块化规范，规定了模块的特性和各模块之间如何依赖<br>nodejs遵循CommonJS规范<br>特点：同步加载模块，不适合在浏览器中使用（影响页面加载）<br>之前使用的模块化规范（已过时）<br>        AMD规范：require.js异步  依赖前置，提前执行<br>        CMD规范：sea.js异步  就近加载，用到的时候才去加载<br>三个成员：<br>        require 引入其他模块<br>        exports 导出当前模块<br>        module 导出当前模块</p><h1 id="3-模块作用域和全局作用域"><a href="#3-模块作用域和全局作用域" class="headerlink" title="3.模块作用域和全局作用域"></a>3.模块作用域和全局作用域</h1><ul><li>模块作用域：每个js文件都有一个独立的作用域，外部require引入文件时，不能直接访问内部的私有成员</li><li>global全局作用域： global可以看做浏览器中的window，但有区别；默认JS文件中定义的变量和方法都是属于模块作用域的，不属于global，需要挂载；</li></ul><p>模块之间共享成员：<br>1.把变量和方法挂载到global上，但不推荐使用，会造成global变量污染<br>2.模块1 exports 成员，模块2 require模块1</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/node1.jpg" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/node2.jpg" alt></p><p>exports和module.exports的关系<br>    1.两者引用的是同一个空对象，内存地址相同<br>    2.两者作用一致，都可以向外暴露成员<br>    3.一个模块作用域中，向外暴露成员时，以module.exports为准</p><p>今后在开发中，推荐使用module.exports暴露成员<br>习惯： 导出多个时使用exports，导出一个时使用module.exports</p><h1 id="4-ES6的模块化"><a href="#4-ES6的模块化" class="headerlink" title="4.ES6的模块化"></a>4.ES6的模块化</h1><p>ES6在语言标准层面上，实现了模块化功能，不依赖nodejs，完全可以取代commonjs和AMD，成为浏览器和服务器通用的模块化解决方案<br>ES6的模块化分为导出（export）与导入（import）两个模块。</p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodeJs介绍和文件路径API</title>
      <link href="/2019/05/01/9.nodeJs/1.nodeJS%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84API/"/>
      <url>/2019/05/01/9.nodeJs/1.nodeJS%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-什么是node-js"><a href="#1-什么是node-js" class="headerlink" title="1.什么是node.js"></a>1.什么是node.js</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p><h2 id="2-nodeJs中javascript的组成部分"><a href="#2-nodeJs中javascript的组成部分" class="headerlink" title="2.nodeJs中javascript的组成部分"></a>2.nodeJs中javascript的组成部分</h2><p>ECMAscript核心 + 全局成员 + 核心API模块<br>nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API</p><p>核心API是nodejs安装后自带的<br>想要访问核心API成员，使用require(“核心API名称”)</p><h2 id="3-nodejs可以做什么"><a href="#3-nodejs可以做什么" class="headerlink" title="3.nodejs可以做什么"></a>3.nodejs可以做什么</h2><p>使用JavaScript编写后端API接口或者网站<br>使用nodejs开发一些工具或包<br>基于socket技术开发即时通讯项目<br>基于electron环境开发桌面软件</p><h2 id="4-运行nodeJS的方式"><a href="#4-运行nodeJS的方式" class="headerlink" title="4.运行nodeJS的方式"></a>4.运行nodeJS的方式</h2><p>1）在powershell或者vscode的终端中输入 node xxx.js<br>2）使用repl方式 先输入node，进入repl命令，再输入js代码</p><h2 id="5-path环境变量"><a href="#5-path环境变量" class="headerlink" title="5.path环境变量"></a>5.path环境变量</h2><p>在Windows的高级系统设置里 设置Path环境变量为应用程序的路径 这样就可以在命令行快速启动应用程序</p><h1 id="二、fs文件系统"><a href="#二、fs文件系统" class="headerlink" title="二、fs文件系统"></a>二、fs文件系统</h1><p>fs 模块提供了一个 API，用于与文件系统进行交互。<br><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p><h2 id="1-引入fs模块"><a href="#1-引入fs模块" class="headerlink" title="1.引入fs模块"></a>1.引入fs模块</h2><p><code>const fs = require(&#39;fs&#39;)</code></p><h2 id="2-fs的文件操作"><a href="#2-fs的文件操作" class="headerlink" title="2.fs的文件操作"></a>2.fs的文件操作</h2><p>以下四个方法都是异步进行的，想要改成同步的话在方法名后面添加Sync</p><h3 id="1）读取文件-fs-readFile"><a href="#1）读取文件-fs-readFile" class="headerlink" title="1）读取文件 fs.readFile"></a>1）读取文件 fs.readFile</h3><pre><code>fs.readFile(&apos;读取文件的路径&apos;[,编码格式],回调函数)</code></pre><p>例如： <code>fs.readFile(&#39;1.txt&#39;,&#39;utf-8&#39;,function(err,data){})</code><br>err如果为null说明读取成功；err.message存放了失败时的错误信息<br>编码格式如果不写默认是null，读取出来是buffer16进制</p><h3 id="2-写入文件-fs-writeFile"><a href="#2-写入文件-fs-writeFile" class="headerlink" title="2) 写入文件 fs.writeFile"></a>2) 写入文件 fs.writeFile</h3><pre><code>fs.writeFile(&apos;文件路径&apos;,&apos;要写入的内容&apos;[,编码格式],回调函数)</code></pre><p>例如：<code>fs.writeFile(&#39;1.txt&#39;,&#39;写入的内容&#39;,function(err){})</code><br>文件如果不存在，会新建一个；如果原来有内容会覆盖掉。<br>编码格式默认是utf-8 一般不设置</p><h3 id="3-追加写入文件-fs-appendFile"><a href="#3-追加写入文件-fs-appendFile" class="headerlink" title="3) 追加写入文件 fs.appendFile"></a>3) 追加写入文件 fs.appendFile</h3><pre><code>fs.appendFile(&apos;文件路径&apos;,&apos;要追加的内容&apos;[,编码格式],回调函数)</code></pre><p>例如： <code>fs.appendFile(&#39;1.txt&#39;,&#39;追加的内容&#39;,function(err){})</code><br>文件如果不存在，会新建一个；不会覆盖掉原来的内容。<br>编码格式默认是utf-8 一般不设置</p><h3 id="4-复制文件-fs-copyFile"><a href="#4-复制文件-fs-copyFile" class="headerlink" title="4) 复制文件 fs.copyFile"></a>4) 复制文件 fs.copyFile</h3><pre><code>fs.copyFile(&apos;原文件&apos;,&apos;目标文件&apos;[,flag],回调函数)</code></pre><p>flag一般不指定，是修饰符</p><h3 id="5-删除文件-fs-unlinkFile"><a href="#5-删除文件-fs-unlinkFile" class="headerlink" title="5) 删除文件 fs.unlinkFile"></a>5) 删除文件 fs.unlinkFile</h3><pre><code>fs.unlinkFile(&apos;文件路径&apos;,回调函数)</code></pre><p>文件路径写相对路径时 可能会出现拼接问题<br>推荐使用__dirname：表示当前文件所处的文件夹路径<br>__dirname+”文件”</p><h3 id="6-读取目录下的文件名"><a href="#6-读取目录下的文件名" class="headerlink" title="6)读取目录下的文件名"></a>6)读取目录下的文件名</h3><pre><code>fs.readdir(&apos;文件路径&apos;,(err,filenames)=&gt;{})</code></pre><h1 id="三、Path路径操作"><a href="#三、Path路径操作" class="headerlink" title="三、Path路径操作"></a>三、Path路径操作</h1><p><code>const path = require(&#39;path&#39;)</code></p><h2 id="1-path-join-‘路径片段1’-’路径片段2’…"><a href="#1-path-join-‘路径片段1’-’路径片段2’…" class="headerlink" title="1.path.join(‘路径片段1’,’路径片段2’…)"></a>1.path.join(‘路径片段1’,’路径片段2’…)</h2><p>使用+号拼接需要考虑是否带./和/   容易出错<br>以后拼接路径时使用path.join方法配合__dirname<br>拼接的结果不带.<br>..会和上一级目录抵消掉</p><h2 id="2-path其他属性和方法"><a href="#2-path其他属性和方法" class="headerlink" title="2.path其他属性和方法"></a>2.path其他属性和方法</h2><p>path.sep 返回平台特定的路径分隔符 Windows下是 \  Linux是 /<br>path.basename(paths,[ext]) 返回文件的名称，可以指定扩展名<br>path.dirname(paths) 返回文件的路径，不含文件名<br>path.extname(paths) 返回文件的扩展名</p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客个性化定制</title>
      <link href="/2019/04/16/8.diary/3.Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/"/>
      <url>/2019/04/16/8.diary/3.Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客的个性化修改主要涉及两个文件：<br>1.博客根目录下的config.yml  –博客配置文件<br>2.主题文件夹根目录下的config.yml  –主题配置文件</p></blockquote><h2 id="1-修改博客根目录的Config-yml"><a href="#1-修改博客根目录的Config-yml" class="headerlink" title="1.修改博客根目录的Config.yml"></a>1.修改博客根目录的Config.yml</h2><p>这个配置文件是针对你的博客整站进行配置，如网站标题，作者等，可以适应各个主题。<br>下面列举几个建议修改的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title:#网站标题</span><br><span class="line">subtitle: #网站子标题</span><br><span class="line">description: #网站描述</span><br><span class="line">keywords: #关键词</span><br><span class="line">author: #作者名称</span><br><span class="line">language: #默认语言 常见的有en,zh-CN，zh-Hans等</span><br><span class="line">timezone: #时区 一般无需修改</span><br><span class="line">url: #网站链接 如果有域名可以使用域名，如果没有就是github的默认域名</span><br><span class="line">root: #网站根目录 如果你的网站内容是放在子文件夹，此处应该修改为子文件夹</span><br><span class="line">per_page: #每页显示的文章数量，设置为0可以关闭分页功能</span><br><span class="line">theme: #博客使用的主题，应当和themes文件夹下的主题文件夹名字相同，默认是landscape</span><br><span class="line">deploy: #博客部署相关的信息，在上一篇博文里已经介绍</span><br></pre></td></tr></table></figure><h2 id="2-如何替换默认主题"><a href="#2-如何替换默认主题" class="headerlink" title="2.如何替换默认主题"></a>2.如何替换默认主题</h2><p>默认主题功能比较单一，网上有很多不同风格的hexo主题，官方主题链接：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>每个主题都有自己的github页面，详细介绍了主题如何安装，配置，下面拿NexT主题举例，NexT是一款简洁高效，功能强大的主题，内部集成了丰富的插件，使用响应式设计，可扩展性也很好，被广泛使用。<br>NexT官方文档：<a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></p><ul><li>主题安装方法：<br>在Blog文件夹下，打开Git bash命令行窗口，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li></ul><p>完成后会在Blog/themes文件夹下看到多了一个next文件夹，主题的相关文件就在此文件夹下。</p><ul><li>切换至NexT主题<br>修改<strong>博客配置文件</strong>config.yml的theme字段，改成next即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li></ul><p>修改完成后，启动本地服务器打开localhost:4000，你会发现主题已经换成了NexT的默认样子<br><img src="https://d33wubrfki0l68.cloudfront.net/90fa9a4a64b8ddf623b4b88c59f821f60500655a/6bf8d/images/docs/next-default-scheme-linux.png" alt="NexT默认"><br>至此 你已经完成了主题的安装 搭建博客的两大步已经完成，后面要做的工作主要是在<strong>主题配置文件</strong>下进行的，比如修改样式，添加第三方服务等。</p><h2 id="3-修改NexT主题"><a href="#3-修改NexT主题" class="headerlink" title="3.修改NexT主题"></a>3.修改NexT主题</h2><p>参考本文：<a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39345384/article/details/80785373</a></p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github 博客搭建指南</title>
      <link href="/2019/04/16/8.diary/2.Hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/16/8.diary/2.Hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Git和node-JS"><a href="#1-安装Git和node-JS" class="headerlink" title="1.安装Git和node.JS"></a>1.安装Git和node.JS</h2><p>Git下载地址：<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">https://www.git-scm.com/download/win</a><br>node.JS下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>下载和安装过程不再赘述，可以按照需要更改安装路径，其他选项保持默认即可。<br>检测是否安装完成：<br>安装完成后，在桌面空白处右键，选择Git Bash here，弹出git命令行窗口<br>    输入node -v 回车 应当能看到nodeJs的版本号<br>    输入npm -v 回车 应当能看到npm版本号<br>以上步骤确认无误后，进行下一步</p><h2 id="2-注册GitHub账号，新建代码仓库"><a href="#2-注册GitHub账号，新建代码仓库" class="headerlink" title="2.注册GitHub账号，新建代码仓库"></a>2.注册GitHub账号，新建代码仓库</h2><ul><li>注册账号<br>注册地址：<a href="https://github.com/join?source=login" target="_blank" rel="noopener">https://github.com/join?source=login</a><br>账号注册完成后，点击右上角Sign in登录</li><li>创建代码仓库<br>登录成功，点击头像旁边的加号，选择new repository<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/newResp.jpg" alt="创建代码仓库"><br>在新窗口填写repository name为：<code>你的git账号昵称+.io</code><br>例如：我的git账号是dingx1an，新建的仓库名字就是dingx1an.io<br>其他选项不用修改，点击create repository<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/newrep1.jpg" alt="填写仓库参数"><br>创建完成后，在右上角，头像右侧有一个下拉按钮，点击your repositories<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/yourrep.jpg" alt="选择仓库"><br>可以看到当前账号下的所有仓库，此处只有一个dingx1an.io<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/myrepo.jpg" alt="所有仓库"></li><li>生成SSH key<br>打开git的命令行窗口，输入以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot; 回车</span><br><span class="line">git config --global user.email &quot;youremail&quot; 回车</span><br></pre></td></tr></table></figure></li></ul><p>yourname为你的github用户名，youremail为你的GitHub注册邮箱<br>创建SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>youremail为你的GitHub注册邮箱，输入命令后一路按下Enter键，直到命令窗口提示已经生成了ssh秘钥文件，默认是在 C:\Users\你的用户名\·ssh 文件夹下，文件名称是id_rsa.pub，使用记事本打开后复制全部内容备用</p><ul><li>将SSH key添加到Github<br>在github页面点击头像旁边的下拉按钮，选择settings，在左侧切换到SSH and GPG keys选项卡<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/sshkey.jpg" alt="添加ssh秘钥"><br>点击 New SSH key 输入title(随便)和key值，点击Add SSH key按钮<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/sshkeyadd.jpg" alt="添加ssh秘钥"><br>检查是否添加成功：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><p>如果成功会出现连接成功字样</p><h2 id="3-安装cnpm淘宝源"><a href="#3-安装cnpm淘宝源" class="headerlink" title="3.安装cnpm淘宝源"></a>3.安装cnpm淘宝源</h2><p>在桌面上进入git bash命令行，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>后续安装Npm包时只需要在原命令之前加个<code>c</code>即可<br>ps: 也可以将默认npm源地址切换到淘宝源，输入以下命令<br>临时修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>全局修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>撤销修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h2 id="4-安装Hexo博客组件"><a href="#4-安装Hexo博客组件" class="headerlink" title="4.安装Hexo博客组件"></a>4.安装Hexo博客组件</h2><p>在Git命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>等待一段时间后，命令行里会出现成功提示<br>可以使用<code>hexo -v</code>检查是否安装完成</p><h2 id="5-初始化Hexo和本地预览"><a href="#5-初始化Hexo和本地预览" class="headerlink" title="5.初始化Hexo和本地预览"></a>5.初始化Hexo和本地预览</h2><p>在你想要存放博客的文件夹内Git bash here，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init Blog</span><br></pre></td></tr></table></figure><p>命令执行完成后，会在你的当前文件夹内生成一个名字为Blog的文件夹（文件夹名字可以自定义），之后博客的所有相关文件都存放在Blog文件夹下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Blog //进入博客文件夹</span><br><span class="line">npm install //安装所需的npm包</span><br></pre></td></tr></table></figure><p>执行完成后 可以在本地文件夹下看到以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules: 依赖包</span><br><span class="line">public：存放生成的页面</span><br><span class="line">scaffolds：生成文章的一些模板</span><br><span class="line">source：用来存放你的文章和自定义页面</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml: 博客的配置文件</span><br></pre></td></tr></table></figure><p>在Blog文件夹下 打开git bash命令行 ，输入 <code>hexo g</code> 按下回车生成博客的静态文件，然后输入<code>hexo s</code> 按下回车，启动本地hexo server，之后可以看到<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hexos.jpg" alt="hexo服务器"></p><p>在浏览器中访问localhost:4000，就能看到当前博客的页面，只不过主题是默认的，后续再修改即可<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hexoland.png" alt="hexo默认页面"></p><h2 id="6-将博客部署到Github"><a href="#6-将博客部署到Github" class="headerlink" title="6.将博客部署到Github"></a>6.将博客部署到Github</h2><p>本地预览博客页面没问题后，修改博客文件夹的根目录下config.yml文件，<br>在文件顶部，修改url字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://github.com/dingx1an</span><br><span class="line">root: /dingx1an.io</span><br></pre></td></tr></table></figure><p>在文件最底部，修改repo字段：<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hxconfig.jpg" alt="hexo配置文件"><br>github字段修改成自己的库链接，添加branch字段，其他地方不用修改<br>修改完Config.yml文件后，在Blog文件夹内启动git bash，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -save</span><br></pre></td></tr></table></figure><p>安装hexo上传插件，安装完成后，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>实现博客的部署操作，注意deploy时可能要你输入GitHub的username和password</p><h2 id="7-开启github-pages服务"><a href="#7-开启github-pages服务" class="headerlink" title="7.开启github pages服务"></a>7.开启github pages服务</h2><p>部署成功后，可以在github的个人仓库页面看到本地上传的文件：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitfile.jpg" alt="github pages"><br>接下来需要开启github pages服务，将博客放到网络上：<br>在仓库页面，选择settings<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitpages1.jpg" alt="github pages"><br> 往下拉，直到Github Pages部分，按照下图选择<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitpages2.jpg" alt="github pages"><br>这样就可以使用默认的地址（第一个蓝色框框后面的地址）访问你的博客了</p><blockquote><p>Hexo里常用的命令：<br><code>hexo s</code> 启动本地hexo服务器<br><code>hexo g</code> 生成本地的静态文件<br><code>hexo d</code> 部署本地文件到github<br><code>hexo clean</code> 清理本地静态文件缓存</p></blockquote><p>博客主题修改和自定义配置，在后面的文章里再补充把。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器touchmove事件存在的问题</title>
      <link href="/2019/03/28/0.tips/5.%E6%B5%8F%E8%A7%88%E5%99%A8touchmove%E4%BA%8B%E4%BB%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/28/0.tips/5.%E6%B5%8F%E8%A7%88%E5%99%A8touchmove%E4%BA%8B%E4%BB%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近做项目经常在 chrome 的控制台看到如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unable to preventDefault inside passive event listener due to target being treated as passive. </span><br><span class="line">See https://www.chromestatus.com/features/5093566007214080</span><br></pre></td></tr></table></figure><p>于是 Google 了一番，找到这篇文章，有了详细解释。<a href="https://developers.google.com/web/updates/2017/01/scrolling-intervention" target="_blank" rel="noopener">Making touch scrolling fast by default</a></p><p>简而言之：</p><p>由于浏览器必须要在执行事件处理函数之后，才能知道有没有掉用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。</p><p>所以为了让页面滚动的效果如丝般顺滑，从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, func) 效果和下面一句一样</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, func, &#123; passive: true &#125;)</span><br></pre></td></tr></table></figure><p>这就导致了一个问题：</p><p>如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为。<br>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  height: 2000px;</span><br><span class="line">  background: linear-gradient(to bottom, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 chrome56 中，照样滚动，而且控制台会有提示，blablabla</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, e =&gt; e.preventDefault())</span><br></pre></td></tr></table></figure><p>那么如何解决这个问题呢？不让控制台提示，而且 preventDefault() 有效果呢？<br>两个方案：<br>1、注册处理函数时，用如下方式，明确声明为不是被动的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;touchmove&apos;, func, &#123; passive: false &#125;)</span><br></pre></td></tr></table></figure><p>2、应用 CSS 属性<code>touch-action: none;</code> 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发。<br>touch-action 还有很多选项，详细请参考<a href="https://w3c.github.io/pointerevents/#the-touch-action-css-property" target="_blank" rel="noopener">touch-action</a></p><p>[注]未来可能所有的元素的 touchstart touchmove 事件处理函数都会默认为 passive: true</p><blockquote><p>注：本文转载自<a href="https://segmentfault.com/a/1190000008512184?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008512184?tdsourcetag=s_pcqq_aiomsg</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2019/03/26/0.tips/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/03/26/0.tips/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用Jq插件上传"><a href="#1-使用Jq插件上传" class="headerlink" title="1.使用Jq插件上传"></a>1.使用Jq插件上传</h2><p>使用jQuery-fileupload插件<br>1.引入以下三个文件：</p><ul><li>jquery.ui.widget.js</li><li>jquery.iframe-transport.js</li><li>jquery.fileupload.js</li></ul><p>2.file表单元素设置<br><code>name=&#39;file&#39;</code><br><code>data-url=&quot;后台接口地址&quot;</code></p><p>3.js里对表单控件操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#fileUpload'</span>).fileupload(&#123;</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    done: <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> imgUrl= data._response.result.picAddr;</span><br><span class="line">        $(<span class="string">"#showBrand"</span>).attr(<span class="string">"src"</span>,imgUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-使用ajax上传文件"><a href="#2-使用ajax上传文件" class="headerlink" title="2.使用ajax上传文件"></a>2.使用ajax上传文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#file"</span>).on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>]; <span class="comment">//是一个对象 存储了此图片相关的信息</span></span><br><span class="line">        <span class="keyword">var</span> filedata = <span class="keyword">new</span> FormData(); <span class="comment">//是一个对象 类型为FormData</span></span><br><span class="line">        filedata.append(<span class="string">"file"</span>, file); <span class="comment">//往此对象内部添加图片相关信息</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">"post"</span>,</span><br><span class="line">            url: <span class="string">"/category/addSecondCategoryPic"</span>,</span><br><span class="line">            data: filedata,</span><br><span class="line">            contentType: <span class="literal">false</span>, <span class="comment">//设置之后文件类型变为multipart/form-data</span></span><br><span class="line">            processData: <span class="literal">false</span>, <span class="comment">//不需要进行数据转换 用原格式发送</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                brandLogo = res.picAddr;</span><br><span class="line">                $(<span class="string">".brandimg"</span>).attr(<span class="string">"src"</span>, brandLogo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>contentType 类型：Boolean<br>作用是告诉服务器，浏览器发来了什么数据；一般情况下，我们不需要设置它。默认值为’application/x-www-form-urlencoded; charset=UTF-8’；<br>上传文件时，我们会将content-type设置成flase，这样在发送请求时，请求头里content-Type会变成multipart/form-data</li></ul><ul><li>processData  类型：Boolean<br>默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，设置为 false。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图床从七牛云换到腾讯</title>
      <link href="/2019/03/15/8.diary/1.%E5%9B%BE%E5%BA%8A%E4%BB%8E%E4%B8%83%E7%89%9B%E4%BA%91%E6%9B%BF%E6%8D%A2%E5%88%B0%E8%85%BE%E8%AE%AF/"/>
      <url>/2019/03/15/8.diary/1.%E5%9B%BE%E5%BA%8A%E4%BB%8E%E4%B8%83%E7%89%9B%E4%BA%91%E6%9B%BF%E6%8D%A2%E5%88%B0%E8%85%BE%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天收到邮件通知 七牛云存储空间默认的测试域名到期，被回收了，于是博客里所有外链图片都失效了。<br>百度得知，七牛图床如果没有自定义加速域名，测试域名的有效期只有30天，之后就会被回收。然鹅添加自定义域名需要备案 对小博客来说太麻烦了，所以不得已把图床换成了腾讯云。刚好现在博客是放在Coding上，也相当于在腾讯云里。腾讯云默认有6个月时效的免费空间，就算到期后收费标准也比较低，对于小破站来说完全可以接受。</p></blockquote><p>切换方法简述： </p><ul><li><p>在七牛云上新建存储空间newblog，使用七牛云的qshell工具，把原来的图片全部转移到新空间；因为新空间会有一个默认的测试域名，后面批量下载时会使用到新的测试域名。</p></li><li><p>使用批量下载七牛云图片的工具，把图片下载到本地。上传到腾讯云，博客文章里只需要使用sublime批量替换图片的域名即可，并不是很麻烦。</p></li><li><p>具体参考的博文：<br><a href="https://www.jianshu.com/p/a0c32c22ac3e" target="_blank" rel="noopener">七牛云测试域名失效怎么办</a><br><a href="https://boke112.com/4288.html" target="_blank" rel="noopener">如何批量下载七牛云图片</a><br><a href="https://blog.csdn.net/dataiyangu/article/details/85220829" target="_blank" rel="noopener">腾讯云使用</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端生词本</title>
      <link href="/2019/03/10/0.tips/2.%E5%89%8D%E7%AB%AF%E7%94%9F%E8%AF%8D%E6%9C%AC/"/>
      <url>/2019/03/10/0.tips/2.%E5%89%8D%E7%AB%AF%E7%94%9F%E8%AF%8D%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">name</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">hover</td><td align="center">徘徊，犹豫，鼠标移动到链接上</td></tr><tr><td align="center">indent</td><td align="center">缩进，文本缩进</td></tr><tr><td align="center">italic</td><td align="center">倾斜的 font-style设置字体倾斜</td></tr><tr><td align="center">nav</td><td align="center">导航-navigation的缩写</td></tr><tr><td align="center">solid</td><td align="center">立体的，结实的。在盒子边框属性中意为单实线</td></tr><tr><td align="center">dashed</td><td align="center">虚线，在盒子边框属性中意为虚线</td></tr><tr><td align="center">dotted</td><td align="center">密布的，意为边框使用点线</td></tr><tr><td align="center">collapse</td><td align="center">合并，例如表格边框合并成一条线</td></tr><tr><td align="center">valign</td><td align="center">vertical align的缩写，意为垂直对齐方式。vertical 垂直的。</td></tr><tr><td align="center">even</td><td align="center">偶数</td></tr><tr><td align="center">odd</td><td align="center">奇数</td></tr><tr><td align="center">deg</td><td align="center">degree的缩写，度数</td></tr><tr><td align="center">skew</td><td align="center">斜交 歪斜</td></tr><tr><td align="center">iteration</td><td align="center">反复，重复  iteration-count 播放次数</td></tr><tr><td align="center">alternate</td><td align="center">轮流 交替  在animation-direction里是倒放的意思</td></tr><tr><td align="center">opacity</td><td align="center">不透明度 为1时不透明  为0时透明</td></tr><tr><td align="center">stretch</td><td align="center">拉伸</td></tr><tr><td align="center">background-size</td><td align="center">cover,contain设置背景平铺方式</td></tr><tr><td align="center">background</td><td align="center">-webkit-linear-gradient 背景颜色渐变</td></tr><tr><td align="center">prompt</td><td align="center">浏览器获取输入 取到的是字符型</td></tr><tr><td align="center">parseInt</td><td align="center">转换成整数</td></tr><tr><td align="center">parseFloat</td><td align="center">转换成浮点型</td></tr><tr><td align="center">sibling</td><td align="center">兄弟姐妹</td></tr><tr><td align="center">append</td><td align="center">附加-appendChild添加节点</td></tr><tr><td align="center">propagation</td><td align="center">传播-stopPropagation阻止冒泡</td></tr><tr><td align="center">interval</td><td align="center">间隔-setInterval 设置定时器</td></tr><tr><td align="center">navigator</td><td align="center">领航员-是BOM里的浏览器对象</td></tr><tr><td align="center">explode</td><td align="center">爆炸-php里分割字符串的方法</td></tr><tr><td align="center">decode</td><td align="center">译码-php里json_decode把字符串转为数组的方法</td></tr><tr><td align="center">encode</td><td align="center">编码-php里json_encode把数组转为字符串</td></tr><tr><td align="center">serialize</td><td align="center">序列化-jq里Form表单的序列化方法</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生词本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识补充</title>
      <link href="/2019/03/10/0.tips/1.%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2019/03/10/0.tips/1.%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1-line-height会继承，如果给了ul，li没有设置的话会继承"><a href="#1-line-height会继承，如果给了ul，li没有设置的话会继承" class="headerlink" title="1.line-height会继承，如果给了ul，li没有设置的话会继承"></a>1.line-height会继承，如果给了ul，li没有设置的话会继承</h3><h3 id="2-伪元素不可以使用js控制，因为js无法选中伪元素"><a href="#2-伪元素不可以使用js控制，因为js无法选中伪元素" class="headerlink" title="2.伪元素不可以使用js控制，因为js无法选中伪元素"></a>2.伪元素不可以使用js控制，因为js无法选中伪元素</h3><h3 id="3-最初的伪元素用一个冒号-CSS3中开始使用两个冒号"><a href="#3-最初的伪元素用一个冒号-CSS3中开始使用两个冒号" class="headerlink" title="3.最初的伪元素用一个冒号: CSS3中开始使用两个冒号::"></a>3.最初的伪元素用一个冒号: CSS3中开始使用两个冒号::</h3><p>在 CSS3 中为了区别伪元素和伪类，为伪元素使用了双冒号，即 ::before为伪元素 ； :before    为伪类；<br>伪类有：:first-child ，:link，:visited，:hover，:active,:focus，:lang<br>伪元素有： ::first-line，::first-letter，::before，::after，::selection</p><h3 id="4-flex布局不能实现多个宽高不同的元素-无缝瀑布流布局；"><a href="#4-flex布局不能实现多个宽高不同的元素-无缝瀑布流布局；" class="headerlink" title="4.flex布局不能实现多个宽高不同的元素 无缝瀑布流布局；"></a>4.flex布局不能实现多个宽高不同的元素 无缝瀑布流布局；</h3><h3 id="5-flex可以实现多列布局，每列的高度按照内容最高的一列等高"><a href="#5-flex可以实现多列布局，每列的高度按照内容最高的一列等高" class="headerlink" title="5.flex可以实现多列布局，每列的高度按照内容最高的一列等高"></a>5.flex可以实现多列布局，每列的高度按照内容最高的一列等高</h3><h3 id="6-多列排版是CSS3的新特性"><a href="#6-多列排版是CSS3的新特性" class="headerlink" title="6.多列排版是CSS3的新特性"></a>6.多列排版是CSS3的新特性</h3><h3 id="7-数组元素未给值时是undifined，如arr-，其中每一项是undifined"><a href="#7-数组元素未给值时是undifined，如arr-，其中每一项是undifined" class="headerlink" title="7.数组元素未给值时是undifined，如arr = [ , , ]，其中每一项是undifined"></a>7.数组元素未给值时是undifined，如arr = [ , , ]，其中每一项是undifined</h3><h3 id="8-看以下JavaScript代码，控制台打印的结果是什么？"><a href="#8-看以下JavaScript代码，控制台打印的结果是什么？" class="headerlink" title="8.看以下JavaScript代码，控制台打印的结果是什么？"></a>8.看以下JavaScript代码，控制台打印的结果是什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line">x=<span class="number">10</span>;</span><br><span class="line">y=x++;</span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="9-阻止链接跳转-把链接的-改成javascript"><a href="#9-阻止链接跳转-把链接的-改成javascript" class="headerlink" title="9.阻止链接跳转 把链接的#改成javascript:;"></a>9.阻止链接跳转 把链接的#改成javascript:;</h3><h3 id="10-数组和字符串方法"><a href="#10-数组和字符串方法" class="headerlink" title="10.数组和字符串方法"></a>10.数组和字符串方法</h3><p>数组的方法：<br>数组转换为字符串： <code>arr.toString或者arr.join(&#39;分隔符&#39;)</code><br>数组截取1： <code>arr.slice(startIndex,endIndex)</code> 包含开始 不包含结束，如果只有一个值，往后截取到末尾<br>数组截取2： <code>arr.splice(startIndex,length,replace)</code> 从开始索引截取一定长度，replace是可选参数：替换被截取的元素，改变原数组</p><p>字符串的方法：<br>字符串转换为数组： <code>str.split(&quot;分隔符&quot;)</code> 按照字符串里的分隔符 转换为数组<br>字符串截取1： <code>str.substring(startIndex,endIndex)</code> 包含开始，不包含结束，如果只有一个值，往后截取到末尾<br>字符串截取2： <code>str.substr(startIndex,length)</code> 从某个字符开始截取，截取长度为length，如果只有一个值，截取到末尾</p><h3 id="11-js和jq里insertBefore方法的区别："><a href="#11-js和jq里insertBefore方法的区别：" class="headerlink" title="11.js和jq里insertBefore方法的区别："></a>11.js和jq里insertBefore方法的区别：</h3><p>js里insertBefore是操作DOM节点使用的，语法：<br><code>parentNode.insertBefore(要插入的节点m，某个子节点n)</code>  在子节点n前面插入节点m</p><p>jQuery里 insertBefore是HTML/CSS方法，在被选元素之前插入元素，语法：<br><code>$(要插入的元素m).insertBefore(&#39;选择器&#39;)</code>  在选择器中的元素之前插入元素m  </p><h3 id="12-art-template模板引擎识别HTML标签"><a href="#12-art-template模板引擎识别HTML标签" class="headerlink" title="12.art-template模板引擎识别HTML标签"></a>12.art-template模板引擎识别HTML标签</h3><p>art-template模板引擎识别HTML标签，需要不编码输出，需要在输出语句里加个井号；例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;#value.name&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="13-字符串padStart方法"><a href="#13-字符串padStart方法" class="headerlink" title="13.字符串padStart方法"></a>13.字符串padStart方法</h3><p>填充字符串使用：<br><code>str.padStart(长度，要填充的字符串);</code><br>例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'8'</span>;</span><br><span class="line">str.padStart(<span class="number">2</span>,<span class="string">'0'</span>); <span class="comment">//字符串变为'08'</span></span><br></pre></td></tr></table></figure><h3 id="14-鼠标双击事件"><a href="#14-鼠标双击事件" class="headerlink" title="14.鼠标双击事件"></a>14.鼠标双击事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.box&quot;).on(&apos;dbclick&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="15-数组的findIndex方法"><a href="#15-数组的findIndex方法" class="headerlink" title="15.数组的findIndex方法"></a>15.数组的findIndex方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> index = arr.findIndex(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item == <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">index是<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="16-ES6的class继承"><a href="#16-ES6的class继承" class="headerlink" title="16.ES6的class继承"></a>16.ES6的class继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(name, age, eat) &#123;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">           <span class="keyword">this</span>.age = age;</span><br><span class="line">           <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">"我是animal的eat方法"</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(name, age, foot, sayHi) &#123;</span><br><span class="line">           <span class="keyword">super</span>(name, age);</span><br><span class="line">           <span class="keyword">this</span>.foot = <span class="number">4</span>;</span><br><span class="line">           <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> qkl = <span class="keyword">new</span> cat(<span class="string">'巧克力'</span>, <span class="number">2</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(qkl)<span class="comment">//cat &#123;name: "巧克力", age: 2, eat: ƒ, foot: 4, sayHi: ƒ&#125;</span></span><br><span class="line">   qkl.eat()<span class="comment">//我是animal的eat方法</span></span><br><span class="line">   qkl.sayHi()<span class="comment">//Hi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源和跨域</title>
      <link href="/2018/07/08/7.AJAX/3.%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/07/08/7.AJAX/3.%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、同源"><a href="#一、同源" class="headerlink" title="一、同源"></a>一、同源</h1><p>同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。</p><h1 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h1><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。<br>跨域不能访问cookie和localstorage，不允许进行DOM操作，不能发送ajax请求。<br>允许跨域的标签：img,link,src,href。<br>跨域不是请求没有发出去，而是发出后，服务器返回的数据被浏览器拦截了。</p><h2 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2.跨域解决方案"></a>2.跨域解决方案</h2><ul><li>1) 服务器端跨域 CORS <em>cross origin resource sharing</em><br>在请求的php文件中设置响应头：<br><code>header(&quot;Access-Control-Allow-Origin:*&quot;)</code> 允许所有其他域向当前域发送请求。<br><code>header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;)</code> 允许指定的域向当前域发送请求。<br>不常用，服务器一般不允许这么设置。</li><li>2）JSONP<br>常用的跨域方式</li></ul><h2 id="3-JSONP跨域方案"><a href="#3-JSONP跨域方案" class="headerlink" title="3.JSONP跨域方案"></a>3.JSONP跨域方案</h2><h3 id="1）原理（原生js解释）"><a href="#1）原理（原生js解释）" class="headerlink" title="1）原理（原生js解释）"></a>1）原理（原生js解释）</h3><ul><li>前台修改：<br>其本质是利用了<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code>标签的src具有可跨域的特性，将操作数据的函数test拼接为callback的值。</li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/1eajEg68jYO4.png?imageslim" alt="mark"></p><ul><li>后台处理：<br>服务端返回一个‘预先定义好的Javascript函数的调用’，并且将‘服务器数据’以该‘函数参数’的形式传递过来<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/nsBDCM1kXu0C.png?imageslim" alt="mark"></li></ul><p><strong>只能以GET方式请求</strong></p><h3 id="2）jquery使用JSONP跨域的步骤："><a href="#2）jquery使用JSONP跨域的步骤：" class="headerlink" title="2）jquery使用JSONP跨域的步骤："></a>2）jquery使用JSONP跨域的步骤：</h3><ul><li><p>前台修改：在ajax请求里设置datatype为jsonp，开启跨域请求<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/Ic7JxGnJWcIw.png?imageslim" alt="mark"></p></li><li><p>后台处理：将所需结果返回即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data = file_get_contents(&quot;data.json&quot;);</span><br><span class="line">    echo $data;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>ajax和jsonp的本质不一样，jsonp是通过JavaScript标签发送请求；ajax是通过XMLhttpRequest实现发送请求</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板引擎</title>
      <link href="/2018/07/04/7.AJAX/2.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2018/07/04/7.AJAX/2.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<blockquote>> md文件中如果直接出现{{}}没有被代码块包裹时，会出现解析问题。要使用{%raw%}和{%endraw%}包裹起来。</blockquote><h1 id="一、模板引擎"><a href="#一、模板引擎" class="headerlink" title="一、模板引擎"></a>一、模板引擎</h1><h2 id="1-为什么使用模板引擎"><a href="#1-为什么使用模板引擎" class="headerlink" title="1.为什么使用模板引擎"></a>1.为什么使用模板引擎</h2><p>从json获取数据后，想要生成页面结构，需要拼接字符串，效率低且繁琐；</p><h2 id="2-什么是模板引擎"><a href="#2-什么是模板引擎" class="headerlink" title="2.什么是模板引擎"></a>2.什么是模板引擎</h2><p>为了使用户界面和业务数据分离，用于生成特定的网页结构块。为了动态渲染的时候简化字符串的拼接。</p><h2 id="3-流行模板引擎"><a href="#3-流行模板引擎" class="headerlink" title="3.流行模板引擎"></a>3.流行模板引擎</h2><p><a href="http://tangram.baidu.com/BaiduTemplate/" target="_blank" rel="noopener">BaiduTemplate</a><br><a href="http://aui.github.io/art-template/zh-cn/" target="_blank" rel="noopener">ArtTemplate</a><br><a href="https://github.com/shepherdwind/velocity.js/" target="_blank" rel="noopener">velocity.js</a><br><a href="http://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars</a> <br><br>速度最快，最常用的是<code>artTemplate</code></p><h2 id="4-art-template语法"><a href="#4-art-template语法" class="headerlink" title="4.art-template语法"></a>4.<code>art-template</code>语法</h2><p>分为原生语法和简洁语法，引入不同的js文件</p><ul><li>原生语法： 引入 <code>template-native.js</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式：` &lt;% 表达式 %&gt;` 里面可以写js代码循环或判断</span><br><span class="line">输出表达式： 编码输出：`&lt;%=content%&gt;`  不编码输出： `&lt;%=#content%&gt; `</span><br></pre></td></tr></table></figure><p>（编码可以防止数据中含有 HTML 字符串，避免引起 XSS 攻击）</p><ul><li>简洁语法： 引入<code>template.js</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式：&#123;&#123; 表达式 &#125;&#125;</span><br><span class="line">输出表达式： 编码输出&#123;&#123;content&#125;&#125; 不编码输出&#123;&#123;#content&#125;&#125;</span><br></pre></td></tr></table></figure><p>条件表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> 条件&#125;&#125;</span><br><span class="line">&lt;p&gt;内容<span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;else if value &gt; 0&#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;内容2&lt;/</span>p&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">&lt;p&gt;内容<span class="number">3</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/i</span>f&#125;&#125;</span><br></pre></td></tr></table></figure><p>循环遍历表达式：<br>value相当于传统写法的data[i],index相当于i<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each list <span class="keyword">as</span> value index&#125;&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123;value.user&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/</span>each&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简写为：</span></span><br><span class="line">默认有个$value和$index</span><br><span class="line">&#123;&#123;each list&#125;&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123;$value.user&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/</span>each&#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-art-template模板使用方法："><a href="#5-art-template模板使用方法：" class="headerlink" title="5.art-template模板使用方法："></a>5.<code>art-template</code>模板使用方法：</h2><ul><li><p>创建模板： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">"text/template"</span> id = <span class="string">"temp"</span>&gt; </span><br><span class="line">模板结构，可以写逻辑表达式 </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用模板函数：<code>template(模板id,数据)</code><br>函数返回值是页面结构（html）<br>数据格式只能是对象形式，如果数据是数组，要包装为对象{“items”:arr}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX编程</title>
      <link href="/2018/07/03/7.AJAX/1.ajax%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/03/7.AJAX/1.ajax%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1.Ajax"></a>1.Ajax</h2><p>即 Asynchronous Javascript And XML，AJAX 不是一门的新的语言，而是对现有技术的综合利用。</p><ul><li><ol><li>基于web标签的xhtml+css</li></ol></li><li><ol start="2"><li>可以使用dom进行动态的显示和交互</li></ol></li><li><ol start="3"><li>使用XML和XSLT(是一种用于将XML文档转换任意文本的描述语言)进行数据的交换和操作</li></ol></li><li><ol start="4"><li>使用XMLHttpRequest进行异步的数据查询和检索等操作</li></ol></li></ul><p>本质:   是在HTTP协议的基础上以异步的方式通过XMLHttpRequest对象与服务器进行通信。<br>作用：可以在页面不刷新的情况下，请求服务器，局部更新页面的数据；</p><h2 id="2-异步Asynchronous-ə’sɪŋkrənəs"><a href="#2-异步Asynchronous-ə’sɪŋkrənəs" class="headerlink" title="2.异步Asynchronous [ə’sɪŋkrənəs]"></a>2.异步Asynchronous [ə’sɪŋkrənəs]</h2><p>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。<br>异步可以提升程序的执行效率,增强用户体验</p><h2 id="3-XMLHttpRequest异步对象"><a href="#3-XMLHttpRequest异步对象" class="headerlink" title="3.XMLHttpRequest异步对象"></a>3.XMLHttpRequest异步对象</h2><p>浏览器的内置对象，用于后台与服务器进行交互。可以实现不刷新整个页面，局部更新数据</p><h3 id="1-异步对象发送请求"><a href="#1-异步对象发送请求" class="headerlink" title="1.异步对象发送请求"></a>1.异步对象发送请求</h3><ul><li>1 创建异步对象<pre><code>var xhr = new XMLHttpRequest();</code></pre></li><li>2 设置请求行 open(请求方式，请求url):<pre><code>xhr.open(&quot;get/post&quot;, &quot;url?参数可选&quot;);</code></pre>get请求如果有参数就需要在url？后面拼接参数<br>post如果有参数，就在请求体中传递</li><li>3 设置请求头 <pre><code>setRequestHeader(&apos;key&apos;,&apos;value&apos;)</code></pre>get方式不需要设置请求头<br>post需要设置 <code>xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code></li><li>4 设置请求体:发送请求 <pre><code>send(参数：key=value&amp;key=value)</code></pre>get在这个位置可以传递Null或空内容<pre><code>xhr.send(null)</code></pre>post如果有参数，应该在这个位置来传递参数<pre><code>xhr.send(&quot;name=&quot;+uname)</code></pre></li></ul><p><strong>注GET和POST请求方式的差异（面试题）</strong><br>1、GET没有请求主体，使用xhr.send(null)<br>2、GET可以通过在请求URL上添加请求参数<br>3、POST可以通过<code>xhr.send(&#39;name=itcast&amp;age=10&#39;)</code><br>4、POST需要设置<code>xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code> 如果没设置 参数无法传到服务器<br>5、GET大小限制约4K，POST则没有限制</p><h3 id="2-判断响应是否完成"><a href="#2-判断响应是否完成" class="headerlink" title="2.判断响应是否完成"></a>2.判断响应是否完成</h3><p>复习响应报文：<br>    报文行：响应状态码 响应状态信息 200 ok<br>    报文头：服务器返回给客户端的一些额外信息<br>    报文体：服务器返回给客户端的数据<br>异步对象的相关属性：<br><code>xhr.responseText</code>:服务器返回的普通字符串<br><code>xhr.responseXML</code>：服务器返回的xml格式的字符串，XML格式的字符串只能用此方法接收<br><code>xhr.status</code>:可以获取当前服务器的响应状态 200 》成功<br><code>xhr.readyState</code>: 监听异步对象的响应状态,<br>         readyState=0：已经创建了异步对象，但是还没有调用open方法 –未初始化<br>         readyState=1：说明已经调用了open方法，初始化完成 –载入<br>         readyState=2：send方法执行完毕，请求发送 –载入完成<br>         readyState=3：正在接收响应数据 –交互<br>         readyState=4：响应的内容解析完毕，可以在客户端使用了 –完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 1.服务器成功响应 2.数据已经返回到客户端并且可以使用了</span></span><br><span class="line"><span class="keyword">if</span> (xhr.status == <span class="number">200</span> &amp;&amp; xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line"><span class="comment">// 将返回结果在页面中展示</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".msg"</span>).innerHTML = xhr.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-XML"><a href="#4-XML" class="headerlink" title="4.XML"></a>4.XML</h2><p>XML是一种标记语言，类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190603/mcf1gXYhbf4I.png?imageslim" alt="mark"><br>1、第一句不可更改，必须有一个根元素<br>2、标签名称不可有空格、不可以数字或.开头、大小写敏感<br>3、不可交叉嵌套<br>4、属性双引号（浏览器自动修正成双引号了）<br>5、特殊符号要使用实体<br>6、注释和HTML一样<br>虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。<br>接收XML数据时，接收XML数据时，js使用xhr.responseXML接收，php设置响应头为header(“Content-Type:application/xml;charset=utf-8”)</p><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5.JSON"></a>5.JSON</h2><p>即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。JSON体积小、解析方便且高效，在实际开发成为首选。<br>接收json数据时，php设置响应头为header(“Content-Type:application/json;charset=utf-8”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">属性名<span class="number">1</span>:属性值,</span><br><span class="line">属性名<span class="number">2</span>:属性值</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">属性名<span class="number">3</span>:属性值,</span><br><span class="line">属性名<span class="number">4</span>:属性值</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="1、Javascript-解析json方法"><a href="#1、Javascript-解析json方法" class="headerlink" title="1、Javascript 解析json方法"></a>1、Javascript 解析json方法</h3><pre><code>JSON.parse()     可以将json格式的字符串 转换为js的数组或对象，类似php里的json_decode方法JSON.stringify()；    可以将js的数组或对象转换为json格式的字符串 ，类似php里的json_decode方法</code></pre><h3 id="2、PHP解析json方法"><a href="#2、PHP解析json方法" class="headerlink" title="2、PHP解析json方法"></a>2、PHP解析json方法</h3><pre><code>json_decode() 将字符串转换为数组或对象json_encode() 将数组或对象转换为字符串</code></pre><p>js和html混编：<br>    声明变量html存放生成的html标签，全部生成完后再添加到页面上</p><h2 id="6-封装AJAX工具函数"><a href="#6-封装AJAX工具函数" class="headerlink" title="6.封装AJAX工具函数"></a>6.封装AJAX工具函数</h2><p>将XMLHttpRequest封装成一个函数，提升开发效率</p><p><code>xhr.getResponseHeader(&quot;Content-Type&quot;)</code>可以获取响应头字符串，如<code>application/json;charset=utf-8</code></p><h2 id="7-jquery里的ajax"><a href="#7-jquery里的ajax" class="headerlink" title="7.jquery里的ajax"></a>7.jquery里的ajax</h2><p>jquery提供了$.ajax({})函数，参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- url 接口地址 </span><br><span class="line">- type 请求方式 </span><br><span class="line">- timeout 请求超时时间，单位是毫秒 </span><br><span class="line">- dataType 服务器返回格式，设置想要从服务器返回的数据格式 xml,json,text,html...</span><br><span class="line">- data 请求参数 使用对象形式&#123;&quot;aa&quot;:&quot;bb&quot;&#125;或者使用表单序列化方法</span><br><span class="line">- beforeSend:function()&#123;&#125; 请求发起前调用，可以实现验证操作 </span><br><span class="line">- success:funtion()&#123;&#125; 成功响应后调用 </span><br><span class="line">- error:funtion()&#123;&#125; 错误响应时调用,比如请求超时 </span><br><span class="line">- complete()&#123;&#125; 响应完成时调用（包括成功和失败），比如全局成员的释放，页面状态的重置</span><br></pre></td></tr></table></figure><p>jquery还提供了专门发送get和post类型的ajax请求的函数<br><code>$.get({url,data,success,datatype})  只能发送get请求</code><br><code>$.post({url,data,success,datatype})    只能发送post请求</code></p><p>表单序列化方法：<br><code>$(form表单).serialize();</code><br>是jquery提供的方法，可以将form里所有有name属性的表单收集，生成key=value&amp;key=value的格式的字符串<br>ajax支持处理两种格式的参数：<br>    1.对象形式 {“aa”:”bb”}<br>    2.key=value&amp;key=value格式的字符串</p><p>** 注册案例 **需要创建以下文件<br>    data.json 存储数据<br>    getCode.php 获取验证码<br>    register.php 注册操作<br>    validateUsername.php 验证用户名<br>    register.html 结构和自定js文件<br>    jquery.min.js<br>主要功能点：<br>    用户输入用户名，失去焦点时判断是否重名，给出提示；<br>    用户点击按钮获取验证码，从服务器取到验证码；<br>    用户点击注册按钮，把数据写入服务器json文件</p><p>如果ajax里设置了datatype为json，后台返回数据时要使用json格式：<br><code>echo json_encode(array(&quot;code&quot;=&gt;&quot;1&quot;,&quot;msg&quot;=&gt;&quot;用户名存在&quot;))</code></p><p><code>array_rand(arr)</code>:可以随机生成指定的数组长度内的索引</p><h3 id="附录：使用原生js编写的ajax工具函数"><a href="#附录：使用原生js编写的ajax工具函数" class="headerlink" title="附录：使用原生js编写的ajax工具函数"></a>附录：使用原生js编写的ajax工具函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> $ = &#123;</span><br><span class="line">        <span class="comment">// 将用户传递的 对象形式的参数 转换为字符串</span></span><br><span class="line">        getpa: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">"object"</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="string">"?"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">                    str = str + k + <span class="string">"="</span> + data[k] + <span class="string">"&amp;"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                str = str.substr(<span class="number">0</span>, str.length - <span class="number">1</span>); <span class="comment">//截取掉最后一个&amp; 得到?name=liu&amp;age=10这种格式</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;,</span><br><span class="line">        ajax: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> type = option.type || <span class="string">'get'</span>; <span class="comment">//请求类型</span></span><br><span class="line">            <span class="keyword">var</span> url = option.url || location.href; <span class="comment">//请求url</span></span><br><span class="line">            <span class="comment">//请求参数，option.data格式是&#123;"name":"liu","age":10&#125;，操作后data是?name=liu&amp;age=18</span></span><br><span class="line">            <span class="keyword">var</span> data = <span class="keyword">this</span>.getpa(option.data) || <span class="string">""</span>; <span class="comment">//this指向？</span></span><br><span class="line">            <span class="keyword">var</span> success = option.success; <span class="comment">//响应成功之后的回调函数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">"get"</span>) &#123;</span><br><span class="line">                url += data; <span class="comment">//如果是get 把参数加进url里</span></span><br><span class="line">                data = <span class="literal">null</span>; <span class="comment">//把data置为空，get发送请求体是Null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求行</span></span><br><span class="line">            xhr.open(type, url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求头,get不需要请求头</span></span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">"post"</span>) &#123;</span><br><span class="line">                xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">                <span class="comment">//去掉问号</span></span><br><span class="line">                data = data.substr(<span class="number">1</span>, data.length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求体</span></span><br><span class="line">            xhr.send(data);</span><br><span class="line"></span><br><span class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="comment">// 接收响应的返回值</span></span><br><span class="line">                    <span class="comment">// responseText   responseXML 获取响应头字符串判断是哪种类型</span></span><br><span class="line">                    <span class="keyword">var</span> rh = xhr.getResponseHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">                    <span class="comment">// 判断</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.indexOf(<span class="string">"xml"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> result = xhr.responseXML;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.indexOf(<span class="string">"json"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//字符串里不包括xml和json，按照普通数据接收</span></span><br><span class="line">                        <span class="keyword">var</span> result = xhr.responseText;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 接收数据之后，调用回调函数</span></span><br><span class="line">                    success &amp;&amp; success(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        url: <span class="string">"index.php"</span>,</span><br><span class="line">        data: &#123; <span class="string">"name"</span>: <span class="string">"liu"</span>, <span class="string">"age"</span>: <span class="number">18</span> &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前赤壁赋</title>
      <link href="/2018/06/01/6.%E5%8F%A4%E6%96%87/%E5%89%8D%E8%B5%A4%E5%A3%81%E8%B5%8B/"/>
      <url>/2018/06/01/6.%E5%8F%A4%E6%96%87/%E5%89%8D%E8%B5%A4%E5%A3%81%E8%B5%8B/</url>
      
        <content type="html"><![CDATA[<center>宋 苏轼</center><p>　　壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p><p>　　于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉；余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p><p>　　苏子愀然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞。’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长 江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</p><p>　　苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。“</p><p>　　客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP操作MySql数据库</title>
      <link href="/2018/06/01/5.PHP/7.PHP%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/06/01/5.PHP/7.PHP%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1.连接数据库"></a>1.连接数据库</h2><ul><li>第一步：设置编码格式<br>php文件的编码 <code>header(&quot;Content-Type:text/html;charset=utf-8&quot;)</code><br>服务器返回数据的编码<code>mysqli_set_charset($conn，&quot;utf8&quot;)</code> 默认就是utf-8，可以不设置</li><li>第二步：连接数据库<br><code>$conn = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;mybase&quot;)</code><br>如果连接成功返回连接对象conn，如果连接失败返回false</li></ul><h2 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2.操作数据库"></a>2.操作数据库</h2><p>操作数据是建立在连接数据库成功的前提下，即已经获取到了连接对象conn</p><h3 id="1-增加和删除语句"><a href="#1-增加和删除语句" class="headerlink" title="1.增加和删除语句"></a>1.增加和删除语句</h3><p>1)创建语句: <code>$sql = &quot;sql语句&quot;</code><br>2)执行语句：<code>mysqli_query($conn,$sql)</code><br>例如：<br><code>$sql = &quot;UPDATE mytable set name=&#39;刘啸&#39;,sex=&#39;男&#39;,age=23 where id = 1&quot;</code><br><code>mysqli_query($conn,$sql)</code><br>返回值 如果成功了返回true 失败了返回false<br>最近一条sql语句产生的错误信息存放在mysqli_error($conn)中</p><h3 id="2-查询语句"><a href="#2-查询语句" class="headerlink" title="2.查询语句"></a>2.查询语句</h3><p>1）创建sql查询语句 <code>$sql = &quot;sql语句&quot;</code><br>2）执行语句：<code>$res = mysqli_query($conn,$sql)</code><br>如果查询失败返回false，如果成功，分为两种情况，可以通过mysqli_num_rows($res)判断：</p><ul><li>有结果集但是没数据时<code>mysqli_num_rows($res) = 0</code></li><li>有结果集也有数据时<code>mysqli_num_rows($res) != 0</code></li></ul><p><strong>有数据时返回的结果也不是表里的具体数据，而是数据的引用</strong>。可以使用以下方法提取具体数据，生成数组：</p><ul><li><code>mysqli_fetch_array($res[,type])</code><pre><code>$res 查询语句的执行结果（结果集）type:限制生成的数组类型，取值有    MYSQLI_NUM 只生成索引数组    MYSQLI_ASSOC 只生成关联数组    MYSQLI_BOTH 同时生成两种数组</code></pre></li><li><code>mysqli_fetch_assoc($res)</code> 只生成关联数组</li><li><code>mysqli_fetch_row($res)</code> 只生成索引数组<br>如果没有读取到数据则返回空;<br>上面的函数都只能读取第一行，但是会自动将指针移动到下一行；<br>想要读取所有数据，需要使用while循环：把数据添加到$data里<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>($arr = mysqli_fetch_array($res,MYSQL_NUM))&#123;</span><br><span class="line">$result[]= $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-关闭数据库的连接"><a href="#3-关闭数据库的连接" class="headerlink" title="3.关闭数据库的连接"></a>3.关闭数据库的连接</h2><p>数据库连接数量有上限，当不需要继续连接数据库时，需要断开连接：<br><code>mysqli_close($conn)</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2018/06/01/5.PHP/6.MySQL/"/>
      <url>/2018/06/01/5.PHP/6.MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MySQL操作"><a href="#一、MySQL操作" class="headerlink" title="一、MySQL操作"></a>一、MySQL操作</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>mysql安装过程 参考菜鸟教程上的安装指导：<a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-install.html</a></p><h2 id="2-可视化工具"><a href="#2-可视化工具" class="headerlink" title="2.可视化工具"></a>2.可视化工具</h2><p>使用Navicat for MySQL</p><h1 id="二、SQL语句"><a href="#二、SQL语句" class="headerlink" title="二、SQL语句"></a>二、SQL语句</h1><h2 id="1-查询语句"><a href="#1-查询语句" class="headerlink" title="1.查询语句"></a>1.查询语句</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190601/DFnG3OGccYOr.png?imageslim" alt="mark"><br>查询所有数据：<br>    <code>SELECT * FROM mytable</code><br>查询某一字段的数据：<br>    <code>SELECT name,hobby FROM mytable</code><br>条件查询：<br>    <code>SELECT * FROM mytable WHERE id=3</code><br>    <code>SELECT * FROM mytable WHERE age&lt;=23</code><br>混合条件查询 ：<br>    and=&amp;&amp; not=! or=||<br>    <code>SELECT * FROM mytable WHERE age&lt;=23 and hobby=&quot;玩&quot;</code><br>可以给mytable起别名p：<br>    <code>SELECT p.name FROM mytable p where p.age=23</code><br>子查询 查询中嵌套另一个查询：<br>    <code>SELECT * FROM mytable WHERE age &gt; (SELECT age FROM mytable WHERE name=&quot;刘啸&quot;)</code><br>模糊查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mytable WHERE name LIKE &quot;刘%&quot;</span><br><span class="line">SELECT * FROM mytable WHERE age BETWEEN 23 and 28</span><br><span class="line">SELECT * FROM mytable WHERE id in &#123;1,3,4&#125;</span><br><span class="line">SELECT * FROM mytable WHERE age is NULL  不能用等号判空</span><br></pre></td></tr></table></figure><p>多表查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student,class where student.cid = class.classid</span><br></pre></td></tr></table></figure><p>更多使用<code>SELECT * FROM student JOIN class ON student.cid = class.classid</code><br>JOIN 还分为left join和right join，写在join左边的是左表<br>    left join：获取左表中所有数据 如果建立关联的字段在右表没有 右表的相应字段为空值<br>    right join：获取右表中所有数据 如果建立关联的字段在左表没有 左表的相应字段为空值</p><h2 id="2-增加语句"><a href="#2-增加语句" class="headerlink" title="2.增加语句"></a>2.增加语句</h2><p><code>insert(into) 表名[(字段1，字段2...)] values(值1，值2...)</code><br>[]表示可以不写字段，如果表名后面不写字段，要为每一个字段设置值；<br>如果表里有标识列，如id，增加时可以给null，系统会自动生成递增的标识；也可以不写标识列的字段，给其他字段的值就可以<br>可以为空的字段可以不给值，建议非空字段一定要赋值</p><h2 id="3-修改语句"><a href="#3-修改语句" class="headerlink" title="3.修改语句"></a>3.修改语句</h2><p><code>update 表名 set 字段1=值1，字段2=值2... where 条件</code><br>修改时要加条件 否则会修改字段的所有值</p><h2 id="4-删除语句"><a href="#4-删除语句" class="headerlink" title="4.删除语句"></a>4.删除语句</h2><p><code>delete from 表名 where 条件</code><br>删除和修改操作都是不可逆的</p><p><strong>注意：查询返回的是结果集，增删改返回的是受影响的行数</strong></p><h1 id="三、常见的数学函数"><a href="#三、常见的数学函数" class="headerlink" title="三、常见的数学函数"></a>三、常见的数学函数</h1><h2 id="1-count-计数函数"><a href="#1-count-计数函数" class="headerlink" title="1.count()计数函数"></a>1.count()计数函数</h2><p>括号里可以写：<code>*</code> 计算行数；<br>括号里写字段是计算当前字段的行数<br>null不计入计数</p><h2 id="2-max-和min-求最值的函数"><a href="#2-max-和min-求最值的函数" class="headerlink" title="2.max()和min() 求最值的函数"></a>2.max()和min() 求最值的函数</h2><p>字母比较是按照ASCII码排序</p><h2 id="3-avg-求平均值"><a href="#3-avg-求平均值" class="headerlink" title="3.avg() 求平均值"></a>3.avg() 求平均值</h2><p>括号里一般是数值型</p><h2 id="4-order-by-排序"><a href="#4-order-by-排序" class="headerlink" title="4. order by 排序"></a>4. order by 排序</h2><p><code>select * from 表名 order by id 排序字段;</code><br>排序字段： 默认是 asc 升序； desc 降序</p><h2 id="5-limit-获取指定范围的数据"><a href="#5-limit-获取指定范围的数据" class="headerlink" title="5.limit 获取指定范围的数据"></a>5.limit 获取指定范围的数据</h2><p>limit如果后面只有一个参数 获取指定的前n条记录:<br><code>select * from 表名 limit 5</code><br>如果后面有两个参数 偏移量,获取的记录数:<br><code>select * from 表名 Limit 2,4  从2开始 取4条数据</code><br>也可以使用<code>select * from 表名 limit 4 offset 2</code><br>偏移从0开始</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态保持-Cookie和Session</title>
      <link href="/2018/05/29/5.PHP/5.cookie%E5%92%8Csession/"/>
      <url>/2018/05/29/5.PHP/5.cookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<h1 id="一、HTTP无状态"><a href="#一、HTTP无状态" class="headerlink" title="一、HTTP无状态"></a>一、HTTP无状态</h1><p>http对事务处理没有记忆能力，不会存储之前请求产生的信息，如果当前步骤需要使用之前的信息，需要就进行重传；<br>大部分情况下 需要使用之前的信息 为了解决http无状态造成的问题，有两种HTTP状态保持方法：cookie和session</p><h1 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h1><h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h2><ul><li>客户端发送请求</li><li>服务器将用户当前操作的相关数据存储到Cookie中（键值对形式name=&gt;value），将cookie和响应结果一起返回给客户端，在请求头中使用set-cookie的方式返回</li><li>客户端接收到响应结果，结果中包含cookie</li><li>客户端再次发送请求时，会将之前的cookie一起发送给服务器</li><li>服务器接收到请求，对请求和客户端携带的cookie再次进行处理</li></ul><h2 id="2-php里面实现cookie"><a href="#2-php里面实现cookie" class="headerlink" title="2.php里面实现cookie"></a>2.php里面实现cookie</h2><h3 id="创建cookie："><a href="#创建cookie：" class="headerlink" title="创建cookie："></a>创建cookie：</h3><pre><code>setcookie(name[,value,expire,path,domain]);</code></pre><p>想要设置后面的参数 必须设置前面的参数<br>expire:有效期 单位是s，时间参考点是php默认起始时间(1970-1-1); 可以设置为time()+秒数；<br>　　　设置永久有效期：把expired设置为PHP_INT_MAX<br>path:访问目录权限 参照是网站根目录；设置目录为父级，子目录也能访问（反过来不行）； /代表整站都能访问<br>domain: 访问域名权限 </p><h3 id="获取cookie："><a href="#获取cookie：" class="headerlink" title="获取cookie："></a>获取cookie：</h3><pre><code>$_COOKIE[name]判断客户端是否有cookie： if(isset($_COOKIE[name])){ ，，， }</code></pre><h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie:"></a>删除cookie:</h3><pre><code>怎么创建就怎么删除，参数个数要对应1.有效期设置为过去时间2.将value设置为空字符串或false3.不设置value</code></pre><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><p>cookie数据不太安全；<br>cookie只能存储字符串值；<br>cookie存储文件容量大小有限制4kb</p><p>案例： 登录功能</p><h1 id="三、Session"><a href="#三、Session" class="headerlink" title="三、Session"></a>三、Session</h1><h2 id="1-session的原理"><a href="#1-session的原理" class="headerlink" title="1.session的原理"></a>1.session的原理</h2><p>1）客户端发送请求<br>2）服务器处理：开启一个session，同时生成一个用于存储数据的文件，为这个文件生成一个id号。将处理结果和id号返回给客户端<br>3）客户端获取处理结果和sessionId<br>4）客户端再次发送请求时，会把之前的sessionId传递给服务器<br>5）服务器根据sessionId找到相应的文件，根据文件对新请求进行处理</p><h2 id="2-php实现session"><a href="#2-php实现session" class="headerlink" title="2.php实现session"></a>2.php实现session</h2><p>php默认不会开启session功能，如果想要使用。需要添加代码session_start();</p><blockquote><p>想要默认开启，通过修改配置文件php.ini下的session.auto_start为1实现。注意：修改后，打开网页就会产生sessionId，不建议修改</p></blockquote><p>session_start的执行过程：<br>    动态生成一个sessionID；<br>    在服务器生成一个存放数据的文件，文件名以sess_sessionId构成；<br>    通过响应头设置cookie，存放了本次产生的sessionID，在将来返回</p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><pre><code>session_start();$_SESSION[&apos;name&apos;] = 值; 可以是各种数据类型</code></pre><h3 id="读取session"><a href="#读取session" class="headerlink" title="读取session"></a>读取session</h3><pre><code>session_start();$user = $_SESSION[&apos;user&apos;];</code></pre><h3 id="删除一个session信息"><a href="#删除一个session信息" class="headerlink" title="删除一个session信息"></a>删除一个session信息</h3><blockquote><p>tips: 删除session是在服务端进行的，通过浏览器查看sessionID会发现还存在，因为浏览器存储的是本地缓存，只有重新打开浏览器才能看到删除效果</p></blockquote><pre><code>session_start();unset($_SESSION[&apos;user&apos;]);</code></pre><h3 id="删除所有session信息"><a href="#删除所有session信息" class="headerlink" title="删除所有session信息"></a>删除所有session信息</h3><pre><code>session_start();方式1：unset($_SESSION);方式2：$_SESSION = []</code></pre><h3 id="销毁session"><a href="#销毁session" class="headerlink" title="销毁session"></a>销毁session</h3><pre><code>session_destroy(); 会销毁整个文件</code></pre><h2 id="3-session的优点"><a href="#3-session的优点" class="headerlink" title="3.session的优点"></a>3.session的优点</h2><p>Session数据存储在服务器端，相比cookie更加安全<br>可以存储除了资源以外的数据类型<br>存储容量大小没有限制，服务器放得下就行</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2018/05/29/5.PHP/4.HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/05/29/5.PHP/4.HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><h2 id="1-http的定义"><a href="#1-http的定义" class="headerlink" title="1.http的定义"></a>1.http的定义</h2><p>超文本传输协议  端与端之间的通讯协议</p><h2 id="2-建立连接-三次握手"><a href="#2-建立连接-三次握手" class="headerlink" title="2.建立连接-三次握手"></a>2.建立连接-三次握手</h2><ol><li>客户端向服务器发送一个连接请求</li><li>服务器向客户端返回一个确认信息</li><li>客户端将请求及这个确认信息发送服务器</li></ol><h2 id="3-关闭连接-四次挥手："><a href="#3-关闭连接-四次挥手：" class="headerlink" title="3.关闭连接-四次挥手："></a>3.关闭连接-四次挥手：</h2><pre><code>tcp标志位有6种标示:    SYN(synchronous建立联机)    ACK(acknowledgement 确认)    PSH(push传送)    FIN(finish结束)    RST(reset重置)    URG(urgent紧急) </code></pre><p>1.Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>2.Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>3.Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>4.Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。      </p><h2 id="4-约定内容："><a href="#4-约定内容：" class="headerlink" title="4.约定内容："></a>4.约定内容：</h2><pre><code>- 请求 / 响应报文格式- 请求方式 —— GET / POST / etc.- 响应状态 —— 200 / 404 / 302 / 304 / etc.- 预设的请求 / 响应头</code></pre><h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><h2 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/W0Ue8N51Qdsm.png?imageslim" alt="mark"><br>        请求行：GET /demo.php HTTP/1.1 即 请求方式 +请求路径 +HTTP 协议版本<br>        请求头：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/bWr2gOaFENki.png?imageslim" alt="mark"><br>        请求体：<br>            这次请求客户端想要发送给服务端的数据正文，一般在 GET 请求时很少用到</p><h2 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/ebEhifGjvaCI.png?imageslim" alt="mark"><br>        状态行： 协议+状态码+状态描述<br>        响应头：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/cdb97OubXsba.png?imageslim" alt="mark"><br>        响应体：<br>            服务端想要返回给客户端的数据正文，一般返回的都是 HTML，也可以返回 JavaScript 或者 CSS</p><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><ul><li><p>设置响应文件的类型<br><code>header(&quot;Content-Type: text/css&quot;)</code></p></li><li><p>重定向<br><code>header(&quot;Location: xxx.php&quot;)</code><br><code>header(&quot;refresh:3; url=xxx.php&quot;)</code> 重定向延迟3s跳转</p></li><li><p>下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 让文件下载</span><br><span class="line">header(&apos;Content-Type: application/octet-stream&apos;);</span><br><span class="line">// 设置默认下载文件名</span><br><span class="line">header(&apos;Content-Disposition: attachment; filename=demo.txt&apos;);</span><br></pre></td></tr></table></figure></li><li><p>图片防盗链</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求报文数据</span></span><br><span class="line"><span class="comment">// print_r(getallheaders());</span></span><br><span class="line">$refer = getallheaders()[<span class="string">"Referer"</span>];</span><br><span class="line"><span class="keyword">echo</span> $refer;</span><br><span class="line"><span class="comment">//获取url的各部分</span></span><br><span class="line">print_r(parse_url($refer));</span><br><span class="line">$host = parse_url($refer)[<span class="string">"host"</span>];</span><br><span class="line"><span class="keyword">if</span>($host === <span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"识别主机，响应"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"不响应"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP注册案例源码</title>
      <link href="/2018/05/27/5.PHP/3.PHP%E6%B3%A8%E5%86%8C%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81/"/>
      <url>/2018/05/27/5.PHP/3.PHP%E6%B3%A8%E5%86%8C%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><strong>本案例会把用户数据写入php同级目录下info.txt文件中，头像会存放在php文件同级目录下userAvatar文件夹下；这两个文件/文件夹需要自行创建</strong><br>以下是源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>($_SERVER[<span class="string">"REQUEST_METHOD"</span>]===<span class="string">"POST"</span>)&#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// $_POST打印出来格式如下</span></span><br><span class="line">        <span class="comment">// Array</span></span><br><span class="line">        <span class="comment">//     (</span></span><br><span class="line">        <span class="comment">//         [username] =&gt; liuxiao</span></span><br><span class="line">        <span class="comment">//         [nickname] =&gt; liu</span></span><br><span class="line">        <span class="comment">//         [age] =&gt; 18</span></span><br><span class="line">        <span class="comment">//         [tel] =&gt; 139</span></span><br><span class="line">        <span class="comment">//         [sex] =&gt; 男</span></span><br><span class="line">        <span class="comment">//         [banji] =&gt; 1</span></span><br><span class="line">        <span class="comment">//     )</span></span><br><span class="line">        <span class="comment">// 判断输入是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"username"</span>])||trim($_POST[<span class="string">"username"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入姓名"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"nickname"</span>])||trim($_POST[<span class="string">"nickname"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入昵称"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"age"</span>])||trim($_POST[<span class="string">"age"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入年龄"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"tel"</span>])||trim($_POST[<span class="string">"tel"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入电话"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"sex"</span>])||trim($_POST[<span class="string">"sex"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入性别"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//$_FILES的内容</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>($_FILES)||$_FILES[<span class="string">"photo"</span>][<span class="string">"error"</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请上传头像"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            $type = $_FILES[<span class="string">"photo"</span>][<span class="string">"type"</span>];</span><br><span class="line">            <span class="keyword">if</span>(strpos($type,<span class="string">"image/"</span>)===<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//获取文件后缀名生成随机文件名</span></span><br><span class="line">                $houzhui = strrchr ($_FILES[<span class="string">"photo"</span>][<span class="string">"name"</span>],<span class="string">"."</span>);</span><br><span class="line">                $newFileName = time().rand(<span class="number">1000</span>,<span class="number">9999</span>).$_POST[<span class="string">"username"</span>].$houzhui;</span><br><span class="line">                move_uploaded_file($_FILES[<span class="string">"photo"</span>][<span class="string">"tmp_name"</span>],<span class="string">"./userAvatar/"</span>.$newFileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"上传的不是图片格式"</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        $_POST[]=$newFileName;</span><br><span class="line">        $str = implode($_POST,<span class="string">"|"</span>);<span class="comment">//最终存储到txt文件的字符串</span></span><br><span class="line">        <span class="comment">// echo $str;</span></span><br><span class="line">        file_put_contents(<span class="string">"./info.txt"</span>,$str.<span class="string">"\n"</span>,FILE_APPEND);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"./css/form.css"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">                * &#123;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">            padding: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        body &#123;</span><br><span class="line">            background: <span class="comment">#ccc;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        h1,</span><br><span class="line">        h2,</span><br><span class="line">        h3,</span><br><span class="line">        h4,</span><br><span class="line">        h5,</span><br><span class="line">        h6 &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        form &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            margin: <span class="number">50</span>px auto;</span><br><span class="line">            padding: <span class="number">20</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#eee;</span></span><br><span class="line">            border-radius: <span class="number">10</span>px;</span><br><span class="line">            background: <span class="comment">#fff;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'text'</span>],</span><br><span class="line">        input[type=<span class="string">'select'</span>],</span><br><span class="line">        input[type=<span class="string">'password'</span>],</span><br><span class="line">        input[type=<span class="string">'submit'</span>],</span><br><span class="line">        input[type=<span class="string">'password'</span>],</span><br><span class="line">        input[type=<span class="string">'file'</span>],</span><br><span class="line">        select &#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            display: block;</span><br><span class="line">            height: <span class="number">24</span>px;</span><br><span class="line">            margin-bottom: <span class="number">15</span>px;</span><br><span class="line">            border-radius: <span class="number">3</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#aaa;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'submit'</span>] &#123;</span><br><span class="line">            height: <span class="number">40</span>px;</span><br><span class="line">            background: rgb(<span class="number">209</span>, <span class="number">92</span>, <span class="number">92</span>);</span><br><span class="line">            border: none;</span><br><span class="line">            color: <span class="comment">#fff;</span></span><br><span class="line">            font-size: <span class="number">24</span>px;</span><br><span class="line">            ;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'radio'</span>],</span><br><span class="line">        input[type=<span class="string">'checkbox'</span>] &#123;</span><br><span class="line">            height: <span class="number">20</span>px;</span><br><span class="line">            width: <span class="number">20</span>px;</span><br><span class="line">            <span class="comment">/* display: inline; */</span></span><br><span class="line">            margin: <span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'file'</span>] &#123;</span><br><span class="line">            border: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .box &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: <span class="number">10</span>px;</span><br><span class="line">            left: <span class="number">350</span>px;</span><br><span class="line">            width: <span class="number">73</span>px;</span><br><span class="line">            height: <span class="number">73</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#666;</span></span><br><span class="line">            border-radius: <span class="number">10</span>%;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;   </span><br><span class="line">    &lt;form action=<span class="string">"&lt;?php echo $_SERVER["</span>PHP_SELF<span class="string">"] ?&gt;"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">        头像： &lt;input type=<span class="string">"file"</span> name=<span class="string">"photo"</span> id=<span class="string">"photo"</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;</span><br><span class="line">        昵称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"nickname"</span>&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</span><br><span class="line">        电话：&lt;input type=<span class="string">"text"</span> name=<span class="string">"tel"</span>&gt;</span><br><span class="line">        性别：&lt;input type=<span class="string">"radio"</span> name=<span class="string">"sex"</span> value=<span class="string">"男"</span> checked&gt;男</span><br><span class="line">             &lt;input type=<span class="string">"radio"</span> name=<span class="string">"sex"</span> value=<span class="string">"女"</span> &gt;女</span><br><span class="line">             &lt;br&gt;</span><br><span class="line">        班级：&lt;select name=<span class="string">"banji"</span> &gt;</span><br><span class="line">                &lt;option value=<span class="string">"1"</span>&gt;黑马<span class="number">11</span>期&lt;/option&gt;</span><br><span class="line">                &lt;option value=<span class="string">"2"</span>&gt;黑马<span class="number">12</span>期&lt;/option&gt;</span><br><span class="line">                &lt;option value=<span class="string">"3"</span>&gt;黑马<span class="number">13</span>期&lt;/option&gt;</span><br><span class="line">             &lt;/select&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"添加信息"</span>&gt;</span><br><span class="line">        &lt;img class="box"&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现头像实时预览功能</span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> photo = document.querySelector(<span class="string">"#photo"</span>);</span><br><span class="line">        photo.onchange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> file = photo.files[<span class="number">0</span>]; <span class="comment">//表单的files属性存储了所有相关信息</span></span><br><span class="line">            <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();<span class="comment">//读取器</span></span><br><span class="line">            reader.readAsDataURL(file);<span class="comment">//读取器读取图片</span></span><br><span class="line">            reader.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//读取完毕后把图片路径给盒子的src</span></span><br><span class="line">                <span class="keyword">var</span> box = document.querySelector(<span class="string">".box"</span>);</span><br><span class="line">                box.src = reader.result;</span><br><span class="line">                console.log(reader.result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐列表案例</title>
      <link href="/2018/05/27/5.PHP/2.2.%E9%9F%B3%E4%B9%90%E5%88%97%E8%A1%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/05/27/5.PHP/2.2.%E9%9F%B3%E4%B9%90%E5%88%97%E8%A1%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、音乐列表"><a href="#一、音乐列表" class="headerlink" title="一、音乐列表"></a>一、音乐列表</h1><h2 id="1-功能点"><a href="#1-功能点" class="headerlink" title="1.功能点"></a>1.功能点</h2><pre><code>表格展示数据，增删改歌曲信息</code></pre><h2 id="2-数据存储"><a href="#2-数据存储" class="headerlink" title="2.数据存储"></a>2.数据存储</h2><p>数据如何描述和保存： 不再使用字符串加|的格式，因为无法区分值对应的属性名。<br>使用json描述数据： javascript object notation js对象的描述</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">属性名1:属性值,</span><br><span class="line">属性名2:属性值</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">属性名3:属性值,</span><br><span class="line">属性名4:属性值</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>语法：属性和值都用双引号，除非是数字；json文件中不能写任何注释；没有undifined<br>描述对象使用{}，描述数组使用[]<br><code>json_decode($str,boolean)</code>: 将json格式的字符串转换为php数组或对象<br>　　　字符串中的[]默认转换为数组，{}默认转换为对象<br>　　　第二个参数如果是true转换为数组，如果是false转换为对象<br><code>json_encode($arr或$obj)</code>: 将php数组或对象转换为json格式的字符串</p><h2 id="3-判断输入数据是否合法"><a href="#3-判断输入数据是否合法" class="headerlink" title="3.判断输入数据是否合法"></a>3.判断输入数据是否合法</h2><p>之前用echo提示，只能提示一个错误，并且显示的位置不合理；<br>需要一次性提示用户所有的错误输入信息；判断出错后，先存储所有的错误信息到数组errorArr里，后面再统一处理<br>        in_array方法（元素，数组）判断元素是否在数组中<br>操作提示信息盒子的类名：<br><code>&lt;?php echo in_array(&quot;title&quot;,_GLOBAL[&quot;error&quot;])?&quot;show&quot;:&quot;&quot; ?&gt;</code></p><h2 id="4-新增音乐功能"><a href="#4-新增音乐功能" class="headerlink" title="4.新增音乐功能"></a>4.新增音乐功能</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190603/LLSQmnOgPBsS.png?imageslim" alt="mark"><br>id用于标识区分是哪一行，方便后面的删除和编辑</p><h2 id="5-删除音乐功能"><a href="#5-删除音乐功能" class="headerlink" title="5.删除音乐功能"></a>5.删除音乐功能</h2><pre><code>`array_splice(数组，起始索引，删除几个元素)；`</code></pre><p>获取id号；<br>获取json数据 ，转换为数组；<br>根据id号删除数组中的元素（遍历数组）；<br>将删除后的数组数据重新写入json文件；<br>页面跳转到list.php列表页</p><h2 id="6-修改音乐功能"><a href="#6-修改音乐功能" class="headerlink" title="6.修改音乐功能"></a>6.修改音乐功能</h2>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GET和POST方法</title>
      <link href="/2018/05/27/5.PHP/2.1.GET%E5%92%8CPOST%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/27/5.PHP/2.1.GET%E5%92%8CPOST%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、GET请求"><a href="#一、GET请求" class="headerlink" title="一、GET请求"></a>一、GET请求</h1><h2 id="1-什么是GET"><a href="#1-什么是GET" class="headerlink" title="1.什么是GET"></a>1.什么是GET</h2><p>获取服务端的数据</p><h2 id="2-发起GET请求常见的方式"><a href="#2-发起GET请求常见的方式" class="headerlink" title="2.发起GET请求常见的方式"></a>2.发起GET请求常见的方式</h2><p>地址栏访问；<br>src/href；<br>表单；<br>网页中各种搜索框，详情页面，大部分超链接</p><h2 id="3-GET方式提交数据的格式"><a href="#3-GET方式提交数据的格式" class="headerlink" title="3.GET方式提交数据的格式"></a>3.GET方式提交数据的格式</h2><p><code>index.php?userName=jack&amp;password=123</code></p><h2 id="4-GET的特点"><a href="#4-GET的特点" class="headerlink" title="4.GET的特点"></a>4.GET的特点</h2><p>get方式在url后面拼接参数，只能以文本的形式传递数据<br>传递的数据量小，4KB左右（不同浏览器会有差异）<br>安全性低，会将数据显示在地址栏<br>速度快，通常用于对安全性要求不高的请求</p><h1 id="二、POST请求"><a href="#二、POST请求" class="headerlink" title="二、POST请求"></a>二、POST请求</h1><h2 id="1-什么是POST"><a href="#1-什么是POST" class="headerlink" title="1.什么是POST"></a>1.什么是POST</h2><p>字面上理解，post就是指<code>发送，提交</code>,它可以向指定的资源提交要被处理的数据</p><h2 id="2-为什么需要POST请求"><a href="#2-为什么需要POST请求" class="headerlink" title="2.为什么需要POST请求"></a>2.为什么需要POST请求</h2><p>GET方式提交数据通过URL传递到请求的页面，提交的数据量一般较小，用于请求页面数据。此外，GET方式传递的数据安全性低, 对于密码等隐私信息、文件上传必须使用POST方式提交。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190527/7xl1jbqYIx4u.png?imageslim" alt="mark"><br>要求：如果使用表单方式进行提交，表单的method必须设置为POST</p><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><p>1-post 方式 安全性比较高<br>2-传递数据量大，请求对数据长度没有要求<br>3-请求不会被缓存，也不会保留在浏览器历史记录中<br>用于：密码等安全性要求比较高的场合，提交的数据量比较大：发布文章，上传文件。</p><blockquote><p>POST方式提交数据上限默认为8M（可以在PHP的配置文件post_max_size选项中修改）</p></blockquote><h1 id="三、表单处理"><a href="#三、表单处理" class="headerlink" title="三、表单处理"></a>三、表单处理</h1><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>form表单元素有两个重要的属性：<br>            action：处理数据的页面，一般是后台页面xxx.php<br>            method：get/post<br>提交表单元素的数据 <strong>必须设置name属性</strong>，这样才能生成url里面的key=value的结构</p><p>php里有三个超全局变量，都是关联数组， 用于接收表单提交的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_GET  存储了以GET方法提交的参数</span><br><span class="line">$_POST 存储了以POST方法提交的参数</span><br><span class="line">$_REQUEST：用于获取 GET 或 POST 方式提交的参数</span><br></pre></td></tr></table></figure><h2 id="2-SERVER"><a href="#2-SERVER" class="headerlink" title="2.$_SERVER"></a>2.$_SERVER</h2><p>$_SERVER 存储了用户请求的相关数据，也是关联数组，常用的属性有：<br>    PHP_SELF: 获取当前文件的路径<br>    REQUEST_METHOD：请求方法名称<br>一般处理请求时需要进行判断再输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($_SERVER[&apos;REQUEST_METHOD&apos;] === &apos;POST&apos;) &#123;</span><br><span class="line">  // 表单提交请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常见表单元素处理方式"><a href="#3-常见表单元素处理方式" class="headerlink" title="3.常见表单元素处理方式"></a>3.常见表单元素处理方式</h2><p>系统会自动收集表单属性的value值<br><strong>单选按钮radio</strong>： 如果不设置value值，选中状态收集到的值是on<br><strong>复选框checkbox</strong>：如果不设置value值，选中状态收集到的值是on; 多个复选框name值设置为相同的并且要加[]，系统会把所有选中的值存储到数组中<br><strong>下拉列表select</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;sel&quot;&gt; </span><br><span class="line">&lt;option value=&quot;1&quot;&gt;唱&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;2&quot;&gt;跳&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;3&quot;&gt;rap&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;4&quot;&gt;篮球&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>如果没有给option设置value，会传递被选中的Option的文字内容；如果设置了value就会传递value </p><h2 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4.文件上传"></a>4.文件上传</h2><h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作:"></a>客户端操作:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;myFile&quot; multiple&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>form的enctype属性取值有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded 用来处理字符串 默认的编码格式</span><br><span class="line">multipart/form-data 用于处理特殊数据 如文件</span><br></pre></td></tr></table></figure><p>input的multiple属性: <code>添加multiple属性可以选择多个文件</code></p><h3 id="服务端操作："><a href="#服务端操作：" class="headerlink" title="服务端操作："></a>服务端操作：</h3><p>文件上传之后的相关信息都存储在$_FILES中，也是关联数组，$_FILES打印出来如下：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190527/WIKqASJ8BNIS.png?imageslim" alt="mark"><br>文件上传之后 如果不改变存放位置，会被删除，要使用函数移动文件位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(源文件全路径，目标路径);</span><br></pre></td></tr></table></figure><p>例如: <code>move_uploaded_file($_FILES[myFile][tmp_name],&quot;./upload/&quot;.文件名&quot;);</code></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1)判断用户是否进行了提交<br>            使用empty($_FILES)判断数组里是否有内容，有再进行移动位置<br>2)限制用户上传文件的类型：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1.设置表单属性 accept=&quot;.png,.jpg&quot;</span><br><span class="line">方法2.在服务端判断：获取$_FILES里面的文件类型$type=$_FILES[myFile][type]</span><br><span class="line">strpos(源字符串，目标字符串) 获取目标字符串在源字符串中第一次出现的索引，从0开始</span><br><span class="line">判断是否是图片类型：if（strpos($type,&quot;image/&quot;)===0）</span><br></pre></td></tr></table></figure><p>3)上传多个文件保存时不重名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把 时间time()+随机数rand(m,n)+文件扩展名 拼接作为新的文件名</span><br><span class="line">获取文件扩展名：strrchr(字符串m，字符n);  截取字符串m从n之后的字符，包含字符n</span><br></pre></td></tr></table></figure><p>4)php默认上传文件大小限制是2M，在php.ini中修改<code>upload_max_filesize</code>每次post请求传递的数据默认限制为8M，在php.ini中修改<code>post_max_size</code></p><p>5)上传多个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**客户端处理</span><br><span class="line">方式1：input表单添加multiple属性，但是只是能够选择多个文件，给input的name值后面添加中括号，这样$_FILES就能接收多个文件</span><br><span class="line">方式2：写多个input，并且给name加中括号</span><br><span class="line">**服务端处理</span><br><span class="line">和单个文件处理基本思想相同</span><br><span class="line">name和tmp_name只需要遍历一个即可，遍历时用$key=$value的方式，因为两个数组的索引是一一对应的</span><br></pre></td></tr></table></figure><h1 id="四、案例：基于文件的注册"><a href="#四、案例：基于文件的注册" class="headerlink" title="四、案例：基于文件的注册"></a>四、案例：基于文件的注册</h1><ul><li>php中如果直接写return，整个php代码执行就结束了；如果在方法中return，则只结束方法的执行，因此：判断完用户发送的是POST请求后，调用一个函数register，而不是直接把代码写在判断中</li><li>trim()方法 可以去除字符串中的空格</li><li>数据写入txt文件的格式是 qq|qqq|123|…</li><li>implode() 将关联数组的数据以指定的分隔符分割，转换为字符串(和explode相反)</li></ul><h1 id="五、图片即时预览功能"><a href="#五、图片即时预览功能" class="headerlink" title="五、图片即时预览功能"></a>五、图片即时预览功能</h1><p>使用js编写；<br>为文件输入表单添加change事件，操作写在change事件内；<br>图片存储在表单的files属性里,是一个伪数组； 表单.files[0]可以获取图片的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader(); 定义一个文件读取器</span><br><span class="line">reader.readAsDataURL(图片) 读取图片  读取结果存放在reader.result里</span><br></pre></td></tr></table></figure><p>本案例源码在下一篇日志。由于博客没有添加代码折叠功能，代码占据体积较大。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滕王阁序</title>
      <link href="/2018/05/27/6.%E5%8F%A4%E6%96%87/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/"/>
      <url>/2018/05/27/6.%E5%8F%A4%E6%96%87/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<center>唐 王勃</center><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><center>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</center><center>画栋朝飞南浦云，珠帘暮卷西山雨。</center><center>闲云潭影日悠悠，物换星移几度秋。</center><center>阁中帝子今何在？槛外长江空自流。</center>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滕王阁序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP介绍和语法</title>
      <link href="/2018/05/25/5.PHP/1.PHP%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/25/5.PHP/1.PHP%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、phpStudy工具使用"><a href="#一、phpStudy工具使用" class="headerlink" title="一、phpStudy工具使用"></a>一、phpStudy工具使用</h1><h2 id="1-设置网站根目录"><a href="#1-设置网站根目录" class="headerlink" title="1.设置网站根目录"></a>1.设置网站根目录</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/7VX3iJlHdLaw.png?imageslim" alt="mark"></p><h2 id="2-创建虚拟主机域名"><a href="#2-创建虚拟主机域名" class="headerlink" title="2.创建虚拟主机域名"></a>2.创建虚拟主机域名</h2><p>1.在根目录下创建子文件夹<br>2.在站点域名管理新建域名<br>3.修改host文件 映射添加的域名<br>4.修改配置文件vhosts.ini 在相应域名下修改 <code>Options Indexes FollowSymLinks ExecCGI</code></p><h2 id="3-VS配置文件修改"><a href="#3-VS配置文件修改" class="headerlink" title="3.VS配置文件修改"></a>3.VS配置文件修改</h2><p><code>&quot;php.validate.executablePath&quot;:路径</code></p><hr><h1 id="二、php语法特点"><a href="#二、php语法特点" class="headerlink" title="二、php语法特点"></a>二、php语法特点</h1><h2 id="1-输出语句"><a href="#1-输出语句" class="headerlink" title="1.输出语句"></a>1.输出语句</h2><p><code>echo</code> 输出字符串   echo “123”,”456”;  可以输出多个字符串<br><code>print</code>输出字符串   print “123”;    只能输出一个字符串<br><code>print_r();</code> 可以输出复杂类型 输出形式是key和值<br><code>var_dump();</code> 可以输出复杂类型 输出形式是key和值 同时可以获取值的长度<br><code>die()</code> 输出后,后面的代码不再执行</p><p>输出细节： 如果输出为true结果为1；如果为false输出为null</p><h2 id="2-与html混编"><a href="#2-与html混编" class="headerlink" title="2.与html混编"></a>2.与html混编</h2><p>php代码要写在php结构以内<code>&lt;?php代码 ?&gt;</code><br>html代码不能写在php结构内<br>1）普通嵌入<br><code>&lt;p&gt;&lt;?php代码 ?&gt;&lt;/p&gt;</code><br>2）混合编写<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/TVeSqwzC4svU.png?imageslim" alt="mark">    </p><h2 id="3-php注释"><a href="#3-php注释" class="headerlink" title="3.php注释"></a>3.php注释</h2><p>单行：#可以进行单行注释 但不常用<br>多行：<code>/*多行注释*/</code></p><hr><h1 id="三、php语法"><a href="#三、php语法" class="headerlink" title="三、php语法"></a>三、php语法</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><ul><li>所有的变量声明 必须以$符号做前缀</li><li>变量名区分大小写</li><li>变量名由字母，数字，下划线构成</li><li>声明变量时无需关注类型，和js的弱类型相似；</li><li>如果只声明不赋值，变量值默认为空</li><li>与变量相关的函数：<br>　　-isset() 判断变量是否存在/变量值是否为空，返回值是true和false<br>　　-empty() 判断变量是否为空  “”, 0, “0”, null, false, array()<br>　　-unset() 删除变量<br>　　　如果删除变量会把它的值置空；<br>　　　可以同时删除多个变量，中间加逗号<br>　　　如果在函数中删除全局变量，并不会真的 将全局变量删除</li></ul><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="索引数组："><a href="#索引数组：" class="headerlink" title="索引数组："></a>索引数组：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">或者 $arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组:"></a>关联数组:</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">'key1'</span> =&gt; <span class="string">'value1'</span>, <span class="string">'key2'</span> =&gt; <span class="string">'value2'</span>);</span><br><span class="line">或者$arr2 = [<span class="string">'key1'</span> =&gt; <span class="string">'value1'</span>, <span class="string">'key2'</span> =&gt; <span class="string">'value2'</span>];</span><br></pre></td></tr></table></figure><h3 id="隐形数组："><a href="#隐形数组：" class="headerlink" title="隐形数组："></a>隐形数组：</h3><p>$arr[] = 1  系统自动生成索引<br>对于索引数组 自动递增数组的索引；<br>对于关联数组 索引从0开始</p><h3 id="二维数组："><a href="#二维数组：" class="headerlink" title="二维数组："></a>二维数组：</h3><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/2GuTljX0D7n8.png?imageslim" alt="mark"></p><h3 id="索引数组的遍历："><a href="#索引数组的遍历：" class="headerlink" title="索引数组的遍历："></a>索引数组的遍历：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($arr);$i++)&#123;</span><br><span class="line"><span class="keyword">echo</span> $arr[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联数组的遍历："><a href="#关联数组的遍历：" class="headerlink" title="关联数组的遍历："></a>关联数组的遍历：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key=&gt;$value)&#123;</span><br><span class="line"><span class="keyword">echo</span> $key;</span><br><span class="line"><span class="keyword">echo</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以遍历索引数组<br>括号里不需要key可以不写</p><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $value)&#123;</span><br><span class="line"><span class="keyword">foreach</span>($value <span class="keyword">as</span> $value1)&#123;</span><br><span class="line">print_r($value1);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h2><ul><li>强制类型转换：<br>在变量前面添加：  (类型)变量;<br>任何变量都可以转换为数组： (array)变量  变量值会变成数组的元素</li><li>自动类型转换：<br>php大部分情况下都是自动转换</li></ul><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算术运算符： + - * / % ++ --</span><br><span class="line">赋值运算符：= += -= *= /=</span><br><span class="line">逻辑运算符： ! &amp;&amp; ||</span><br><span class="line">比较运算符： &gt; &gt;= &lt; &lt;= == === !=</span><br><span class="line">三元运算符： a&gt;b? &quot;xxx&quot; : &quot;xxx&quot;</span><br></pre></td></tr></table></figure><ul><li>加号+：只能是算术运算符，自动将加号两边的变量转换为数字，如果可以转换就转换，如果不能转换会返回这个数据类型的默认值：int-&gt;0  object-&gt;null  bool-&gt;false   float-&gt;0.0 </li><li>点号.: 用于连接字符串</li></ul><h2 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5.流程控制"></a>5.流程控制</h2><p>if分支指令式写法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>():</span><br><span class="line"><span class="keyword">elseif</span>():</span><br><span class="line"><span class="keyword">elseif</span>():</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="keyword">endif</span>;</span><br></pre></td></tr></table></figure><p>for指令式写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>():</span><br><span class="line"><span class="keyword">endfor</span>;</span><br></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><p>和js的区别：<br>　　　在js中函数内部可以使用外部的全局变量；<br>　　　但是在php中函数内部不能使用函数外部的成员<br>　　　想要在函数内部使用外部的变量（针对不传参数的情况），需要使用关键字global：<br>　　　　　　<code>global $num;</code><br>把外部变量$num声明为内部可以使用的全局变量　　　　　<br>如果想要在函数内修改$num的值，需要另起一行 $num = 10;<br>如果在函数内修改了全局变量的值，那么函数外使用到这个值也会受影响</p><h2 id="7-php超全局变量"><a href="#7-php超全局变量" class="headerlink" title="7.php超全局变量"></a>7.php超全局变量</h2><p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。<br>在函数或方法中无需执行 global $variable; 就可以访问它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS — 引用全局作用域中可用的全部变量，存储了所有的全局变量</span><br><span class="line">$_SERVER — 获取服务端相关信息</span><br><span class="line">$_REQUEST — 获取提交参数</span><br><span class="line">$_POST — 获取 POST 提交参数</span><br><span class="line">$_GET — 获取 GET 提交参数</span><br><span class="line">$_FILES — 获取上传文件</span><br><span class="line">$_ENV — 操作环境变量</span><br><span class="line">$_COOKIE — 操作 Cookie</span><br><span class="line">$_SESSION — 操作 Session</span><br></pre></td></tr></table></figure><h2 id="8-常量"><a href="#8-常量" class="headerlink" title="8.常量"></a>8.常量</h2><p>定义语法： <code>define(名称，值，是否对大小写敏感);</code><br>常量名一般大写；第三个参数insensitive：默认是false，区分大小写<br>例如 define(“PI”,3.14,false);<br><strong>php中的魔术常量</strong>： 根据不同的使用场合返回不同的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__LINE__：获取当前的代码行</span><br><span class="line">__FILE__:获取当前文件路径：目录+文件名</span><br><span class="line">__DIR__:获取当前文件目录</span><br><span class="line">__FUNCTION__:获取当前魔术常量所在的函数</span><br></pre></td></tr></table></figure><h2 id="9-载入其他文件"><a href="#9-载入其他文件" class="headerlink" title="9.载入其他文件"></a>9.载入其他文件</h2><p>本质：把其他php文件的代码复制到载入文件的地方<br>PHP中引入其他 PHP 文件有四种方式：</p><ul><li><p>require    文件载入失败会影响后续代码执行；重复载入文件会载入多次</p></li><li><p>require_once  文件载入失败会影响后续代码执行；重复载入文件也只会载入一次</p></li><li><p>include    文件载入失败不会影响后续代码执行；重复载入文件会载入多次</p></li><li><p>include_once  文件载入失败不会影响后续代码执行；重复载入文件也只会载入一次</p></li></ul><p>使用环境：<br>如果是公共文件，不能影响后续代码执行，要使用include；<br>如果是必须文件，不能缺少，使用require</p><h2 id="10-常用API"><a href="#10-常用API" class="headerlink" title="10.常用API"></a>10.常用API</h2><p><code>strlen($str)</code> 获取字符串的长度<br>　　　不能处理宽字符集，如中文等；GB2312每个字符占2字节；UTF-8每个字符占3字节<br><code>mb_internal_encoding()</code> 获取php当前文件的默认编码<br><code>mb_strlen($str)</code>获取字符串的长度，能够处理宽字符集，把中文字符识别成一个字节<br>　　　默认情况下不能使用，需要在配置文件php.ini里修改php_mbstring.dll字段<br><code>explode(&quot;分隔符&quot;,$str)</code> 把字符串按照分隔符分割为数组<br><code>count($arr)</code>获取数组长度<br><code>date(&quot;Y-m-d H:i:s&quot;)</code>获取当前时间<br>　　　默认是格林威治时间，修改php.ini的timezone字段可以获取本地时间<br>　　　可以通过 strtotime() 将有格式的时间字符串转换为时间戳<br><code>time()</code>获取从格林威治时间 1970-01-01 00:00:00到当前时间的秒数</p><h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><p><code>file_get_contents 读取文件内容；</code><br>　　　读取成功返回文件内容；读取失败返回false<br>　　　读取图片时要设置浏览器的读取方式:<code>header(&quot;Content-Type:image/jpeg&quot;);</code><br><code>file_put_contents(文件路径,需要写入的内容,FILE_APPEND);</code><br>　　　写入内容，同时返回写入的长度,第三个参数如果添加，是追加内容，不添加会覆盖原有文件内容</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/14.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/14.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1.什么是正则表达式"></a>1.什么是正则表达式</h2><p>用于匹配规律规则的表达式；正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h2><p>1.给定的字符串是否符合正则表达式的过滤逻辑(匹配)<br>2.可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)<br>3.强大的字符串替换能力(替换)</p><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><ol><li>灵活性、逻辑性和功能性非常的强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂</li></ol><hr><h1 id="二、组成"><a href="#二、组成" class="headerlink" title="二、组成"></a>二、组成</h1><h2 id="1-普通字符"><a href="#1-普通字符" class="headerlink" title="1.普通字符"></a>1.普通字符</h2><pre><code>如abc，123等</code></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h2><p>正则表达式中有特殊意义的字符<br>1）常用元字符<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/tcrNY9X9hDNz.png?imageslim" alt="mark"><br>2）限定符<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/zenqTADv6Bc2.png?imageslim" alt="mark"></p><p>[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思<br>[^]  匹配除中括号以内的内容<br>\ 转义符 匹配有特殊意义的字符时，需要进行转义<br>| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱<br>() 从两个直接量中选择一个，例如：gr(a|e)y匹配gray和grey<br><code>[\u4e00-\u9fa5]</code> 匹配汉字</p><hr><h1 id="三、JS里的正则表达式"><a href="#三、JS里的正则表达式" class="headerlink" title="三、JS里的正则表达式"></a>三、JS里的正则表达式</h1><h2 id="1-正则对象"><a href="#1-正则对象" class="headerlink" title="1.正则对象"></a>1.正则对象</h2><p>内置对象RegExp  regularExpression</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span>：<span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(表达式，flag);  <span class="comment">//括号内是字符串格式</span></span><br><span class="line">方式<span class="number">2</span>：<span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>flag  <span class="comment">//不需要是字符串格式，不加''</span></span><br></pre></td></tr></table></figure><p>flag: ‘i’ 忽略大小写   ‘g’ 全局匹配   ‘gi’全局匹配并且忽略大小写</p><h2 id="2-正则表达式的方法"><a href="#2-正则表达式的方法" class="headerlink" title="2.正则表达式的方法"></a>2.正则表达式的方法</h2><p><strong>test和exec是正则对象的方法</strong><br><strong>match,replace,split是字符串的方法</strong></p><h3 id="1）匹配："><a href="#1）匹配：" class="headerlink" title="1）匹配："></a>1）匹配：</h3><p><code>reg.test(str)    如果str和reg匹配返回true，否则返回false</code></p><h3 id="2）提取："><a href="#2）提取：" class="headerlink" title="2）提取："></a>2）提取：</h3><p>提取时reg不写开始和结束符号，经常使用全局匹配：<code>/表达式/g</code><br><code>reg.exec(str)</code>  一次只返回符合表达式的一个结果<br><code>str.match(reg)</code> 返回str字符串中符合表达式的结果，如果是全局匹配，会返回所有结果<br>返回值都是数组形式</p><h3 id="3）分组提取："><a href="#3）分组提取：" class="headerlink" title="3）分组提取："></a>3）分组提取：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'2019-5-22'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/</span>;</span><br><span class="line">reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>把reg用括号分成不同的组；<br>执行任意一种表达式方法后，可以用<code>RegExp.$1</code>获取第一组，<code>RegExp.$2</code>获取第二组…</p><h3 id="4）切割split"><a href="#4）切割split" class="headerlink" title="4）切割split"></a>4）切割split</h3><p>字符串的split方法可以配合正则表达式使用<br><code>str.split(/[分隔符]/)  返回的是数组</code></p><h3 id="5）替换replace"><a href="#5）替换replace" class="headerlink" title="5）替换replace"></a>5）替换replace</h3><p><code>str.replace(字符1，字符2);</code><br>把字符1替换为字符2，只替换匹配的第一个；<br>字符1可以使用正则表达式，加上全局匹配g，这样就可以全部替换<br>去掉字符串所有空格的第二种方法 <code>str.split(&#39;&#39;).join(&#39;&#39;);</code></p><h2 id="3-贪婪模式和非贪婪模式"><a href="#3-贪婪模式和非贪婪模式" class="headerlink" title="3.贪婪模式和非贪婪模式"></a>3.贪婪模式和非贪婪模式</h2><p><strong>贪婪模式</strong>：正则表达式进行匹配时，默认是贪婪模式；<br>　　　　　例如匹配页面所有的标签&lt;.+&gt; 这样会把双标签内的文本也获取到；<br><strong>非贪婪模式</strong>： &lt;.+?&gt;在结束符号之前加问号，这样匹配到一个符合的就不再匹配后续字符</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包、递归和对象拷贝</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/13.%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/13.%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="函数的执行过程"><a href="#函数的执行过程" class="headerlink" title="函数的执行过程"></a>函数的执行过程</h2><p>调用函数：创建内存地址<br>1）进栈 进入执行环境<br>2）压栈 执行当前环境的代码<br>3）出栈 返回执行环境<br>4）销毁内存空间</p><h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><p>一个作用域可以访问其他作用域的变量；<br>一个封闭的执行环境（隔离区域）<br>函数才能起到闭包作用</p><h2 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h2><p>在一个作用域内部 访问外部的变量或者函数</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>函数调用函数本身，注意添加结束条件，否则会出现内存溢出问题</p><p>递归的应用：遍历DOM树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadTree</span>(<span class="params">parent, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parent.children.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> child = parent.children[i];</span><br><span class="line"><span class="keyword">if</span> (callback) &#123;</span><br><span class="line">callback(child);</span><br><span class="line">&#125;</span><br><span class="line">loadTree(child, callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h1><p>把obj1的成员复制给obj2 </p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">obj2[k] = obj1[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只复制obj1的第一层成员，如果obj1里面还有obj3或者数组，那么obj2只是复制了obj3的地址，不会创建新的对象；<br>拷贝完成后，修改obj1的复杂类型，会同步修改obj2</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>拷贝obj1的多层属性;<br>拷贝完成后，obj1中的属性发生变化，不会影响obj2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj1) &#123;</span><br><span class="line"><span class="comment">//如果是数组</span></span><br><span class="line"><span class="keyword">if</span> (obj1[k] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">obj2[k] = [];</span><br><span class="line">deepCopy(obj1[k], obj2[k]); <span class="comment">//递归调用拷贝方法;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是object类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj1[k] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">obj2[k] = &#123;&#125;;</span><br><span class="line">deepCopy(obj1[k], obj2[k]); <span class="comment">//递归调用拷贝方法;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj2[k] = obj1[k]; <span class="comment">//普通拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断顺序不能改变，因为数组也属于对象</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数高级</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/12.%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/12.%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="声明函数的第三种方式"><a href="#声明函数的第三种方式" class="headerlink" title="声明函数的第三种方式"></a>声明函数的第三种方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function(&apos;var name=&quot;liuxiao&quot;;console.log(name)&apos;);</span><br></pre></td></tr></table></figure><p>传参数写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function(&apos;a&apos;,&apos;b&apos;,&apos;console.log(a+b)&apos;);</span><br><span class="line">fn(1,2)</span><br></pre></td></tr></table></figure><p>这种方式运行速度较慢，一般不使用;<br>console.dir(fn);会发现函数也是对象，fn是Function的实例</p><h2 id="函数调用方式和this指向"><a href="#函数调用方式和this指向" class="headerlink" title="函数调用方式和this指向"></a>函数调用方式和this指向</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/xmfFjGt5FfJS.png?imageslim" alt="mark"><br>函数内部的this指向，不是由书写的时候确定的，而是在函数调用时确定的</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><p>处理函数内部 this 指向问题的三个方法<br>1）fn.call(obj,其他参数)<br>改变this指向为obj，并且调用，返回值就是函数的返回值<br>应用： 让伪数组可以调用数组的方法</p><p>2）fn.apply(obj,[参数数组])<br>改变this指向为obj，并且调用，返回值就是函数的返回值；<br>参数以数组的形式传递 ，并不是真的数组<br>应用：可以把数组展开，每一项传递给方法<br>求数组的最大值；打印数组中的每一项</p><p>3）fn.bind(obj,其他参数)<br>改变this指向为obj，不调用，返回新的函数，需要定义变量接收bind<br>应用： 改变定时器的this指向；改变事件处理函数的this指向</p><h2 id="函数中的其他成员"><a href="#函数中的其他成员" class="headerlink" title="函数中的其他成员"></a>函数中的其他成员</h2><p>1）arguments<br>实参的伪数组<br>2）caller<br>函数的调用者，如果在全局调用，返回null<br>3）name<br>函数的名字<br>4）length<br>函数形参的个数</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>当函数作为参数或者返回值时，就产生了高阶函数</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/11.js%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/11.js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类,新的类能吸收已有类的数据属性和行为,并能扩展新的能力<br>如Student和Teacher的共同成员 提取到 Person里，实现代码复用<br>一般做框架时才用继承，做网页特效不使用继承</p><h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'liuxiao'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">sex</span>: <span class="string">'男'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="直接复制"><a href="#直接复制" class="headerlink" title="直接复制"></a>直接复制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o2[k]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o2[k] = o1[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(o2);</span><br></pre></td></tr></table></figure><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child[k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                child[k] = parent[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    extend(o1, o2);</span><br><span class="line">    <span class="built_in">console</span>.log(o2)</span><br></pre></td></tr></table></figure><h3 id="用arguments传参数"><a href="#用arguments传参数" class="headerlink" title="用arguments传参数"></a>用arguments传参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        extend: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> <span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>[k]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>[k] = <span class="built_in">arguments</span>[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.extend(o1, o2, o3);</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>缺点：原型继承无法设置构造函数的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = <span class="string">'liuxiao'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Stu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Stu.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">   Stu.prototype.constructor = Person;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> stu = <span class="keyword">new</span> Stu();</span><br><span class="line">   <span class="built_in">console</span>.log(stu.name);</span><br></pre></td></tr></table></figure><p>不能给stu设置参数。只能继承Person的参数；</p><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>缺点：无法重用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'liuxiao'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stu); <span class="comment">//可以设置参数</span></span><br><span class="line">    stu.sayHi(); <span class="comment">//报错提示没有此方法</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>既能设置参数 又能调用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">    Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'liuxiao'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stu);</span><br><span class="line">    stu.sayHi();</span><br></pre></td></tr></table></figure><h2 id="快速继承create"><a href="#快速继承create" class="headerlink" title="快速继承create()"></a>快速继承create()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">        name: <span class="string">'liuxiao'</span>,</span><br><span class="line">        friends: <span class="string">'dyx'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">    <span class="built_in">console</span>.log(anotherPerson.friends)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自调用函数</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/10.%E8%87%AA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/10.%E8%87%AA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>普通函数不调用不执行，立即执行函数不需要调用，能够自己执行，也称为自调用函数</p><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(形参) &#123;&#125;)(实参) 或者 (function()&#123;&#125;())</span><br></pre></td></tr></table></figure><p>可以传递参数；<br>有多个立即执行函数要用分号隔开；<br>立即执行函数会创建一个独立的作用域，里面的变量都是局部变量；<br>全局作用域下的变量不会被销毁，局部作用域的变量在关闭浏览器时会销毁；</p><h3 id="解决变量或方法的命名冲突问题："><a href="#解决变量或方法的命名冲突问题：" class="headerlink" title="解决变量或方法的命名冲突问题："></a>解决变量或方法的命名冲突问题：</h3><p>把同一个js文件的内容写在自调用函数里，开启一个新的作用域<br>(function(){js代码})()<br>注意把构造函数赋值给window,这样外部才能访问到： window.Food = Food;</p><h3 id="为了提升浏览器加载速度，要把所有js文件放到单个Index-js文件里"><a href="#为了提升浏览器加载速度，要把所有js文件放到单个Index-js文件里" class="headerlink" title="为了提升浏览器加载速度，要把所有js文件放到单个Index.js文件里"></a>为了提升浏览器加载速度，要把所有js文件放到单个Index.js文件里</h3><h3 id="自调用函数的问题："><a href="#自调用函数的问题：" class="headerlink" title="自调用函数的问题："></a>自调用函数的问题：</h3><p>连续写多个自调用函数时 前面要加分号，否则代码解析时会出现错误</p><h3 id="自调用函数的参数window和undifined"><a href="#自调用函数的参数window和undifined" class="headerlink" title="自调用函数的参数window和undifined"></a>自调用函数的参数window和undifined</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(function(window,undifined)&#123;</span><br><span class="line">//code</span><br><span class="line">&#125;)(window,undifined)</span><br></pre></td></tr></table></figure><p>window方便代码压缩，undifined防止被重命名</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/9.%E5%8E%9F%E5%9E%8B/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/9.%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>每个构造函数都有一个属性 原型或原型对象prototype<br>一般把构造函数的方法用原型声明在构造函数外部，这样不同实例使用此方法，不会开辟新的内存地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;属性&#125;;</span><br><span class="line">Person.prototype.sing = function()&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有很多方法时这样写比较麻烦，第6点会讲解如何解决</p><h2 id="构造函数、原型、对象实例之间的关系"><a href="#构造函数、原型、对象实例之间的关系" class="headerlink" title="构造函数、原型、对象实例之间的关系"></a>构造函数、原型、对象实例之间的关系</h2><p>原型图：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190519/PBHHf1AL8WL5.png?imageslim" alt="mark"></p><h2 id="为什么使用原型"><a href="#为什么使用原型" class="headerlink" title="为什么使用原型"></a>为什么使用原型</h2><p>减少内存占用、便于开发、资源共享</p><h2 id="获取属性-方法：原型链"><a href="#获取属性-方法：原型链" class="headerlink" title="获取属性/方法：原型链"></a>获取属性/方法：原型链</h2><p>实例对象调用方法和属性时，先去构造函数内寻找，如果构造函数内找到了，就停止寻找；如果构造函数内没有，去当前构造函数的原型对象内查找，如果还没有再去原型的原型找，直到找到，如果最终找不到则为null；</p><h2 id="设置属性："><a href="#设置属性：" class="headerlink" title="设置属性："></a>设置属性：</h2><p>给对象s1设置新的属性attr时，不会搜索原型链，而是直接给对象直接添加attr属性</p><h2 id="构造函数方法的写法"><a href="#构造函数方法的写法" class="headerlink" title="构造函数方法的写法"></a>构造函数方法的写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Student()&#123;xxx&#125;;</span><br><span class="line">Student.prototype = &#123;//在原型对象内部直接写方法</span><br><span class="line">say: function()&#123;</span><br><span class="line">&#125;，</span><br><span class="line">eat: function()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上步骤修改prototype后，prototype内已经没有constructor属性了。<br>所以对象实例的constructor属性的指向就不再是Student()了，而是Object(通过原型链找到的)；<br>可以手动再给prototype加上constructor属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = &#123;</span><br><span class="line">constructor: Student, //手动添加</span><br><span class="line">say: function()&#123;</span><br><span class="line">&#125;,</span><br><span class="line">eat: function()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明实例对象必须要在prototype修改之后，否则实例无法调用里面的方法：先设置原型对象，再使用其中的成员</p><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>数组或string中的prototype是不可以修改的；因为会覆盖原来的方法；<br>给内置对象添加方法时，只能用这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.getSum = function()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：-随机生成方块"><a href="#案例：-随机生成方块" class="headerlink" title="案例： 随机生成方块"></a>案例： 随机生成方块</h2><p>方块对象<br>工具对象：{生成随机数}</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象和构造函数</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/8.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/8.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象介绍"><a href="#面向对象介绍" class="headerlink" title="面向对象介绍"></a>面向对象介绍</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>(1) 对象是单个事物的抽象。<br>(2) 对象是一个容器，封装了属性（property）和方法（method）。<br>在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。<br>ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。</p><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。<br>面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目</p><p>面向对象与面向过程： </p><p>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊<br>面向对象就是找一个对象，指挥得结果<br>面向对象将执行者转变成指挥者<br>面向对象不是面向过程的替代，而是面向过程的封装</p><p>面向对象的特性：</p><p>封装性<br>继承性<br>[多态性]抽象</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &apos;Jack&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createPerson (name, age) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="工厂模式和构造函数"><a href="#工厂模式和构造函数" class="headerlink" title="工厂模式和构造函数"></a>工厂模式和构造函数</h2><p>工厂模式创建的实例 person instanceof Person返回是false，即不能识别对象<br>构造函数创建的实例 person instanceof Person返回是true，可以判断实例对象的类型</p><h2 id="构造函数和实例对象的关系"><a href="#构造函数和实例对象的关系" class="headerlink" title="构造函数和实例对象的关系"></a>构造函数和实例对象的关系</h2><p>实例对象没有constructor属性<br>是通过原型对象的constructor属性指向它的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log（person.constructor === Person）   // true</span><br></pre></td></tr></table></figure><p>但是检测某个实例 是否 是构造函数的实例时，一般使用instanceof方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log（person instanceof Person）   // true</span><br></pre></td></tr></table></figure><h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><p>成员：即属性或者方法<br>实例成员/对象成员： 跟对象相关的成员，将来使用对象的方式来调用 person.sing()<br>静态成员： 跟构造函数相关的成员，使用构造函数来调用 Person.version</p><h2 id="构造函数创建方法的问题"><a href="#构造函数创建方法的问题" class="headerlink" title="构造函数创建方法的问题"></a>构造函数创建方法的问题</h2><p>多个实例对象会存储多个同名的方法，造成内存浪费    –通过原型声明方法    </p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jq插件和其他方法</title>
      <link href="/2017/08/03/3.jquery/7.jquery%E6%8F%92%E4%BB%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/"/>
      <url>/2017/08/03/3.jquery/7.jquery%E6%8F%92%E4%BB%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="jq插件"><a href="#jq插件" class="headerlink" title="jq插件"></a>jq插件</h1><h2 id="常用的jq插件网站"><a href="#常用的jq插件网站" class="headerlink" title="常用的jq插件网站"></a>常用的jq插件网站</h2><p><a href="http://www.htmleaf.com/" target="_blank" rel="noopener">jquery之家</a><br><a href="www.jq22.com">jquery插件库</a></p><h3 id="瀑布流插件"><a href="#瀑布流插件" class="headerlink" title="瀑布流插件"></a>瀑布流插件</h3><p><a href="http://www.jq22.com/search?seo=%E7%80%91%E5%B8%83%E6%B5%81" target="_blank" rel="noopener">瀑布流插件</a></p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>可视区的图片显示，其他的不加载<br><a href="http://www.jq22.com/jquery-info11629" target="_blank" rel="noopener">easylazyload.js</a></p><p>原生js写法： 图片距离页面顶部的距离 &lt;= 可视区高度 + 页面卷去的头部时显示当前图片<br>不满足条件时，把正确src地址放在自定义属性data-img里，src里面放一张空白图片<br>满足条件时再取出正确图片路径 放入src属性</p><h3 id="bootstrap-js插件"><a href="#bootstrap-js插件" class="headerlink" title="bootstrap js插件"></a>bootstrap js插件</h3><p><a href="https://v3.bootcss.com/javascript/" target="_blank" rel="noopener">bootstrap插件库</a></p><h3 id="fullpage全屏滚动插件"><a href="#fullpage全屏滚动插件" class="headerlink" title="fullpage全屏滚动插件"></a>fullpage全屏滚动插件</h3><p><a href="http://www.jq22.com/jquery-info1124" target="_blank" rel="noopener">全屏滚动插件</a></p><h1 id="补充方法"><a href="#补充方法" class="headerlink" title="补充方法"></a>补充方法</h1><h2 id="jquery对象拷贝"><a href="#jquery对象拷贝" class="headerlink" title="jquery对象拷贝"></a>jquery对象拷贝</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190519/hLnYgBNfzx88.png?imageslim" alt="mark"></p><h2 id="change-事件"><a href="#change-事件" class="headerlink" title="change()事件"></a>change()事件</h2><p>当元素的值发生改变时，会触发 change 事件<br>该事件仅适用于text field，textarea 和 select 元素。<br>当用于 select 元素时，change 事件会在选择状态发生变化时发生。<br>当用于 text field 或 textarea 时，该事件会在元素失去焦点时发生。</p><h2 id="toFixed-2"><a href="#toFixed-2" class="headerlink" title="toFixed(2)"></a>toFixed(2)</h2><p>把数字转换为2位小数</p><h2 id="hover事件"><a href="#hover事件" class="headerlink" title="hover事件"></a>hover事件</h2><p>hover([over,]out) 模仿悬停事件<br>over是鼠标经过的函数，out是鼠标离开的函数<br>如果只写一个函数，鼠标经过和离开都会触发这个函数（可以把toggle函数写在里面）</p><h2 id="end-事件"><a href="#end-事件" class="headerlink" title="end()事件"></a>end()事件</h2><p>改变元素操作对象时会改变this指向，使用end()可以让this指向原来的元素</p><h2 id="index-属性"><a href="#index-属性" class="headerlink" title="index()属性"></a>index()属性</h2><p>获取元素的索引值  li.index()</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery事件</title>
      <link href="/2017/08/02/3.jquery/6.jquery%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/08/02/3.jquery/6.jquery%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h1><h2 id="一次只能注册一个事件"><a href="#一次只能注册一个事件" class="headerlink" title="一次只能注册一个事件"></a>一次只能注册一个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/tkuWFWDp0xEE.png?imageslim" alt="mark"></p><h2 id="链式方式注册多个事件"><a href="#链式方式注册多个事件" class="headerlink" title="链式方式注册多个事件"></a>链式方式注册多个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/1b3U50h2hvKV.png?imageslim" alt="mark"></p><h2 id="on注册"><a href="#on注册" class="headerlink" title="on注册"></a>on注册</h2><p>语法：<code>on(events,[selector],[data],fn)</code></p><h1 id="on的优势"><a href="#on的优势" class="headerlink" title="on的优势"></a>on的优势</h1><h2 id="on可以一次绑定多个事件"><a href="#on可以一次绑定多个事件" class="headerlink" title="on可以一次绑定多个事件"></a>on可以一次绑定多个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/u1GNMuDtDpr7.png?imageslim" alt="mark"><br>如果 多个事件的 事件处理函数一样，还可以这样写：<br>注意多个事件之间加空格<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/2oBPUSugwi6x.png?imageslim" alt="mark"></p><h2 id="on可以实现事件委派"><a href="#on可以实现事件委派" class="headerlink" title="on可以实现事件委派"></a>on可以实现事件委派</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/boxgKT38RLx7.png?imageslim" alt="mark"><br>click是绑定在ul上，但是触发对象是li，this指向li</p><h2 id="on可以给动态创建的元素绑定事件"><a href="#on可以给动态创建的元素绑定事件" class="headerlink" title="on可以给动态创建的元素绑定事件"></a>on可以给动态创建的元素绑定事件</h2><p>给动态创建的元素绑定事件必须用on事件委托</p><p>方法one()类似on，也可以添加事件，但是只会触发一次：$(“div”).one(“click”,function(){})</p><h1 id="off解绑事件"><a href="#off解绑事件" class="headerlink" title="off解绑事件"></a>off解绑事件</h1><h2 id="off"><a href="#off" class="headerlink" title="off()"></a>off()</h2><p>通过on绑定的事件，可以使用off()方法解绑；<br>$(“div”).off()<br>如果括号内为空，会解绑div的所有事件<br>括号里为(“事件类型”)，会解绑div的某个事件<br>$(“ul”).off(“click”,”li”) 解绑事件委托</p><h1 id="自动触发事件"><a href="#自动触发事件" class="headerlink" title="自动触发事件"></a>自动触发事件</h1><h2 id="元素-事件"><a href="#元素-事件" class="headerlink" title="元素.事件()"></a>元素.事件()</h2><p>例如: $(“div”).click()<br>会触发事件冒泡</p><h2 id="元素-trigger-“type”"><a href="#元素-trigger-“type”" class="headerlink" title="元素.trigger(“type”)"></a>元素.trigger(“type”)</h2><p>例如: $(“div”).trigger(“click”)<br>会触发事件冒泡，可以用以下方法阻止事件冒泡<br>        1.e.stopPropagation()<br>        2.return false 在原生js里不能阻止</p><h2 id="元素-triggerHandler-“type”"><a href="#元素-triggerHandler-“type”" class="headerlink" title="元素.triggerHandler(“type”)"></a>元素.triggerHandler(“type”)</h2><p>例如: $(“div”).triggerHandler(“click”)<br>区别：不会触发元素的默认行为，不会触发事件冒泡<br>        例如文本框通过focus事件获取了焦点，会有光标闪烁，但是使用triggerHandler不会有光标闪烁</p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><h2 id="元素-事件-1"><a href="#元素-事件-1" class="headerlink" title="元素.事件()"></a>元素.事件()</h2><p>只要有事件发生就会产生事件对象e<br>element.on(events,[selector],function(e){})<br>    属性：<br>        e.type 事件类型<br>        e.target 触发事件的元素<br>        e.pageX,pageY 鼠标位置<br>    方法：<br>        e.preventDefault() 阻止默认行为<br>        e.stopPropagation() 阻止事件冒泡</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery尺寸和位置操作</title>
      <link href="/2017/08/02/3.jquery/5.jquery%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/02/3.jquery/5.jquery%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="尺寸方法"><a href="#尺寸方法" class="headerlink" title="尺寸方法"></a>尺寸方法</h1><h2 id="width"><a href="#width" class="headerlink" title="width()"></a>width()</h2><p>width</p><h2 id="innerWidth"><a href="#innerWidth" class="headerlink" title="innerWidth()"></a>innerWidth()</h2><p>width+padding</p><h2 id="outerWidth"><a href="#outerWidth" class="headerlink" title="outerWidth()"></a>outerWidth()</h2><p>width+padding+border<br>括号里参数为true时：width+padding+border+margin<br>以上尺寸方法 ：如果括号为空是获取，如果是数字是修改</p><h1 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h1><h2 id="offset"><a href="#offset" class="headerlink" title="offset()"></a>offset()</h2><p>元素距离文档的位置<br>获取：    括号为空时，返回的是对象，包括left和top<br>offset().top 返回距离文档top值<br>offset().left 返回距离文档left值<br>设置： offset({top: 200,left: 100})</p><h2 id="position"><a href="#position" class="headerlink" title="position()"></a>position()</h2><p>元素距离带有定位的父元素的位置<br>只能获取，不能设置偏移</p><h2 id="scrollTop-scrollLeft"><a href="#scrollTop-scrollLeft" class="headerlink" title="scrollTop()/scrollLeft()"></a>scrollTop()/scrollLeft()</h2><p>被卷去的头部/左侧<br>$(window).scrollTop() 页面被卷去的头部<br>$(“html”).scrollTop() 文档被卷去的头部<br>如果要添加动画效果，只能给元素添加，window和document不能添加<br>scrollTop()括号不写内容是获取，写数字是设置</p><h2 id="案例：电梯导航"><a href="#案例：电梯导航" class="headerlink" title="案例：电梯导航"></a>案例：电梯导航</h2><p>1.滚动到一定位置显示隐藏侧边栏<br>2.点击侧边栏 滚动到相应模块<br>3.滚动到某个模块，侧边栏相应模块变色</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery操作</title>
      <link href="/2017/08/02/3.jquery/4.jquery%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/02/3.jquery/4.jquery%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery样式操作"><a href="#jQuery样式操作" class="headerlink" title="jQuery样式操作"></a>jQuery样式操作</h1><h2 id="操作css方法"><a href="#操作css方法" class="headerlink" title="操作css方法"></a>操作css方法</h2><p>$(“div”).css(“属性名”) 不写属性值是获取，返回字符串<br>$(“div”).css(“属性名”,”属性值”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).css(&#123;</span><br><span class="line">属性名:&quot;属性值&quot;,</span><br><span class="line">属性名:&quot;属性值&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>属性值是数字可以不用加引号</p><h2 id="设置类样式方法"><a href="#设置类样式方法" class="headerlink" title="设置类样式方法"></a>设置类样式方法</h2><p>$(“div”).addClass(“类名”)    添加类<br>$(“div”).removeClass(“类名”)    移除类<br>$(“div”).toggleClass(“类名”)    切换类<br>原生js里的div.className = “box”会覆盖原来的类名。jQuery类名操作不会覆盖。</p><h1 id="jquery属性操作"><a href="#jquery属性操作" class="headerlink" title="jquery属性操作"></a>jquery属性操作</h1><h2 id="prop"><a href="#prop" class="headerlink" title="prop()"></a>prop()</h2><p>获取或设置元素固有属性  比如获取checkbox的checked属性<br>$(“div”).prop(“属性名”)            获取属性<br>$(“div”).prop(“属性名”,”属性值”)    设置属性</p><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>获取或设置元素固有属性和自定义属性<br>$(“div”).attr(“属性名”)            获取属性<br>$(“div”).attr(“属性名”,”属性值”)    设置属性</p><h2 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h2><p>数据缓存，存储在元素的内存里，不改变DOM元素的属性<br>$(“div”).data(“属性名”)            获取属性<br>        可以获取h5属性data-index；不用写data-,返回的是数字<br>$(“div”).data(“属性名”,”属性值”)    设置属性</p><h2 id="removeAttr"><a href="#removeAttr" class="headerlink" title="removeAttr()"></a>removeAttr()</h2><p>$(“div”).removeAttr(“属性名”)        移除属性</p><h1 id="jq文本操作"><a href="#jq文本操作" class="headerlink" title="jq文本操作"></a>jq文本操作</h1><h2 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h2><p>获取：括号里不写内容是获取<br>设置：<code>html(&quot;&lt;p&gt;123&lt;/p&gt;&quot;)</code> 括号里可以写html内容</p><h2 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h2><p>不解析html标签，其他和html用法相同</p><h2 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h2><p>操作表单元素文字专用<br>获取： val()  获取到的是字符型<br>设置： val(值)</p><h1 id="jq元素操作"><a href="#jq元素操作" class="headerlink" title="jq元素操作"></a>jq元素操作</h1><h2 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var li = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</span><br><span class="line">var li = html(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>内部添加<br>$(“ul”).append(li);    放到最后面  等价于li.appendTo($(“ul”))<br>$(“ul”).prepend(li);     放到最前面  等价于li.prependTo($(“ul”))<br>外部添加<br>$(“div”).after(p);    放到div后面<br>$(“div”).before(p);     放到div前面</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>$(“ul”).remove()     删除自己<br>$(“ul”).empty()     删除内部的子节点<br>$(“ul”).html(“”)    删除内部的子节点 如果子元素有事件 只是清除元素内容 事件还会保留</p><h2 id="遍历DOM元素"><a href="#遍历DOM元素" class="headerlink" title="遍历DOM元素"></a>遍历DOM元素</h2><p>方法1<br>$(“div”).each(function (i, ele) {<br>    xxx;<br>})<br>里面的回调函数有2个参数：i 是每个元素的索引号; ele 是每个DOM元素对象，不是jquery对象<br>所以要想使用jquery方法，需要给这个dom元素转换为jquery对象  $(ele)<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/C1X5AeFNVALp.png?imageslim" alt="mark"></p><p>方法2<br>$.each(arr,function(i, ele){ })  遍历数据 ele就是arr[i]<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/rtdUGtNRBPrG.png?imageslim" alt="mark"></p><p>案例： 购物车<br>    全选按钮 数量调整 动态计算价格  计算总件数总价（封装函数）  删除商品  选中的商品添加背景</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery简介</title>
      <link href="/2017/08/02/3.jquery/1.jquery%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/08/02/3.jquery/1.jquery%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h1><h2 id="JavaScript库"><a href="#JavaScript库" class="headerlink" title="JavaScript库"></a>JavaScript库</h2><p>即js library，是封装好的方法和函数特定的集合；<br>简单理解就是一个JS文件；<br>jQuery就是属于JS库的一种</p><h2 id="jQuery的概念"><a href="#jQuery的概念" class="headerlink" title="jQuery的概念"></a>jQuery的概念</h2><p>write less, do more<br>封装了JavaScript常用的功能代码<br>jQuery的出现大大提高了JavaScript的开发速度</p><h2 id="jQuery的优点"><a href="#jQuery的优点" class="headerlink" title="jQuery的优点"></a>jQuery的优点</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/Q7ngmOhqkzi6.png?imageslim" alt="Jq的优点"></p><h1 id="jQuery的基本使用"><a href="#jQuery的基本使用" class="headerlink" title="jQuery的基本使用"></a>jQuery的基本使用</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://jquery.com/" target="_blank" rel="noopener">jquery官方网站</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>引入jQuery的js文件</p><h2 id="jQuery入口程序"><a href="#jQuery入口程序" class="headerlink" title="jQuery入口程序"></a>jQuery入口程序</h2><p>写在入口函数里的代码是在DOM元素加载完毕执行，等价于原生js里的DOMContentLoaded</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">代码； //最常用</span><br><span class="line">&#125;);</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">代码；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery的顶级对象"><a href="#jQuery的顶级对象" class="headerlink" title="jQuery的顶级对象$"></a>jQuery的顶级对象$</h2><p>$就是指jQuery，代码里它们可以互相替换  $ = jQuery<br>他们之间的关系，类似于原生js里面的window和无window</p><h2 id="jQuery对象和DOM对象的区别"><a href="#jQuery对象和DOM对象的区别" class="headerlink" title="jQuery对象和DOM对象的区别"></a>jQuery对象和DOM对象的区别</h2><p>用原生js获取的对象就是DOM对象； document.querySeletor(“div”)<br>用jQuery方法获取的对象就是jQuery对象； $(“div”)<br>jquery对象是对DOM对象进行包装后产生的，是伪数组形式；<br>两种对象只能使用各自的属性和方法</p><h2 id="两种对象转换："><a href="#两种对象转换：" class="headerlink" title="两种对象转换："></a>两种对象转换：</h2><p>jq对象转dom对象：  $(“div”)[0] 或者 $(“div”).get(0)<br>dom对象转jq对象：    $(div) 里面的div已经获取到了所以不用加引号</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery动画</title>
      <link href="/2017/08/02/3.jquery/3.jquery%E5%8A%A8%E7%94%BB/"/>
      <url>/2017/08/02/3.jquery/3.jquery%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h1><h2 id="显示隐藏效果"><a href="#显示隐藏效果" class="headerlink" title="显示隐藏效果"></a>显示隐藏效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show([speed],[easing],[fn])显示</span><br><span class="line">hide([speed],[easing],[fn])隐藏</span><br><span class="line">toggle([speed],[easing],[fn])切换</span><br></pre></td></tr></table></figure><h2 id="上拉下拉效果"><a href="#上拉下拉效果" class="headerlink" title="上拉下拉效果"></a>上拉下拉效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slideUp([speed],[easing],[fn])上拉收起</span><br><span class="line">slideDown([speed],[easing],[fn])下拉显示</span><br><span class="line">slideToggle([speed],[easing],[fn]) 切换</span><br></pre></td></tr></table></figure><h2 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fadeIn([speed],[easing],[fn]) 淡入显示</span><br><span class="line">fadeOut([speed],[easing],[fn]) 淡出隐藏</span><br><span class="line">fadeToggle([speed],[easing],[fn])切换</span><br></pre></td></tr></table></figure><p>参数一般省略:<br>speed: 速度 “slow” “normal” “fast” 或者时间 1000<br>easing: 运动曲线，默认是swing中间较快,可选linear匀速；<br>可以使用jquery.easing.min.js添加其他的运动曲线<br>fn: 回调函数  </p><h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h2><p>停止动画排队： 把stop()写在动画效果的前面 如$(“div”).stop().toggle();<br>防止鼠标滑动过快动画一直播放</p><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animate(&#123;样式对象&#125;,[speed],[easing],[fn])</span><br></pre></td></tr></table></figure><p>样式属性名可以不带引号，不支持改变颜色，需要借助插件<br>动画只能给元素添加，不能是document和window<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).animate(&#123; </span><br><span class="line">width: 200,</span><br><span class="line">height: &quot;100%&quot;, </span><br><span class="line">fontSize: &quot;10em&quot;, </span><br><span class="line">borderWidth: 10</span><br><span class="line">&#125;, 1000 );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jq选择器</title>
      <link href="/2017/08/02/3.jquery/2.jquery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2017/08/02/3.jquery/2.jquery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jq选择器"><a href="#jq选择器" class="headerlink" title="jq选择器"></a>jq选择器</h1><p>jq推荐使用双引号””</p><h2 id="jq基础选择器"><a href="#jq基础选择器" class="headerlink" title="jq基础选择器"></a>jq基础选择器</h2><p>$(“div”)          标签选择器<br>$(“.box”)         类名选择器<br>$(“#box”)           id选择器<br>$(“*”)            全选选择器<br>$(“div,p”)        并集选择器</p><h2 id="jq层级选择器"><a href="#jq层级选择器" class="headerlink" title="jq层级选择器"></a>jq层级选择器</h2><p>$(“div&gt;p”)    子元素选择器<br>$(“div p”)    后代选择器</p><h2 id="jq筛选选择器"><a href="#jq筛选选择器" class="headerlink" title="jq筛选选择器"></a>jq筛选选择器</h2><p>$(“li:first”)    选择第一个li元素<br>$(“li:last”)    选择最后一个li元素<br>$(“li:nth-of-type(n)”)    选择第n个li元素<br>$(“li:eq(2)”)    选择索引为2的li元素<br>$(“li:odd”)        选择索引为奇数的li元素<br>$(“li:even”)    选择索引为偶数的li元素</p><h2 id="jq筛选方法"><a href="#jq筛选方法" class="headerlink" title="jq筛选方法"></a>jq筛选方法</h2><p>$(“div”).parent()         选择亲爸爸<br>$(“div”).parents(“.box”)    选择div的父级里类名是box的元素<br>$(“div”).children(“p”)         选择亲儿子p         相当于div&gt;p<br>$(“div”).find(“p”)         选择所有后代里的p    相当于div p<br>$(“div”).siblings(“p”)        选择所有亲兄弟里的p<br>$(“ul li”).eq(0)            选择ul里的第一个li    相当于:eq(0) 更推荐使用<br>$(“div”).next()            选择后面的第一个兄弟<br>$(“div”).nextAll(“p”)        选择后面所有的兄弟p<br>$(“div”).prev()            选择前面的第一个兄弟<br>$(“div”).prevAll(“p”)        选择前面所有的兄弟p<br>$(“div”).hasClass(“类名”)     判断div是否有类名，如果有返回true        </p><h2 id="jq排他思想"><a href="#jq排他思想" class="headerlink" title="jq排他思想"></a>jq排他思想</h2><p>jq里的this写法： $(this)<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/VQ79oXXeoTV0.png?imageslim" alt="mark"></p><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><p>jq会自动遍历jq对象内部的DOM元素，称为隐式迭代</p><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>节省代码量，看起来更优雅<br>上面例子可以用以下一句话写；<br>$(this).css(“background”,”pink”).siblings().css(“background”,””)<br>什么时候可以链式编程：<br>    设置型操作可以一直链式编程；jq的大部分方法都是定义在原型上的，方法执行完返回的原来的对象，this又指回了原来的对象，因此可以链式编程<br>    获取型操作会断链；</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地存储</title>
      <link href="/2017/06/20/2.webAPI/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <url>/2017/06/20/2.webAPI/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-本地存储特性"><a href="#1-本地存储特性" class="headerlink" title="1.本地存储特性"></a>1.本地存储特性</h2><p>数据存储在用户浏览器中（不与服务器打交道）<br>设置读取方便，刷新也不会丢失</p><h2 id="2-window-sessionStorage"><a href="#2-window-sessionStorage" class="headerlink" title="2.window.sessionStorage"></a>2.window.sessionStorage</h2><p>1.生命周期为关闭浏览器窗口<br>2.存储在当前页面内存，只在同一个页面以下数据共享<br>3.以键值对形式存储<br>4.最大5M</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem(<span class="string">'key'</span>,value)</span><br><span class="line">获取： sessionStorage.getItem(<span class="string">'key'</span>)</span><br><span class="line">删除： sessionStorage.removeItem(<span class="string">'key'</span>)</span><br><span class="line">删除所有: sessionStorage.clear()</span><br></pre></td></tr></table></figure><h2 id="3-window-localStorage"><a href="#3-window-localStorage" class="headerlink" title="3.window.localStorage"></a>3.window.localStorage</h2><p>1.存储到本地内存，不同页面也可以数据共享<br>2.最大20M<br>3.生命周期为永久<br>方法和sessionStorage完全类似</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端网页特效案例</title>
      <link href="/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、触屏事件"><a href="#一、触屏事件" class="headerlink" title="一、触屏事件"></a>一、触屏事件</h1><h2 id="1-常见触摸事件"><a href="#1-常见触摸事件" class="headerlink" title="1.常见触摸事件"></a>1.常见触摸事件</h2><p><code>touchstart</code>  手指触摸元素<br><code>touchmove</code> 手指在元素上移动<br><code>touchend</code> 手指不再触摸元素</p><h2 id="2-触摸事件对象"><a href="#2-触摸事件对象" class="headerlink" title="2.触摸事件对象"></a>2.触摸事件对象</h2><p><code>e.touches</code>  正在触摸屏幕的所有手指列表<br><code>e.targetTouches</code> 正在触摸当前dom元素的手指列表<br><code>e.changedTouches</code> 手指状态发生改变的列表 从无到有或者从有到无<br>手指离开屏幕时 touches和targetTouches没有了，但是changedTouches还有<br><code>e.targetTouches[0]</code> 是触摸元素的第一个手指的相关信息 包括坐标,触摸对象等；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.clientX 手指在可视区的X坐标</span><br><span class="line">e.clientY 手指在可视区的Y坐标</span><br><span class="line">e.pageX 手指在页面文档的X坐标</span><br><span class="line">e.pageY 手指在页面文档的Y坐标</span><br><span class="line">e.screenX 手指在手机屏幕的X坐标</span><br><span class="line">e.screenY 手指在手机屏幕的Y坐标</span><br></pre></td></tr></table></figure><h1 id="二、移动端轮播图"><a href="#二、移动端轮播图" class="headerlink" title="二、移动端轮播图"></a>二、移动端轮播图</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/HNQ4xw5KAKJR.png?imageslim" alt="Image"></p><h2 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h2><p>（1）搭建结构和样式：ol里面的小圆点不再自动生成，ul不添加定位。因为移动位置是使用translate方法不需要定位。<br>（2）自动轮播功能：使用 定时器+CSS3过渡+translate移动位置；<br>　　　注意无缝滚动功能需要克隆图片，向左滑动功能也需要克隆图片<br>（3）小圆点跟随滚动变化样式： 不再使用排他方法，使用classList操作；也是在过渡结束后圆点才发生变化<br>（4）手指拖动功能： 和手指拖动盒子写法类似<br>（5）判断滑动完播放哪一张图片</p><h2 id="2-新知识"><a href="#2-新知识" class="headerlink" title="2.新知识"></a>2.新知识</h2><p>transitionend事件 过渡结束<br><code>element.classList</code> 返回元素的类名 伪数组形式<br><code>div.classList.add(&#39;类名&#39;)</code> 给div追加一个新类名<br>　　　不会覆盖以前的类<br>　　　一次只能添加一个类名，注意不加.<br><code>div.classList.remove(&#39;类名&#39;)</code> div删除一个类名<br><code>div.classList.toggle(&#39;类名&#39;)</code> 切换类名<br>　　　自动检测，如果有此类则去掉，如果没有则加上；<br><code>div.classList.item(索引)</code>  获取div的第n个类名<br><code>div.classList.contains(&#39;类名&#39;)</code> 判断是否有这个类名<br>　　　如果有返回true 没有返回false</p><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3.源码"></a>3.源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">'.focus'</span>);</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.querySelector(<span class="string">'ol'</span>);</span><br><span class="line">    <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.自动播放功能</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">        ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">        ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">//无缝滚动，判断条件在每次播放完成之后再检测，需要使用transitionend事件</span></span><br><span class="line">    ul.addEventListener(<span class="string">'transitionend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//播放到最后一张或再往后时跳到图1</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//无过渡的跳到第一张，因此先去掉过渡</span></span><br><span class="line">            ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">            <span class="comment">//直接跳到第一张</span></span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果拖动到最左边的图3(索引是负数),跳到索引是2的图3位置</span></span><br><span class="line">        <span class="comment">//---目前不会出现索引负数，等下面添加了手指滑动事件才有可能出现</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">2</span>;</span><br><span class="line">            ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.小圆点跟随变化功能</span></span><br><span class="line">        <span class="comment">// 也要写在transitionend里面，因为是每次滚动完一张小圆点发生变化</span></span><br><span class="line">        <span class="comment">// 选出带current类名的圆点，去掉类名</span></span><br><span class="line">        ol.querySelector(<span class="string">'.current'</span>).classList.remove(<span class="string">'current'</span>);</span><br><span class="line">        <span class="comment">//滚动到的那一张（即index）的小圆圈加上类名  </span></span><br><span class="line">        <span class="comment">//小圆圈索引是0-2 index在这里的取值也被限制为0-2</span></span><br><span class="line">        ol.children[index].classList.add(<span class="string">'current'</span>);</span><br><span class="line">        <span class="comment">//可以加上过渡效果更美观，在css里设置</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.手指滑动功能</span></span><br><span class="line">    <span class="keyword">var</span> startX = <span class="number">0</span>; <span class="comment">//手指初始坐标</span></span><br><span class="line">    <span class="keyword">var</span> moveX = <span class="number">0</span>; <span class="comment">//手指移动距离</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>; <span class="comment">//判断手指是否移动的变量</span></span><br><span class="line">    ul.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        startX = e.targetTouches[<span class="number">0</span>].pageX;</span><br><span class="line">        <span class="comment">//手指触摸停止定时器</span></span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    ul.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        moveX = e.targetTouches[<span class="number">0</span>].pageX - startX;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动ul:  ul原来位置+移动距离</span></span><br><span class="line">        <span class="keyword">var</span> x = -index * focusWidth + moveX;</span><br><span class="line">        ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">        ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手指移动过，设flag为true</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//判断滑动完播放哪一张图片</span></span><br><span class="line">    ul.addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//用户有可能只是单击后松手，也会触发touchend事件，但是此时没有移动，判断moveX没有意义，所以设置flag判断用户是否移动了手指，如果移动了再判断moveX</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//移动超过50像素，就切换图片</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(moveX) &gt; <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="comment">// 右划播放上一张，左滑播放下一张</span></span><br><span class="line">                <span class="keyword">if</span> (moveX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    index--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moveX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断完后移动距离</span></span><br><span class="line">                <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">                ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">                ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不超过50像素，回弹到原来位置</span></span><br><span class="line">                <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">                ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">                ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手指离开重新开始定时器，先清除，保证只有一个定时器</span></span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">        &#125;, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、移动端返回顶部"><a href="#三、移动端返回顶部" class="headerlink" title="三、移动端返回顶部"></a>三、移动端返回顶部</h1><p>和PC端写法一样</p><h1 id="四、移动端click延时问题"><a href="#四、移动端click延时问题" class="headerlink" title="四、移动端click延时问题"></a>四、移动端click延时问题</h1><p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面；<br>解决方案：<br>1.禁用缩放 user-scalable=no 禁止双击缩放<br>2.自己封装函数判断是否是点击事件<br>3.使用fastclick插件</p><h1 id="五、移动端插件"><a href="#五、移动端插件" class="headerlink" title="五、移动端插件"></a>五、移动端插件</h1><h2 id="1-swiper插件-轮播图插件"><a href="#1-swiper插件-轮播图插件" class="headerlink" title="1.swiper插件 轮播图插件"></a>1.swiper插件 轮播图插件</h2><p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a><br>1.引入swiper.min.css文件和swiper.min.js<br>2.在demo文件夹找到想要的轮播图效果，去对应的源代码里复制html和样式<br>3.复制swiperjs代码</p><h2 id="2-superslide插件"><a href="#2-superslide插件" class="headerlink" title="2.superslide插件"></a>2.superslide插件</h2><p><a href="http://www.superslide2.com/" target="_blank" rel="noopener">http://www.superslide2.com/</a></p><h2 id="3-iscroll滚动弹回插件"><a href="#3-iscroll滚动弹回插件" class="headerlink" title="3.iscroll滚动弹回插件"></a>3.iscroll滚动弹回插件</h2><p><a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">https://github.com/cubiq/iscroll</a></p><h2 id="4-zy-media-js移动端视频插件"><a href="#4-zy-media-js移动端视频插件" class="headerlink" title="4.zy.media.js移动端视频插件"></a>4.zy.media.js移动端视频插件</h2><h2 id="5-插件使用总结："><a href="#5-插件使用总结：" class="headerlink" title="5.插件使用总结："></a>5.插件使用总结：</h2><pre><code>1.确认插件实现的功能2.去官网查看使用说明3.下载插件4.打开demo实例文件，查看需要引入的相关文件，并且引入5.复制demo实例文件中的结构html，样式css以及js代码</code></pre><h1 id="六、移动端常用开发框架"><a href="#六、移动端常用开发框架" class="headerlink" title="六、移动端常用开发框架"></a>六、移动端常用开发框架</h1><p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p><p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。<br>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端<br>前端常用的移动端插件有 swiper、superslide、iscroll等。<br>框架： 大而全，一整套解决方案<br>插件： 小而专一，某个功能的解决方案<br>bootstrap轮播图<br>1.引入jquery.min.js文件和bootstrap.min.js<br>2.引入bootstrap.min.css<br>3.把html代码复制进focus盒子里，更改图片</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC端网页特效案例</title>
      <link href="/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、网页轮播图"><a href="#一、网页轮播图" class="headerlink" title="一、网页轮播图"></a>一、网页轮播图</h1><h2 id="1-结构搭建"><a href="#1-结构搭建" class="headerlink" title="1.结构搭建"></a>1.结构搭建</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/W0D7LIbLoYmb.png?imageslim" alt="Image">    </p><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h2><p>动态设置ul的宽度<br>1）鼠标经过轮播图区域左右箭头才显示<br>2）动态生成小圆圈<br>3）点击小圆圈切换图片 配合animate函数<br>    - 变量index 是点击时小圆圈的索引号<br>4）点击方向箭头切换图片，小圆圈也跟着变化<br>    - 变量num 控制箭头切换图片<br>    - 变量circle 是小圆圈跟随变化新的索引号<br>    - 克隆最后一张图实现无缝滚动<br>5）自动播放：<br>定时器 + 手动调用点击事件 arrowr.click();<br>鼠标经过停止定时器<br>6）添加节流阀：<br>防止轮播图按钮连续点击造成播放过快。<br>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。<br>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<br>开始设置一个变量<code>var flag= true;</code><br><code>If(flag){flag = false; do something}       关闭水龙头</code><br><code>利用回调函数动画执行完毕， flag = true     打开水龙头</code></p><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3.源码"></a>3.源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">'.focus'</span>);</span><br><span class="line">    <span class="keyword">var</span> arrowl = <span class="built_in">document</span>.querySelector(<span class="string">'.arrow-l'</span>);</span><br><span class="line">    <span class="keyword">var</span> arrowr = <span class="built_in">document</span>.querySelector(<span class="string">'.arrow-r'</span>);</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    <span class="keyword">var</span> imglis = ul.children;</span><br><span class="line">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.querySelector(<span class="string">'ol'</span>);</span><br><span class="line">    <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示隐藏功能</span></span><br><span class="line">    focus.addEventListener(<span class="string">'mouseenter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowl.style.display = <span class="string">'block'</span>;</span><br><span class="line">        arrowr.style.display = <span class="string">'block'</span>;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;)</span><br><span class="line">    focus.addEventListener(<span class="string">'mouseleave'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowl.style.display = <span class="string">'none'</span>;</span><br><span class="line">        arrowr.style.display = <span class="string">'none'</span>;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            arrowr.click();</span><br><span class="line">        &#125;, <span class="number">1500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态生成圆圈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imglis.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.setAttribute(<span class="string">'index'</span>, i);</span><br><span class="line">        ol.appendChild(li);</span><br><span class="line">        <span class="comment">//点击圆圈切换图片和圆圈样式</span></span><br><span class="line">        li.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//排他思想设置小圆圈颜色</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> index = <span class="keyword">this</span>.getAttribute(<span class="string">'index'</span>);</span><br><span class="line">            num = index;</span><br><span class="line">            circle = index;</span><br><span class="line">            animate(ul, -index * focusWidth);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ol.children[<span class="number">0</span>].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右按钮功能</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> circle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> lastli = imglis[<span class="number">0</span>].cloneNode(<span class="literal">true</span>);</span><br><span class="line">    ul.appendChild(lastli);</span><br><span class="line"></span><br><span class="line">    arrowr.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == ul.children.length - <span class="number">1</span>) &#123;</span><br><span class="line">                ul.style.left = <span class="number">0</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            circle++;</span><br><span class="line">            <span class="keyword">if</span> (circle == ol.children.length) &#123;</span><br><span class="line">                circle = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ol.children[circle].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//左按钮功能</span></span><br><span class="line">    arrowl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                ul.style.left = -focusWidth * (ul.children.length - <span class="number">1</span>) + <span class="string">'px'</span>;</span><br><span class="line">                num = ul.children.length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            circle--;</span><br><span class="line">            <span class="keyword">if</span> (circle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                circle = ol.children.length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ol.children[circle].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//自动轮播定时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowr.click();</span><br><span class="line">    &#125;, <span class="number">1500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="二、返回顶部案例"><a href="#二、返回顶部案例" class="headerlink" title="二、返回顶部案例"></a>二、返回顶部案例</h1><h2 id="1-窗口滚动事件"><a href="#1-窗口滚动事件" class="headerlink" title="1.窗口滚动事件"></a>1.窗口滚动事件</h2><p><code>window.scroll(x,y);</code>  使窗口滚动到某个坐标，x和y不写单位<br><code>window.pageYOffset</code> 是页面被卷去的头部  IE9 以上兼容</p><h2 id="2-思想"><a href="#2-思想" class="headerlink" title="2.思想"></a>2.思想</h2><p>修改animate函数来实现缓慢滚动到顶部</p><h1 id="三、筋斗云案例"><a href="#三、筋斗云案例" class="headerlink" title="三、筋斗云案例"></a>三、筋斗云案例</h1><p>利用animate函数 记录点击的位置，作为下一次移动的起点</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js动画函数</title>
      <link href="/2017/06/20/2.webAPI/BOM/5.JS%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2017/06/20/2.webAPI/BOM/5.JS%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、动画实现原理"><a href="#一、动画实现原理" class="headerlink" title="一、动画实现原理"></a>一、动画实现原理</h1><h2 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1.核心原理"></a>1.核心原理</h2><p>通过定时器 setInterval() 不断移动盒子位置</p><h2 id="2-实现步骤："><a href="#2-实现步骤：" class="headerlink" title="2.实现步骤："></a>2.实现步骤：</h2><p>1.获得盒子当前位置<br>2.让盒子在当前位置加上1个移动距离<br>3.利用定时器不断重复这个操作<br>4.加一个结束定时器的条件<br>5.注意此元素需要添加定位，才能使用element.style.left</p><h1 id="二、动画函数封装"><a href="#二、动画函数封装" class="headerlink" title="二、动画函数封装"></a>二、动画函数封装</h1><h2 id="1-封装函数"><a href="#1-封装函数" class="headerlink" title="1.封装函数"></a>1.封装函数</h2><p>把动画封装进一个函数，传的参数是 obj调用对象 和 target动画结束条件</p><h2 id="2-给不同元素添加不同定时器"><a href="#2-给不同元素添加不同定时器" class="headerlink" title="2.给不同元素添加不同定时器"></a>2.给不同元素添加不同定时器</h2><p>可以减少内存占用<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/YglwUtGXe9NJ.png?imageslim" alt="Image"><br>把var timer 改成 obj.timer，这样每个调用函数的元素都有了自己的定时器</p><h1 id="三、缓动动画"><a href="#三、缓动动画" class="headerlink" title="三、缓动动画"></a>三、缓动动画</h1><h2 id="1-核心原理-1"><a href="#1-核心原理-1" class="headerlink" title="1.核心原理"></a>1.核心原理</h2><p>缓动：运动速度慢慢变小，实现缓慢停下来的效果<br>让盒子每次移动的距离慢慢变小： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">step = (目标位置-现在位置) / <span class="number">10</span>;</span><br><span class="line">step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br></pre></td></tr></table></figure><p>步长如果是正值向上取值，如果是负值向下取整<br>封装的缓动动画用于轮播图案例里 实现图片滚动效果</p><h2 id="2-缓动动画添加回调函数"><a href="#2-缓动动画添加回调函数" class="headerlink" title="2.缓动动画添加回调函数"></a>2.缓动动画添加回调函数</h2><p>回调函数原理： 把函数P当做一个参数传递到另外一个函数fn里，当fn全部执行完毕之后才会执行此函数P，这个过程称为回调<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/jUee2pFPX7fm.png?imageslim" alt="Image"><br>根据定义 定时器全部执行完才执行回调函数，因此回调函数写在定时器结束时。如果有回调函数 则调用此函数；</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的执行机制</title>
      <link href="/2017/06/20/2.webAPI/BOM/4.JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/06/20/2.webAPI/BOM/4.JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>JS执行机制</p><h1 id="一、JS是单线程"><a href="#一、JS是单线程" class="headerlink" title="一、JS是单线程"></a>一、JS是单线程</h1><p>js代码是从上往下执行，同一时间只能做一件事,称为js单线程<br>单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待</p><h1 id="二、同步和异步"><a href="#二、同步和异步" class="headerlink" title="二、同步和异步"></a>二、同步和异步</h1><p>HTML5提出了同步任务和异步任务的概念</p><h2 id="1-同步任务"><a href="#1-同步任务" class="headerlink" title="1.同步任务"></a>1.同步任务</h2><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 形成执行栈    </p><h2 id="2-异步任务"><a href="#2-异步任务" class="headerlink" title="2.异步任务"></a>2.异步任务</h2><p>不进入主线程、而进入‘任务队列’的任务，当主线程中的任务运行完了，才会从‘任务队列’取出异步任务放入主线程执行。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/9EutwcwXfKh9.png?imageslim" alt="Image">     </p><h1 id="三、JS事件循环"><a href="#三、JS事件循环" class="headerlink" title="三、JS事件循环"></a>三、JS事件循环</h1><p>主线程执行完毕，查询任务队列，取出一个任务推入主线程运行；反复以上过程称为事件循环<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/PJywDry0ayyb.png?imageslim" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM三大系列</title>
      <link href="/2017/06/20/2.webAPI/BOM/3.BOM%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97/"/>
      <url>/2017/06/20/2.webAPI/BOM/3.BOM%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、offset系列"><a href="#一、offset系列" class="headerlink" title="一、offset系列"></a>一、offset系列</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>元素偏移量 动态获得元素在网页中的位置或大小，返回数值没有单位；</p><h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/afM5Jis7SW4l.png?imageslim" alt="Image"></p><p>offsetTop和offsetLeft以带有定位的父元素为准，如果没有父亲或者父亲没有定位，则以Body为准</p><h2 id="3-offset和style的区别"><a href="#3-offset和style的区别" class="headerlink" title="3.offset和style的区别"></a>3.offset和style的区别</h2><p>style只能获得行内样式表的样式值，offset所有样式写法都可以获得。<br>style获得的left和top是带有单位的字符串，offsetLeft和Top获得不带单位的数值<br>style不包含padding和border，offset包含padding和border<br>style可以读写，而offset是只读属性<br>获取元素的大小位置用offset，更改元素的大小位置用style</p><p><strong>案例：</strong><br>1.拖拽的模态框<br>2.京东放大镜：</p><p>鼠标经过小图片盒子，蒙层和大图片盒子显示，离开隐藏<br>蒙层跟随鼠标，且不超出小盒子<br>移动蒙层时大图片等比例移动</p><p>求大图移动距离的公式：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/lNwrKcSMpc0i.png?imageslim" alt="Image"></p><p>如果大图片和蒙层都是正方形，只要计算一个比例，如果不是正方形要计算宽和高两个比例</p><h1 id="二、client系列"><a href="#二、client系列" class="headerlink" title="二、client系列"></a>二、client系列</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p>获取元素可视区的相关信息</p><h2 id="2-client系列属性"><a href="#2-client系列属性" class="headerlink" title="2.client系列属性"></a>2.client系列属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/PDunjAa9uFk0.png?imagesli" alt="Image"><br>和offsetWidth唯一的区别是clientWidth不包含边框</p><h1 id="三、scroll系列"><a href="#三、scroll系列" class="headerlink" title="三、scroll系列"></a>三、scroll系列</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h2><p>scroll 系列的相关属性可以动态的得到该元素内容的实际大小、滚动距离</p><h2 id="2-scroll系列属性"><a href="#2-scroll系列属性" class="headerlink" title="2.scroll系列属性"></a>2.scroll系列属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/5c6pP1s7kk2x.png?imageslim" alt="Image"><br>scrollTop和scrollHeight 常用<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/KUMH12U4SN3f.png?imageslim" alt="Image">                        </p><h2 id="3-scroll事件"><a href="#3-scroll事件" class="headerlink" title="3.scroll事件"></a>3.scroll事件</h2><p><code>scroll</code> 滚动事件 只要滚动就会触发<br><code>window.pageYOffset</code> 是页面被卷去的头部  IE9 以上兼容<br><code>window.pageXOffset</code> 是页面被卷去的左侧  IE9 以上兼容<br><code>元素.scrollTop</code> 是元素被卷去的头部<br><code>元素.scrollLeft</code> 是元素被卷去的左侧</p><p>案例： 随着页面滚动，侧边栏发生变化</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM三大对象</title>
      <link href="/2017/06/20/2.webAPI/BOM/2.BOM%E4%B8%89%E5%A4%A7%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/06/20/2.webAPI/BOM/2.BOM%E4%B8%89%E5%A4%A7%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、location对象"><a href="#一、location对象" class="headerlink" title="一、location对象"></a>一、location对象</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><pre><code>window的location属性用于获取或设置窗体的URL，返回的是一个对象</code></pre><h2 id="2-URL"><a href="#2-URL" class="headerlink" title="2.URL"></a>2.URL</h2><p>统一资源定位符 格式：<br><code>protocol://host[:port]/path/[?query]#fragment</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/mNM8pYKkq7kw.png?imageslim" alt="Image"></p><h2 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h2><p>重点记住href和search<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/XwqIcSj9HHSV.png?imageslim" alt="Image"></p><h2 id="4-方法"><a href="#4-方法" class="headerlink" title="4.方法"></a>4.方法</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/nRL0iMQ2eij2.png?imageslim" alt="Image">    </p><h1 id="二、navigator对象"><a href="#二、navigator对象" class="headerlink" title="二、navigator对象"></a>二、navigator对象</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>包含浏览器相关信息</p><h2 id="2-常用属性"><a href="#2-常用属性" class="headerlink" title="2.常用属性"></a>2.常用属性</h2><p>navigator.userAgent<br>前端也可以判断访问类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">"手机链接"</span>;     </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">"PC链接"</span>;     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="三、history对象"><a href="#三、history对象" class="headerlink" title="三、history对象"></a>三、history对象</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p>window对象给我们提供了一个history对象，与浏览器历史记录进行交互。<br>该对象包含浏览器访问过的URL</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/f649lwXnB1NV.png?imageslim" alt="Image">        </p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM介绍和常用事件</title>
      <link href="/2017/06/20/2.webAPI/BOM/1.BOM%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/06/20/2.webAPI/BOM/1.BOM%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、BOM概述"><a href="#一、BOM概述" class="headerlink" title="一、BOM概述"></a>一、BOM概述</h1><h2 id="1-什么是BOM"><a href="#1-什么是BOM" class="headerlink" title="1.什么是BOM"></a>1.什么是BOM</h2><p>浏览器对象模型，提供了与浏览器窗口进行交互的对象<br>BOM的核心对象是window<br>BOM是非标准的，兼容性较差，不同浏览器厂商的BOM可能不同</p><h2 id="2-BOM的构成"><a href="#2-BOM的构成" class="headerlink" title="2.BOM的构成"></a>2.BOM的构成</h2><p>BOM包含DOM<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/ShyMnvO6msYS.png?imageslim" alt="Image">    </p><h2 id="3-window对象"><a href="#3-window对象" class="headerlink" title="3.window对象"></a>3.window对象</h2><p>window是浏览器的顶级对象，是一个全局对象；<br>全局变量和方法都可以被window调用，直接调用时相当于省略了window<br>window有一个特殊属性<code>window.name</code></p><h1 id="二、window对象常见事件"><a href="#二、window对象常见事件" class="headerlink" title="二、window对象常见事件"></a>二、window对象常见事件</h1><p>以下事件都有两种添加方式,带on和不带on</p><h2 id="1-窗口加载事件"><a href="#1-窗口加载事件" class="headerlink" title="1.窗口加载事件"></a>1.窗口加载事件</h2><pre><code>load </code></pre><p>整个页面全部加载完才执行里面的代码，可以利用此事件把js代码放到任意位置<br>传统方式只能写一次，addEventListener()可以写多个</p><pre><code>DOMContentLoaded</code></pre><p>DOM元素加载完就执行代码，不包括图片文字css等元素，加载速度更快</p><h2 id="2-调整窗口大小事件"><a href="#2-调整窗口大小事件" class="headerlink" title="2.调整窗口大小事件"></a>2.调整窗口大小事件</h2><p><code>resize</code> 浏览器窗口大小发生变化就会触发事件<br><code>window.innerWidth</code> 当前浏览器窗口宽度<br><code>window.innerHeight</code> 当前浏览器窗口高度</p><h1 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h1><h2 id="1-setTimeout延时器"><a href="#1-setTimeout延时器" class="headerlink" title="1.setTimeout延时器"></a>1.setTimeout延时器</h2><pre><code>window.setTimeout(调用函数, 延迟毫秒数)</code></pre><p>延迟一段时间后开始执行函数，只执行一次<br>window一般省略<br>调用函数可以写函数名或整个函数<br>延迟毫秒数如果省略是0立即执行<br>页面中可能有很多定时器，需要给定时器起名字区分</p><h2 id="2-setInterval定时器"><a href="#2-setInterval定时器" class="headerlink" title="2.setInterval定时器"></a>2.setInterval定时器</h2><pre><code>setInterval(调用函数, 间隔毫秒数)</code></pre><p>间隔多少时间重复执行 第一次调用也会有延迟时间，可以先调用一次函数 再定时</p><h2 id="3-停止定时器"><a href="#3-停止定时器" class="headerlink" title="3.停止定时器"></a>3.停止定时器</h2><pre><code>clearTimeout(定时器名字);clearInterval(定时器名字);</code></pre><h1 id="四、this指向问题"><a href="#四、this指向问题" class="headerlink" title="四、this指向问题"></a>四、this指向问题</h1><p>this的指向在函数执行时才能确定，一般指向调用函数的对象<br>全局作用域下、或者普通函数中this永远指向window（注意定时器里面的this指向window）；<br>方法/事件调用中 this指向方法/事件的调用者；<br>构造函数中 this指向函数的实例对象</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用鼠标和键盘事件</title>
      <link href="/2017/06/20/2.webAPI/DOM/9.%E5%B8%B8%E7%94%A8%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/06/20/2.webAPI/DOM/9.%E5%B8%B8%E7%94%A8%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用鼠标事件："><a href="#1-常用鼠标事件：" class="headerlink" title="1.常用鼠标事件："></a>1.常用鼠标事件：</h2><pre><code>click 点击  focus 获得焦点  blur 失去焦点 mouseover 鼠标经过mouseout 鼠标离开mouseenter 鼠标经过（不冒泡）mouseleave 鼠标离开（不冒泡）mousemove 鼠标移动 只要移动鼠标就会触发事件contextmenu 右键菜单 阻止默认行为可以禁用右键菜单selectstart 鼠标开始选中 阻止默认行为可以禁止选中文字</code></pre><h2 id="2-鼠标事件对象："><a href="#2-鼠标事件对象：" class="headerlink" title="2.鼠标事件对象："></a>2.鼠标事件对象：</h2><pre><code>e.clientX 鼠标在可视区的X坐标e.clientY 鼠标在可视区的Y坐标e.pageX 鼠标在页面文档的X坐标e.pageY 鼠标在页面文档的Y坐标e.screenX 鼠标在电脑屏幕的X坐标e.screenY 鼠标在电脑屏幕的Y坐标</code></pre><h2 id="3-常用键盘事件"><a href="#3-常用键盘事件" class="headerlink" title="3.常用键盘事件"></a>3.常用键盘事件</h2><pre><code>keyup     键盘弹起触发keydown     键盘按下触发 keypress     键盘按下触发 不识别功能键如ctrl shift 方向键等        </code></pre><p>如果三个事件都存在，执行顺序： 先keydown – keypress –keyup后</p><h2 id="4-键盘事件对象"><a href="#4-键盘事件对象" class="headerlink" title="4.键盘事件对象"></a>4.键盘事件对象</h2><pre><code>e.keyCode 返回该键的ASCII码值 </code></pre><p>keyup和keydown不区分字母大小写 a和A都是65<br>keypress区分大小写</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件高级</title>
      <link href="/2017/06/20/2.webAPI/DOM/8.%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
      <url>/2017/06/20/2.webAPI/DOM/8.%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、传统操作事件"><a href="#一、传统操作事件" class="headerlink" title="一、传统操作事件"></a>一、传统操作事件</h1><h2 id="1-传统方式注册"><a href="#1-传统方式注册" class="headerlink" title="1.传统方式注册"></a>1.传统方式注册</h2><p>行内注册<code>&lt;button onclick = &#39;alert(&#39;hello&#39;)&#39;&gt;点击&lt;/button&gt;</code><br>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.querySelector(&apos;button&apos;);</span><br><span class="line">btn.onclick = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><p>特点：同一个事件只能注册一个监听器(即回调函数)</p><h2 id="2-传统方式删除"><a href="#2-传统方式删除" class="headerlink" title="2.传统方式删除"></a>2.传统方式删除</h2><p>元素.onclick = null;<br>或者把function设置为null</p><h1 id="二、方法监听操作事件"><a href="#二、方法监听操作事件" class="headerlink" title="二、方法监听操作事件"></a>二、方法监听操作事件</h1><h2 id="1-方法监听注册"><a href="#1-方法监听注册" class="headerlink" title="1.方法监听注册"></a>1.方法监听注册</h2><pre><code>元素.addEventListener(&apos;事件类型&apos;,监听器,[第三个参数]);</code></pre><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">alert(&apos;hello&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事件类型要加引号，且不带on;<br>同一个元素 同一个事件可以添加多个监听器（事件处理程序）<br>第三个参数下面事件流有解释</p><p>IE9以下用attachEvent(‘事件类型带on’，监听器); 只在IE浏览器有效</p><h2 id="2-方法监听删除"><a href="#2-方法监听删除" class="headerlink" title="2.方法监听删除"></a>2.方法监听删除</h2><pre><code>元素.removeEventListener（&apos;事件类型&apos;,监听器名字 ） </code></pre><p>要写函数名字所以要把函数单独声明，删除时不带()</p><p>IE9以下使用 detachEvent(‘onclick’,fn)</p><h1 id="三、DOM事件流"><a href="#三、DOM事件流" class="headerlink" title="三、DOM事件流"></a>三、DOM事件流</h1><h2 id="1-事件流定义"><a href="#1-事件流定义" class="headerlink" title="1.事件流定义"></a>1.事件流定义</h2><p>js代码只能执行捕获或冒泡其中一个阶段<br>传统的添加事件方法onclick、attachEvent只能获取冒泡阶段，看不到捕获状态<br>addEventListener第三个参数如果为true是捕获阶段，为false或省略是冒泡阶段<br>有的事件是没有冒泡的如blur focus mouseenter mouseleave<br>当处于目标阶段时，捕获和冒泡按照代码书写顺序执行，不一定是先捕获再冒泡<br>事件流和位置没有关系，只要有嵌套都会传播事件</p><h1 id="四、事件对象-事件源参数"><a href="#四、事件对象-事件源参数" class="headerlink" title="四、事件对象(事件源参数)"></a>四、事件对象(事件源参数)</h1><p>可以自己定义名称event、evt、e<br>事件对象写在侦听器的小括号里，当形参来看；<br>有事件就存在事件对象，不需要传递参数，系统自动创建；<br>包含了事件相关的信息集合，如鼠标事件集合、键盘事件集合<br>IE678只兼容window.event，兼容性处理： e = e || window.event</p><h2 id="1-事件对象常见的属性"><a href="#1-事件对象常见的属性" class="headerlink" title="1.事件对象常见的属性"></a>1.事件对象常见的属性</h2><p><code>e.target</code> 返回触发事件的对象  和this的区别：this是返回绑定事件的对象<br><code>e.srcElement</code> IE678兼容 返回触发事件的对象<br><code>e.type</code> 返回事件类型</p><h2 id="2-事件对象常见的方法"><a href="#2-事件对象常见的方法" class="headerlink" title="2.事件对象常见的方法"></a>2.事件对象常见的方法</h2><p><strong>1.阻止默认行为</strong><br>让链接不跳转 让提交按钮不提交<br><code>e.preventDefault();</code> 是方法  标准写法 不支持ie678<br><code>return false; return</code>后面代码不执行 仅限于传统注册方式<br><code>e.returnValue;</code> 是属性  非标准 ie678使用<br><strong>2.阻止冒泡</strong><br><code>e.stopPropagtion();</code> 写在哪里从哪个元素开始不再冒泡</p><p>事件冒泡的应用：事件委托<br>原理：把事件注册给父元素，利用冒泡原理，子元素冒泡到父元素上，减少dom操作次数提高性能</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点和节点操作</title>
      <link href="/2017/06/20/2.webAPI/DOM/7.%E8%8A%82%E7%82%B9%E5%92%8C%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/20/2.webAPI/DOM/7.%E8%8A%82%E7%82%B9%E5%92%8C%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么学节点操作"><a href="#一、为什么学节点操作" class="headerlink" title="一、为什么学节点操作"></a>一、为什么学节点操作</h1><p>利用节点间的关系获取元素更简单，逻辑性比较强</p><h1 id="二、节点概述"><a href="#二、节点概述" class="headerlink" title="二、节点概述"></a>二、节点概述</h1><h2 id="1-什么是节点"><a href="#1-什么是节点" class="headerlink" title="1.什么是节点"></a>1.什么是节点</h2><p>网页中所有内容（属性、文本、元素等）都是节点，在DOM中用node表示</p><h2 id="2-节点属性和分类"><a href="#2-节点属性和分类" class="headerlink" title="2.节点属性和分类"></a>2.节点属性和分类</h2><p>nodeType节点类型 元素节点是1  属性节点是2 文本节点是3<br>nodeName节点名称<br>nodeValue节点值<br>我们主要操作的是<strong>元素节点</strong></p><h1 id="三、节点层级"><a href="#三、节点层级" class="headerlink" title="三、节点层级"></a>三、节点层级</h1><p>如果没有找到节点返回null</p><h2 id="1-父节点"><a href="#1-父节点" class="headerlink" title="1.父节点"></a>1.父节点</h2><pre><code>element.parentNode</code></pre><p>得到离元素最近的父亲节点（亲爸爸）</p><h2 id="2-子节点"><a href="#2-子节点" class="headerlink" title="2.子节点"></a>2.子节点</h2><pre><code>element.childNodes 得到所有子节点的集合，包括所有节点类型，不提倡使用element.children 得到子元素节点的集合，只获得元素节点，实际常用element.firstChild 得到第一个子节点 .lastChild 得到最后一个子节点element.firstElementChild 得到第一个子元素节点  IE9以上支持element.lastElementChild 得到第一个子元素节点 IE9以上支持</code></pre><p>实际开发使用children加索引号选择first和last，既没有兼容性问题又能选择元素节点<br>        如第一个ul.children[0]<br>        最后一个ul.children[ul.children.length-1]</p><h2 id="3-兄弟节点-使用较少"><a href="#3-兄弟节点-使用较少" class="headerlink" title="3.兄弟节点 使用较少"></a>3.兄弟节点 使用较少</h2><pre><code>node.nextSibling 下一个兄弟节点 包括所有类型node.previousSibling 上一个兄弟节点 包括所有类型node.nextElementSibling 下一个兄弟元素节点 IE9以上支持node.previousElementSibling 上一个兄弟元素节点 IE9以上支持</code></pre><h1 id="四、节点操作"><a href="#四、节点操作" class="headerlink" title="四、节点操作"></a>四、节点操作</h1><h2 id="1-创建节点"><a href="#1-创建节点" class="headerlink" title="1.创建节点"></a>1.创建节点</h2><pre><code>document.createElement(&apos;标签名&apos;)</code></pre><p>创建完要添加才能看到</p><h2 id="2-添加节点"><a href="#2-添加节点" class="headerlink" title="2.添加节点"></a>2.添加节点</h2><pre><code>父节点.appendChild(子节点)  </code></pre><p>添加的子节点是放在父亲的末尾</p><pre><code>父节点.insertBefore(&apos;要插入的节点&apos;, 子节点) </code></pre><p>添加在某个子节点之前</p><h2 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.删除节点"></a>3.删除节点</h2><pre><code>父节点.removeChild(子节点)</code></pre><h2 id="4-克隆节点"><a href="#4-克隆节点" class="headerlink" title="4.克隆节点"></a>4.克隆节点</h2><pre><code>node.cloneNode(参数) 得到node的克隆节点</code></pre><p>参数：true 表示完全克隆，默认false 只克隆元素标签  </p><h1 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h1><p>创建多个元素时<br><code>document.write(&#39;&lt;p&gt;&lt;/p&gt;&#39;)</code>直接将内容写入页面的内容流，但是页面加载完毕会导致页面重绘<br><code>innerHTML</code>拼接字符串时，效率比较低，采取数组形式效率很高但是结构较复杂<br><code>createElement(&#39;p&#39;)</code>创建多个元素效率稍低，但是结构更清晰</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义属性</title>
      <link href="/2017/06/20/2.webAPI/DOM/6.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/06/20/2.webAPI/DOM/6.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义属性操作"><a href="#自定义属性操作" class="headerlink" title="自定义属性操作"></a>自定义属性操作</h2><p>自定义属性是程序员自己创建的属性</p><h3 id="1）获取属性值有两种方法："><a href="#1）获取属性值有两种方法：" class="headerlink" title="1）获取属性值有两种方法："></a>1）获取属性值有两种方法：</h3><pre><code>element.属性名  只能获取内置属性element.getAttribute(&apos;属性名&apos;)  还可以获取自定义属性，获取到的是字符型</code></pre><h3 id="2）修改属性值的两种方法："><a href="#2）修改属性值的两种方法：" class="headerlink" title="2）修改属性值的两种方法："></a>2）修改属性值的两种方法：</h3><pre><code>element.属性名 = &apos;属性值&apos;;  只能修改内置属性element.setAttribute(&apos;属性名&apos;,&apos;属性值&apos;);  可以修改自定义属性</code></pre><h3 id="3）移除属性的方法"><a href="#3）移除属性的方法" class="headerlink" title="3）移除属性的方法"></a>3）移除属性的方法</h3><pre><code>element.removeAttribute(&apos;属性名&apos;);</code></pre><h2 id="tab栏切换案例-重要"><a href="#tab栏切换案例-重要" class="headerlink" title="tab栏切换案例 重要"></a>tab栏切换案例 重要</h2><p>设置自定义属性判断用户点了哪一个tab栏</p><h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p>属性有时不好确认是内置属性还是自定义属性；<br>H5规定所有新增的自定义属性命名都由data-开头</p><p>H5新增了获取自定义属性的方法： (IE11以上支持)<br>例如自定义属性是data-index-name，获取时：<code>element.dataset.indexName</code>或<code>element.dataset[&#39;indexName&#39;]</code><br>dataset是一个集合 里面存放了所有以data-开头的自定义属性</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排他思想</title>
      <link href="/2017/06/20/2.webAPI/DOM/5.%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3/"/>
      <url>/2017/06/20/2.webAPI/DOM/5.%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：<br>1.所有元素全部清除样式<br>2.给当前元素设置样式<br>3.注意顺序不能颠倒<br>利用双层for循环<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/izPokjzR8tgX.png?imageslim" alt="Image"></p><p>案例：百度换肤<br>案例：隔行变色<br>案例：全选反选 重点</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="/2017/06/20/2.webAPI/DOM/4.DOM%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/20/2.webAPI/DOM/4.DOM%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-改变元素内容"><a href="#1-改变元素内容" class="headerlink" title="1.改变元素内容"></a>1.改变元素内容</h1><p><code>element.innerText  = 内容;</code><br><code>element.innerHTML  = 内容;</code><br>都可以读写，获取/修改文字内容<br>获取的区别：<br>    <code>innerText 不获取空格 标签 只会获取文本</code><br>    <code>innerHTML 获取空格 标签 和文本</code><br>设置内容时的区别：<br>    <code>innerText 不会解析html标签</code><br>    <code>innerHTML 会解析html标签</code></p><hr><h1 id="2-修改元素属性"><a href="#2-修改元素属性" class="headerlink" title="2.修改元素属性"></a>2.修改元素属性</h1><p><code>element.属性 = 属性值;</code><br>案例： 分时问候</p><hr><h1 id="3-修改表单元素的属性"><a href="#3-修改表单元素的属性" class="headerlink" title="3.修改表单元素的属性"></a>3.修改表单元素的属性</h1><p>修改表单元素里面的内容 是通过改变value属性修改的；<br>其他可以操作的表单属性还有<code>type value checked selected disabled</code><br>使用举例：btn.disabled = true; 表示此按钮被禁用了</p><p>事件下的this指向事件的调用者<br>属性名 = 属性值 js里用true表示 如<code>checked，disabled，selected</code></p><p>案例：密码框文字显示隐藏</p><hr><h1 id="4-修改样式属性"><a href="#4-修改样式属性" class="headerlink" title="4.修改样式属性"></a>4.修改样式属性</h1><h2 id="1）行内样式操作"><a href="#1）行内样式操作" class="headerlink" title="1）行内样式操作"></a>1）行内样式操作</h2><p><code>element.style.属性=&#39;属性值&#39;;</code><br>属性采取驼峰命名法书写，如fontSize,backgroundColor<br>修改完，生成的是行内样式 权重比较高<br>案例：循环精灵图、显示隐藏文本框内容</p><h2 id="2）类名样式操作"><a href="#2）类名样式操作" class="headerlink" title="2）类名样式操作"></a>2）类名样式操作</h2><p><code>element.className = &#39;类名&#39;;</code><br>有很多样式需要修改时，style方式书写较为麻烦，采取类名修改样式属性<br>在css新类里写好要变化的样式，在事件函数里设置<br>        element.className = ‘类名’<br>更改元素的样式<br>*<em>注意: *</em>会覆盖原来的类名，要保留原来的类名需要在两个类之间加空格</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素获取</title>
      <link href="/2017/06/20/2.webAPI/DOM/3.DOM%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96/"/>
      <url>/2017/06/20/2.webAPI/DOM/3.DOM%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p><strong>元素才能使用这些方法</strong></p><h2 id="1-根据id获取"><a href="#1-根据id获取" class="headerlink" title="1.根据id获取"></a>1.根据id获取</h2><p><code>document.getElementById(&quot;id值&quot;)</code><br>id加引号 区分大小写<br>只能是document<br>返回的是DOM的元素对象,类型是object<br>console.dir(元素);可以查看元素对象的详细信息</p><h2 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2.根据标签名获取"></a>2.根据标签名获取</h2><p><code>getElementsByTagName()</code><br>括号里标签名要加引号；<br>返回的是元素对象的集合，以伪数组的形式存储；<br>可以通过遍历的方式依次打印元素对象<br>元素对象是动态的<br>可以通过<code>element.getElementsByTagName(&#39;&#39;)</code>获取某种元素里面的所有标签</p><h2 id="3-根据类名获取"><a href="#3-根据类名获取" class="headerlink" title="3.根据类名获取"></a>3.根据类名获取</h2><p><code>getElementsByClassName()</code><br>返回的也是伪数组形式的对象集合，想要访问单个对象需要加索引号</p><h2 id="4-H5新增获取元素的方法"><a href="#4-H5新增获取元素的方法" class="headerlink" title="4.H5新增获取元素的方法"></a>4.H5新增获取元素的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#id&apos;)</span><br><span class="line">document.querySelector(&apos;.classname&apos;) </span><br><span class="line">document.querySelector(&apos;标签名&apos;)</span><br></pre></td></tr></table></figure><p>如果有多个相同的id、类名、标签名，只获取第一个<br>如果想获取全部的，使用<code>document.querySelectorAll()</code><br>返回的是伪数组对象集合nodelist<br>括号里面还可以写div:first-child</p><h2 id="5-获取特殊元素"><a href="#5-获取特殊元素" class="headerlink" title="5.获取特殊元素"></a>5.获取特殊元素</h2><p>1)获取body元素<br><code>document.body</code><br>2)获取html元素<br><code>document.documentElement</code></p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件基础</title>
      <link href="/2017/06/20/2.webAPI/DOM/2.%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/06/20/2.webAPI/DOM/2.%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事件概述"><a href="#1-事件概述" class="headerlink" title="1.事件概述"></a>1.事件概述</h2><p>事件：可以被js侦测到的行为</p><h2 id="2-事件三要素"><a href="#2-事件三要素" class="headerlink" title="2.事件三要素"></a>2.事件三要素</h2><ul><li>事件源 事件被触发的对象 谁被触发</li><li>事件类型 如何触发 什么事件</li><li>事件处理程序 通过一个函数赋值的方式完成<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">alert(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-事件执行的步骤"><a href="#3-事件执行的步骤" class="headerlink" title="3.事件执行的步骤"></a>3.事件执行的步骤</h2><ul><li>获取事件源  </li><li>注册事件/绑定事件  不是必须有的</li><li>添加事件处理程序 函数赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API和DOM简介</title>
      <link href="/2017/06/20/2.webAPI/DOM/1.API%E5%92%8CDOM%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/06/20/2.webAPI/DOM/1.API%E5%92%8CDOM%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h1><h2 id="1-Web-APIs和js基础关联性"><a href="#1-Web-APIs和js基础关联性" class="headerlink" title="1.Web APIs和js基础关联性"></a>1.Web APIs和js基础关联性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190524/ko6kIKqonlsF.png?imageslim" alt="Image"></p><h2 id="2-API和Web-API"><a href="#2-API和Web-API" class="headerlink" title="2.API和Web API"></a>2.API和Web API</h2><p>API:应用程序编程接口，是给程序员提供的一种工具，以便轻松实现想要的功能<br>Web API:浏览器提供的操作浏览器功能（BOM）和页面元素（DOM）的API，主要针对浏览器做交互效果</p><h1 id="二、DOM"><a href="#二、DOM" class="headerlink" title="二、DOM"></a>二、DOM</h1><h2 id="1-DOM简介"><a href="#1-DOM简介" class="headerlink" title="1.DOM简介"></a>1.DOM简介</h2><p>文档对象模型，处理HTML和XML的标准编程接口。可以改变网页的内容、结构和样式<br>DOM树：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190524/UoqjwpaqNzMq.png?imageslim" alt="Image"><br>文档： document     元素：element所有标签     节点： node所有内容<br>DOM把以上内容都看做是对象</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单类型和复杂类型</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/9.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/9.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简单数据类型（值类型）"><a href="#一、简单数据类型（值类型）" class="headerlink" title="一、简单数据类型（值类型）"></a>一、简单数据类型（值类型）</h1><h2 id="1-五大类"><a href="#1-五大类" class="headerlink" title="1.五大类"></a>1.五大类</h2><p><code>string ，number，boolean，undefined，null(null是一个空object)</code></p><h2 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2.存储方式"></a>2.存储方式</h2><p>存储在栈中，内存直接开辟空间，存放的是值</p><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的<strong>值复制</strong>了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部的变量。</p><h1 id="二、复杂数据类型（引用类型）"><a href="#二、复杂数据类型（引用类型）" class="headerlink" title="二、复杂数据类型（引用类型）"></a>二、复杂数据类型（引用类型）</h1><h2 id="1-用new声明的都是"><a href="#1-用new声明的都是" class="headerlink" title="1.用new声明的都是"></a>1.用new声明的都是</h2><p>Object、Array、Date等</p><h2 id="2-存储方式-1"><a href="#2-存储方式-1" class="headerlink" title="2.存储方式"></a>2.存储方式</h2><p>在栈里存放的是地址（16进制），地址指向堆内存里的数据， 真正的对象实例存放在堆空间中</p><h2 id="3-参数传递-1"><a href="#3-参数传递-1" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的<strong>堆地址复制</strong>给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内置对象</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/8.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/8.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-js对象分类"><a href="#1-js对象分类" class="headerlink" title="1.js对象分类"></a>1.js对象分类</h2><p>自定义对象（ECMAScript）、内置对象（ECMAScript）、浏览器对象（JSAPI）</p><h2 id="2-什么是内置对象"><a href="#2-什么是内置对象" class="headerlink" title="2.什么是内置对象"></a>2.什么是内置对象</h2><p>JS自带的一些对象，提供了常用的功能和方法，优点：帮助我们快速开发</p><h2 id="3-有哪些内置对象"><a href="#3-有哪些内置对象" class="headerlink" title="3.有哪些内置对象"></a>3.有哪些内置对象</h2><p>Math,Date,Array,String等</p><hr><h1 id="二、内置对象学习方法"><a href="#二、内置对象学习方法" class="headerlink" title="二、内置对象学习方法"></a>二、内置对象学习方法</h1><h2 id="1-MDN"><a href="#1-MDN" class="headerlink" title="1.MDN"></a>1.MDN</h2><p><a href="http://developer.mozilla.org" target="_blank" rel="noopener">http://developer.mozilla.org</a></p><h2 id="2-使用内置对象的方法"><a href="#2-使用内置对象的方法" class="headerlink" title="2.使用内置对象的方法"></a>2.使用内置对象的方法</h2><p>  查阅该方法的功能<br>  查看里面参数的意义和类型<br>  查看返回值的意义和类型<br>  通过demo进行测试</p><hr><h1 id="三、Math对象"><a href="#三、Math对象" class="headerlink" title="三、Math对象"></a>三、Math对象</h1><p>Math不是构造函数，不需要new关键字</p><h2 id="1-属性PI，最大值max最小值min"><a href="#1-属性PI，最大值max最小值min" class="headerlink" title="1.属性PI，最大值max最小值min"></a>1.属性PI，最大值max最小值min</h2><pre><code>Math.PIMath.max()Math.min()</code></pre><h2 id="2-绝对值"><a href="#2-绝对值" class="headerlink" title="2.绝对值"></a>2.绝对值</h2><pre><code>Math.abs();</code></pre><h2 id="3-三个取整方法"><a href="#3-三个取整方法" class="headerlink" title="3.三个取整方法"></a>3.三个取整方法</h2><pre><code>向下取整： Math.floor();向上取整： Math.ceil();四舍五入： Math.round();    注意Math.round(-1.5) 结果是-1 因为.5往大了取</code></pre><h2 id="4-随机数方法"><a href="#4-随机数方法" class="headerlink" title="4.随机数方法"></a>4.随机数方法</h2><pre><code>Math.random()返回随机小数，默认范围在[0,1)之间；括号内没有参数；1）想要得到两个数之间的随机整数，包括最小和最大值：function getRandom(min, max) {    return Math.floor(Math.random() * (max - min + 1)) + min;  }2）随机点名    把数组的索引号改成随机整数即可，范围在 0 ~ length-1之间</code></pre><hr><h1 id="四、日期对象"><a href="#四、日期对象" class="headerlink" title="四、日期对象"></a>四、日期对象</h1><p>Date()是构造函数，必须使用new来调用 类似的还有Array()和Object()</p><h2 id="1-使用Date"><a href="#1-使用Date" class="headerlink" title="1.使用Date"></a>1.使用Date</h2><pre><code>如果没有参数 返回系统当前时间    var date1 = new Date();  有参数时：     参数是数字型 var date2 = new Date(2019,10,01);    11月    参数是字符串型 var date3 = new Date(&apos;2019-10-1 10:59:00&apos;);</code></pre><h2 id="2-日期的方法：格式化日期"><a href="#2-日期的方法：格式化日期" class="headerlink" title="2.日期的方法：格式化日期"></a>2.日期的方法：格式化日期</h2><p>var date = new Date();<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/nMYv7O8QJMHw.png?imageslim" alt="mark"></p><pre><code>方法：    date.getFullYear() 获取年份    date.getMonth() 获取月份 取值是0-11    date.getDate() 获取日    date.getDay() 获取周几 取值是0-6 对应周日-周六    date.getHours()  获取时    date.getMinutes() 获取分    date.getSeconds() 获取秒获取毫秒值的方法： 自1970年1月1日开始    date.valueOf()  获取当前毫秒数    date.getTime()  获取当前毫秒数    var times = +new Date(); 最常用              不给参数是当前时间             给参数是指定时间的毫秒数    Date.now()  h5新增 不需要new对象</code></pre><h2 id="倒计时案例："><a href="#倒计时案例：" class="headerlink" title="倒计时案例："></a>倒计时案例：</h2><p>用 时间戳（毫秒数） 转换为时分秒<br>输入时间总毫秒数 - 当前时间总毫秒数 获得 倒计时总时间<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/9G3XdiEmCqUo.png?imageslim" alt="mark"></p><hr><h1 id="五、数组对象"><a href="#五、数组对象" class="headerlink" title="五、数组对象"></a>五、数组对象</h1><h2 id="1-判断对象是否某种类型"><a href="#1-判断对象是否某种类型" class="headerlink" title="1.判断对象是否某种类型"></a>1.判断对象是否某种类型</h2><pre><code>var arr =[];1.instanceof方法        arr instanceof Array  返回true      null instanceof Object返回true2.Array.isArray(arr) 返回true</code></pre><h2 id="2-添加删除数组元素的方法"><a href="#2-添加删除数组元素的方法" class="headerlink" title="2.添加删除数组元素的方法"></a>2.添加删除数组元素的方法</h2><pre><code>数组名.push(元素);     向数组末尾添加元素 返回值是数组长度数组名.pop();         删除数组末尾的元素 返回值是被删除的元素数组名.unshift(元素);     在数组前面添加元素 返回值是数组长度数组名.shift();         删除数组第一个元素 返回值是被删除的元素</code></pre><h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><pre><code>数组名.reverse(); 翻转数组元素 返回新数组 改变原数组数组名.sort(); 给数组元素排序，参数是排序函数 返回新数组 改变原数组sort(function(a,b){    return a-b; //升序    return b-a; //降序})</code></pre><h2 id="4-数组元素索引方法"><a href="#4-数组元素索引方法" class="headerlink" title="4.数组元素索引方法"></a>4.数组元素索引方法</h2><pre><code>数组名.indexOf(元素)      从前往后查找    只返回第一个满足条件的索引号；    数组中如果没有该元素返回-1；数组名.lastIndexOf(元素)      倒着查找 返回值相同</code></pre><p>利用此方法实现数组去重<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/H20KEJIBbFzY.png?imageslim" alt="mark"></p><h2 id="5-数组转换为字符串"><a href="#5-数组转换为字符串" class="headerlink" title="5.数组转换为字符串"></a>5.数组转换为字符串</h2><pre><code>arr.toString()arr.join(‘分隔符’)  不写分隔符默认是逗号 常用的分隔符  -  &amp;</code></pre><h2 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6.其他方法"></a>6.其他方法</h2><pre><code>arr1.concat(arr2)  连接两个数组     返回新数组     不改变原数组slice(开始索引,结束索引)  截取数组     不改变原数组    截取部分数组元素 包含开始不包含结束      返回截取掉的新数组    如果只给一个参数，从此索引开始往后截取splice(开始索引，截取长度，替换元素)  截取数组     返回截取掉的新数组    改变原数组     替换元素是替换了被截取掉的元素</code></pre><hr><h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><h2 id="1-基本包装类型"><a href="#1-基本包装类型" class="headerlink" title="1.基本包装类型"></a>1.基本包装类型</h2><p>概念<br>对象才有属性和方法，为什么字符串也有length属性？<br>因为存在基本包装类型：JS 把 简单数据类型 包装成 复杂数据类型</p><p>后台包装过程：<br>    1.创建对象，变量是b<br>    2.把变量b给变量a<br>    3.销毁变量b<br>基本包装类型创建完就销毁，不能再添加其他属性和方法。<br>可以使用部分js定义的属性和方法</p><h2 id="2-字符串不可变性"><a href="#2-字符串不可变性" class="headerlink" title="2.字符串不可变性"></a>2.字符串不可变性</h2><p>给字符串重新赋值，不会删除原有的字符串，只是改变了字符串变量的内存地址。原来的内存空间仍然存在。因此不要大量拼接字符串，可以把数据放在数组里，然后转换为字符串。</p><h2 id="3-字符串方法"><a href="#3-字符串方法" class="headerlink" title="3.字符串方法"></a>3.字符串方法</h2><p><strong>所有字符串方法都不改变原来的字符串</strong></p><h3 id="1-查找字符位置"><a href="#1-查找字符位置" class="headerlink" title="1.查找字符位置"></a>1.查找字符位置</h3><pre><code>indexOf(&apos;字符&apos;,起始位置)和数组的indexOf方法相同，找到返回索引值，找不到返回-1案例：统计某个字符出现的位置和次数</code></pre><h3 id="2-查找对应位置的字符"><a href="#2-查找对应位置的字符" class="headerlink" title="2.查找对应位置的字符"></a>2.查找对应位置的字符</h3><pre><code>str.charAt(索引）        返回对应索引的字符str.charCodeAt(索引)       返回字符的ASCII码，可以判断用户按下的哪个键str[索引] H5新增</code></pre><h3 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3.拼接字符串"></a>3.拼接字符串</h3><pre><code>str1.concat(str2) 把str1和str2相连  返回新字符串 推荐使用加号</code></pre><h3 id="4-转换成大写"><a href="#4-转换成大写" class="headerlink" title="4.转换成大写"></a>4.转换成大写</h3><pre><code>str.toUpperCase() 把整个字符串转换成大写str[i].toUpperCase()  可以单独转换某个字符</code></pre><h3 id="5-转换成小写"><a href="#5-转换成小写" class="headerlink" title="5.转换成小写"></a>5.转换成小写</h3><pre><code>str.toLowerCase() 把整个字符串转换成小写str[i].toLowerCase() 单独转换某个字符</code></pre><h3 id="6-截取"><a href="#6-截取" class="headerlink" title="6.截取"></a>6.截取</h3><pre><code>substring(开始索引，结束索引); 包括开始不包括结束，如果只有一个值，从该索引截取到字符串末尾</code></pre><h3 id="7-替换字符"><a href="#7-替换字符" class="headerlink" title="7.替换字符"></a>7.替换字符</h3><pre><code>str.replace(&apos;a&apos;,&apos;b&apos;)  把字符a 替换为字符b 只会替换第一个遇到的字符    </code></pre><h3 id="8-转换成数组"><a href="#8-转换成数组" class="headerlink" title="8.转换成数组"></a>8.转换成数组</h3><pre><code>str.split(&apos;分隔符&apos;)  把字符串转换为数组，并添加分隔符分隔符取决于原来字符串内的分隔符</code></pre>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
            <tag> 内置对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/7.%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/7.%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对象概念"><a href="#一、对象概念" class="headerlink" title="一、对象概念"></a>一、对象概念</h1><h2 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1.什么是对象"></a>1.什么是对象</h2><p>是一个具体的事物，不能是泛指的概念<br>JS中，对象是一组无序的相关属性和方法的集合，<br>键值对的集合、数据集和功能集 的集合</p><h2 id="2-为什么需要对象"><a href="#2-为什么需要对象" class="headerlink" title="2.为什么需要对象"></a>2.为什么需要对象</h2><p>和变量和数组相比，对象可以保存的信息结构更清晰</p><h1 id="二、创建对象的三种方式"><a href="#二、创建对象的三种方式" class="headerlink" title="二、创建对象的三种方式"></a>二、创建对象的三种方式</h1><h2 id="1-用字面量创建"><a href="#1-用字面量创建" class="headerlink" title="1.用字面量创建"></a>1.用字面量创建</h2><p>方式1    var 对象字面量： {属性和方法}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name : <span class="string">'shawn'</span>,</span><br><span class="line">sayHi : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2 创建空对象，再添加值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;&#125;;</span><br><span class="line">obj.name=<span class="string">'shawn'</span>;</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-使用Object"><a href="#2-使用Object" class="headerlink" title="2.使用Object"></a>2.使用Object</h2><p>方式1 先创建空对象再给值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'shawn'</span>;</span><br></pre></td></tr></table></figure><p>方式2 创建同时赋值：    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">name : <span class="string">'shawn'</span>,</span><br><span class="line">age : <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-使用构造函数创建对象"><a href="#3-使用构造函数创建对象" class="headerlink" title="3.使用构造函数创建对象"></a>3.使用构造函数创建对象</h2><p>以上方式一次只能创建一个对象<br>构造函数： 把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面，这种思想称为工厂模式；<br>    构造函数里面封装的是对象，泛指的某一大类;对象是特指的某一个<br>语法格式：<br>    声明：    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.属性 = 值；</span><br><span class="line"><span class="keyword">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<code>var  对象名 = new 构造函数名(实参);</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/SEYJWlvB0TTh.png?imageslim" alt="mark">        </p><p>1.构造函数名首字母要大写；<br>2.构造函数不需要return就可以返回结果，返回的是对象；<br>3.调用构造函数必须使用new关键字</p><p>利用构造函数创建对象的过程也称为对象的实例化</p><p>ps:工厂模式和构造函数封装对象的不同之处：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/y8R94kw8rh5g.png?imageslim" alt="mark"><br>函数名首字母不需要大小；内部需要定义一个空对象；需要return此对象；不需要使用new和this关键字</p><h2 id="4-对象的使用方法"><a href="#4-对象的使用方法" class="headerlink" title="4.对象的使用方法"></a>4.对象的使用方法</h2><p>1）获取对象的属性<br>    方法1： 对象名.属性名  <code>obj.name</code><br>    方法2： 对象名[‘属性名’]   <code>obj[&#39;age&#39;]</code><br>2）调用对象的方法： 对象名.方法名  <code>obj.sayHi();</code></p><h1 id="三、new关键字"><a href="#三、new关键字" class="headerlink" title="三、new关键字"></a>三、new关键字</h1><p>new的执行过程<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/unQzcVf4UKME.png?imageslim" alt="mark">    </p><h1 id="四、对象的遍历"><a href="#四、对象的遍历" class="headerlink" title="四、对象的遍历"></a>四、对象的遍历</h1><p>使用for in 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(k);  <span class="comment">//输出属性名和方法名</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[k]);  <span class="comment">//输出属性值和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和预解析</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/6.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/6.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h1><h2 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h2><p>代码名字（变量）在某个范围内起作用，这个范围就是作用域<br>目的是为了提高程序的可靠性，减少命名冲突<br>不同作用域下，相同的名字不会冲突</p><h2 id="2-js作用域分类（ES6之前）"><a href="#2-js作用域分类（ES6之前）" class="headerlink" title="2.js作用域分类（ES6之前）"></a>2.js作用域分类（ES6之前）</h2><p>全局作用域：整个script标签或者整个js文件<br>局部作用域：代码名字只在函数内部起作用<br>现阶段没有块级作用域，在ES6中新增了块级作用域，即{ }花括号里面的变量外面不能使用</p><h2 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h2><p>根据作用域的不同，变量分为两种，全局变量和局部变量<br>    全局变量：在任何地方都可以使用；只有在浏览器关闭时才会销毁，占内存更多<br>    局部变量：在函数内部的变量，只能在当前函数内使用；函数结束时就会销毁，节约内存空间</p><p>在函数内部 不声明只赋值的变量 也属于全局变量<br>函数的形参也属于局部变量</p><h2 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h2><p>函数嵌套时，内部函数可以访问外部函数的变量，用链式查找的方式决定变量的值，这种结构称为作用域链。取值按照就近原则。</p><h1 id="二、预解析"><a href="#二、预解析" class="headerlink" title="二、预解析"></a>二、预解析</h1><p>js解释器运行js代码分为两步<br>    1.预解析 ：把js代码所有var和function提升到当前作用域的最前面<br>    2.代码执行 ：从上到下执行代码</p><h1 id="1-变量预解析（变量提升）：只提升声明，不提升赋值"><a href="#1-变量预解析（变量提升）：只提升声明，不提升赋值" class="headerlink" title="1.变量预解析（变量提升）：只提升声明，不提升赋值"></a>1.变量预解析（变量提升）：只提升声明，不提升赋值</h1><p>变量：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/3OhXKN0D8m4L.png?imageslim" alt="mark"><br>函数以变量形式声明时：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/LCntf5zB4B58.png?imageslim" alt="mark"></p><h1 id="2-函数预解析（函数提升）："><a href="#2-函数预解析（函数提升）：" class="headerlink" title="2.函数预解析（函数提升）："></a>2.函数预解析（函数提升）：</h1><p>函数以这种形式声明时<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/QcbeaYtFJDEY.png?imageslim" alt="mark"><br>只提升函数声明，不调用函数。因此声明和调用的先后顺序不影响执行。<br>案例<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/QyCog6HlvvL6.png?imageslim" alt="mark"><br>输出 9 9 9 9 9 error</p><p>在函数内部，形参与变量名重名时，以形参为主<br>函数内部，只给值不声明是全局变量。但是不能和形参重名，重名的话就不是全局变量了<br>函数调用时，不会改变函数原来的作用域</p><p>​                ​            </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/5.%E5%87%BD%E6%95%B0/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/5.%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、函数的概念"><a href="#一、函数的概念" class="headerlink" title="一、函数的概念"></a>一、函数的概念</h1><h2 id="1-为什么需要函数"><a href="#1-为什么需要函数" class="headerlink" title="1.为什么需要函数"></a>1.为什么需要函数</h2><p>让大量代码可以被重复使用；<br>代码模块化；</p><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><p>封装了一块可以被重复执行调用的代码块,对外只提供一个简单的函数接口</p><h1 id="二、函数的使用"><a href="#二、函数的使用" class="headerlink" title="二、函数的使用"></a>二、函数的使用</h1><p>两个步骤：</p><h2 id="1-声明函数"><a href="#1-声明函数" class="headerlink" title="1.声明函数"></a>1.声明函数</h2><p>方式1    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 函数名 = function()&#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时    fn();<br>fn是变量名 不是函数名<br>函数表达式也可以传递参数</p><p>函数名一般是动词，驼峰命名法；</p><h2 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2.调用函数"></a>2.调用函数</h2><p>函数名();</p><p>函数不调用，自己不执行；</p><h1 id="三、函数的参数"><a href="#三、函数的参数" class="headerlink" title="三、函数的参数"></a>三、函数的参数</h1><p>形参和实参<br>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名（形参1，形参2...）&#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>    <code>函数名(实参1，实参2...);</code></p><p>形参是接收实参的，类似于变量；<br>函数的参数可有可无，数量不限；</p><p>形参和实参个数关系：<br>    个数相等：一一匹配；<br>    实参个数 &gt; 形参个数：舍弃多余的实参；<br>    实参个数 &lt; 形参个数：没有接收到值的形参是undifined；</p><h1 id="四、函数的返回值"><a href="#四、函数的返回值" class="headerlink" title="四、函数的返回值"></a>四、函数的返回值</h1><h2 id="1-return语句"><a href="#1-return语句" class="headerlink" title="1.return语句"></a>1.return语句</h2><p>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">函数体；</span><br><span class="line">return 需要返回的值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>    <code>函数名();</code></p><p>函数体内不应该写输出语句<br>使用return把函数结果返回给调用者，即 函数名() = 返回的值；</p><p>return只能返回一个值，如果写了多个，只会返回最后一个值；想返回多个值可以使用数组；</p><h2 id="2-return会终止函数"><a href="#2-return会终止函数" class="headerlink" title="2.return会终止函数"></a>2.return会终止函数</h2><p>return之后的函数语句不再执行，退出函数并返回值</p><h2 id="3-函数没有return返回undifined"><a href="#3-函数没有return返回undifined" class="headerlink" title="3.函数没有return返回undifined"></a>3.函数没有return返回undifined</h2><p>只要是函数都有返回值，函数没有return时返回值是undifined</p><h1 id="五、arguments的使用"><a href="#五、arguments的使用" class="headerlink" title="五、arguments的使用"></a>五、arguments的使用</h1><p>由于不确定传递多少个实参过来，<br>可以用arguments存储所有传递过来的实参，不再使用形参，跟形参无关<br>    1.arguments是伪数组，具有length属性和索引，但是没有真正数组的一些方法<br>    2.可以按照数组的方式遍历arguments<br>    3.只有函数才有arguments对象，每个函数都内置此对象<br>一般形参和实参数量匹配，arguments用的不多</p><h1 id="六、函数可以相互调用"><a href="#六、函数可以相互调用" class="headerlink" title="六、函数可以相互调用"></a>六、函数可以相互调用</h1><p>可以在一个函数内调用另外一个函数<br>函数可以 以参数的形式 传递，称为回调函数</p><p>​                ​            </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/4.%E6%95%B0%E7%BB%84/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/4.%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>什么是数组<br>    数组Array是一组数据的集合存放在单个变量名下，其中每个数据称为数组元素。<br>    数组可以存放任意类型的元素,一般一个数组只存放一种</p><h1 id="二、创建数组"><a href="#二、创建数组" class="headerlink" title="二、创建数组"></a>二、创建数组</h1><p>1.利用new创建数组<br>    <code>var arr = new Array();</code><br>    <code>var arr = new Array(1,2,3,4);</code><br>2.利用数组字面量创建数组 常用方式<br>    <code>var arr = [];   创建空数组</code><br>    <code>var arr = [1, 2, &#39;pink&#39;, true];  创建非空数组</code></p><p>区别： 当new Array()括号里只有一个数字时，代表的是数组的长度</p><h1 id="三、获取数组元素"><a href="#三、获取数组元素" class="headerlink" title="三、获取数组元素"></a>三、获取数组元素</h1><p>1.数组的索引<br>    索引又称作下标，是访问元素的序号，从0开始；<br>    用索引来访问数组元素；<br>2.数组长度<br>    arr.length 数组元素的个数  会自动检测数组元素的变化改变length大小<br>    与索引的关系： <code>arr.length - 1 = 数组最大索引值</code><br>3.遍历数组<br>    把数组的每个元素都访问一次，称为数组遍历<br>    利用循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  <span class="comment">//i当索引使用</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、增加-修改-删除数组元素"><a href="#四、增加-修改-删除数组元素" class="headerlink" title="四、增加/修改/删除数组元素"></a>四、增加/修改/删除数组元素</h1><p>1.修改数组长度新增元素<br>    数组长度arr.length是可变化的<br>        <code>arr.length = 5;</code><br>    新增的数组元素是undifined;<br>2.修改索引号新增元素<br>    假设<code>arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];</code><br>    此时索引是0-3，没有4，当设置 <code>arr[4] = &#39;e&#39;</code>时会在后面追加一个新元素e<br>    如果索引号已经占用，会覆盖掉原有的元素，实现修改效果<br>3.清空数组<br>    <code>arr.length = 0或Null;</code></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/3.js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/3.js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>流程控制：控制代码按照什么顺序执行<br>主要有顺序，分支，循环</p><h1 id="一-顺序流程控制"><a href="#一-顺序流程控制" class="headerlink" title="一.顺序流程控制"></a>一.顺序流程控制</h1><p>从上到下，顺序执行</p><h1 id="二-分支流程控制"><a href="#二-分支流程控制" class="headerlink" title="二.分支流程控制"></a>二.分支流程控制</h1><p>根据不同条件，执行不同代码，得到不同结果<br>1） if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式1) &#123;</span><br><span class="line">语句1；</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line">语句2；</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line">语句3；</span><br><span class="line">....</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 上述条件都不成立执行此处代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2） switch 语句</p><p>当要针对变量设置一系列的特定值的选项时，就可以使用 switch语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (表达式) &#123;</span><br><span class="line">case value1:</span><br><span class="line">表达式等于value1时要执行的代码；</span><br><span class="line">break;</span><br><span class="line">case value2:</span><br><span class="line">表达式等于value2时要执行的代码；</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">表达式不等于任何一个value时要执行的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断相等是===，类型和取值全相等才执行下面的语句<br>case后面不要加判断条件，而是确定的值<br>switch括号里的可以是变量或者表达式，一般是变量<br>如果不加break，会执行下一个case里的语句</p><h1 id="三-三元表达式"><a href="#三-三元表达式" class="headerlink" title="三.三元表达式"></a>三.三元表达式</h1><p>表达式是有返回值的</p><p>格式：<code>条件表达式1？表达式2：表达式3</code></p><p>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</p><h1 id="四-循环流程控制"><a href="#四-循环流程控制" class="headerlink" title="四.循环流程控制"></a>四.循环流程控制</h1><h2 id="1-循环的目的"><a href="#1-循环的目的" class="headerlink" title="1.循环的目的"></a>1.循环的目的</h2><p>重复执行某些语句<br>    循环体：被重复执行的代码<br>    终止条件：决定能否继续重复执行的条件</p><h2 id="2-三种循环语句"><a href="#2-三种循环语句" class="headerlink" title="2.三种循环语句"></a>2.三种循环语句</h2><p>1）for循环<br>重复执行某些代码，通常跟计数有关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化变量；条件表达式；操作表达式) &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化变量：用var声明的一个普通变量i，通常用于计数器使用<br>条件表达式：决定每一次循环是否执行，即终止条件<br>操作表达式：每次循环最后执行的代码，常用于 更新 计数器变量i </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i=1;i&lt;=10;i++)&#123;</span><br><span class="line">循环体执行10次;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以重复执行不同的代码，因为有变量i的存在；<br>循环体也可以是for循环，这样称作循环嵌套</p><p>2）while循环<br>一般用于不知道循环次数时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (条件表达式) &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式为真时执行循环体，否则跳出循环；<br>循环体里要有操作表达式，更新计数器变量，防止死循环</p><p>3）do while循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125; while (条件表达式)</span><br></pre></td></tr></table></figure><p>先执行一次循环体，再判断条件是否为真继续循环</p><h2 id="3-continue和break关键字"><a href="#3-continue和break关键字" class="headerlink" title="3.continue和break关键字"></a>3.continue和break关键字</h2><p>1）continue<br>跳出本次循环，继续下一次循环<br>2）break<br>跳出整个循环，不再执行其他循环次数</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/2.js%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/2.js%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h1><p>加 减 乘 除 取余<br><code>+  -  *  /  %</code><br>1.浮点数直接运算会出现误差<br>2.不能直接判断两个浮点数是否相等<br>3.取余可以判断一个数能否被整除，余数是0就能整除<br>4.算术运算符优先级 先乘除后加减 有括号先算括号内的</p><h1 id="2-表达式和返回值"><a href="#2-表达式和返回值" class="headerlink" title="2.表达式和返回值"></a>2.表达式和返回值</h1><p>由数字、变量和运算符组成的式子称为表达式<br>表达式的结果称为返回值<br>只要是表达式都有返回值</p><h1 id="3-递增和递减运算符"><a href="#3-递增和递减运算符" class="headerlink" title="3.递增和递减运算符"></a>3.递增和递减运算符</h1><p>递增++ 和 递减– ，必须配合变量使用<br>前置++n: 先加1 后返回值<br>后置n++: 先返回值 后加1<br>单行写的时候没有区别，后面如果还有计算、或者直接输出就有区别</p><h1 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a>4.比较运算符</h1><p>返回结果是boolean型<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/S1Ht9K2Dtd5g.png?imageslim" alt="mark"></p><h1 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5.逻辑运算符"></a>5.逻辑运算符</h1><p>用布尔值进行运算，返回值也是布尔值<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/GgYJtyVxg3U3.png?imageslim" alt="mark"></p><h1 id="6-逻辑中断（短路运算）"><a href="#6-逻辑中断（短路运算）" class="headerlink" title="6.逻辑中断（短路运算）"></a>6.逻辑中断（短路运算）</h1><p>原理：多个表达式进行逻辑运算时，左边的值可以确定时，就不再计算右边的表达式<br>    逻辑与&amp;&amp;：（找错）  表达式1 &amp;&amp; 表达式2<br>        如果有false，输出此false，如果没有，返回最后一个表达式<br>    逻辑或||：（找对） 表达式1 || 表达式2<br>        如果有true，输出此true，如果没有，返回最后一个表达式</p><h1 id="7-赋值运算符"><a href="#7-赋值运算符" class="headerlink" title="7.赋值运算符"></a>7.赋值运算符</h1><p><code>=  +=  -=  *=  /=  %=</code><br>n+=2 等价于 n = n + 2</p><h1 id="8-运算符优先级"><a href="#8-运算符优先级" class="headerlink" title="8.运算符优先级"></a>8.运算符优先级</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/vfjyozcab6V1.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和数据类型</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/1.%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/1.%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、js介绍"><a href="#一、js介绍" class="headerlink" title="一、js介绍"></a>一、js介绍</h1><h2 id="1-为什么学习JavaScript"><a href="#1-为什么学习JavaScript" class="headerlink" title="1.为什么学习JavaScript"></a>1.为什么学习JavaScript</h2><p>一开始的作用：判断用户的输入，验证表单<br>现在的意义：页面特效、移动端开发、异步和服务器交互ajax、服务端开发 </p><h2 id="2-浏览器是如何工作的"><a href="#2-浏览器是如何工作的" class="headerlink" title="2.浏览器是如何工作的"></a>2.浏览器是如何工作的</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/39XqGt97Enfc.png?imageslim" alt="mark"><br>User Interface: 用户界面<br>Browser engine： 浏览器引擎 查询和操作渲染引擎<br>Rendering engine：渲染引擎 解释执行html和css代码<br>JavaScript Interpreter：js解析器 解释执行javascript<br>Networking：网络 向服务器发送和接收请求<br>UI Backend： UI后端 绘制组合框和弹出窗口<br>Data Persistence：数据持久化 浏览器存储数据 cookie、html5中的sessionStorage</p><h2 id="3-JavaScript语言介绍"><a href="#3-JavaScript语言介绍" class="headerlink" title="3.JavaScript语言介绍"></a>3.JavaScript语言介绍</h2><p>js是脚本语言，不需要编译，边解析边执行。<br>编译：一次性把代码转换成CPU可以读懂的语言，一行一行执行<br>解释：一行一行解析，解析一行执行一行</p><p>js是客户端的脚本语言，因为它运行在浏览器上<br>js是直译型、弱类型、可以跨平台、面对对象开发的语言</p><h2 id="4-JavaScript的组成"><a href="#4-JavaScript的组成" class="headerlink" title="4.JavaScript的组成"></a>4.JavaScript的组成</h2><p>ECMAScript：JavaScript语法规范<br>DOM: JavaScript操作网页元素的API<br>BOM:    JavaScript操作浏览器部分功能的API</p><h1 id="二、js书写位置"><a href="#二、js书写位置" class="headerlink" title="二、js书写位置"></a>二、js书写位置</h1><h2 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h2><p>1.行内式：写在标签内 <code>&lt;button onclick=&quot;alert(&#39;成功&#39;)&quot;&gt; &lt;/button&gt;</code><br>2.内嵌式：写在html文件里面，head之内添加<code>&lt;script&gt;js代码&lt;/script&gt;</code><br>3.外部式：引入 <code>&lt;script src=&quot;main.js&quot;&gt; &lt;/script&gt;</code> 中间不可以再写js代码</p><h2 id="script标签的属性"><a href="#script标签的属性" class="headerlink" title="script标签的属性"></a>script标签的属性</h2><p>src: script文件路径<br>type: 默认是text/javascript 可以省略<br>async: 异步，并列执行 取值仅有一个值async<br>sync： 同步，线性执行<br>differ: 异步执行，在整个html文档都执行完之后再执行外部脚本，只有外部脚本可以使用，取值只有differ</p><h1 id="三、js注释"><a href="#三、js注释" class="headerlink" title="三、js注释"></a>三、js注释</h1><p><code>单行 //  快捷键 ctrl+/</code><br>多行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*   </span><br><span class="line">快捷键 修改为 crtl + shift + /</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="四、输入输出语句"><a href="#四、输入输出语句" class="headerlink" title="四、输入输出语句"></a>四、输入输出语句</h1><p>输入语句：<br><code>prompt(&quot;提示信息&quot;,&quot;默认值&quot;); 浏览器弹出输入框,取到的值是字符型的</code></p><p>输出语句：<br><code>alert(msg);</code> 浏览器弹出警示框 比如弹出变量值 <code>alert(&#39;变量值是&#39; + num);</code><br><code>console.log(msg);</code> 浏览器控制台打印输出日志 想要输出多个变量 用逗号分隔<br><code>document.write(&quot;&quot;);</code> 输出内容 在浏览器中显示 换行是用<code>&lt;br /&gt;</code></p><h1 id="五、变量"><a href="#五、变量" class="headerlink" title="五、变量"></a>五、变量</h1><h2 id="1-变量："><a href="#1-变量：" class="headerlink" title="1.变量："></a>1.变量：</h2><p>存放数据的容器，通过变量名获取数据<br>变量是在内存中存放数据的空间 </p><h2 id="2-定义变量两种方式："><a href="#2-定义变量两种方式：" class="headerlink" title="2.定义变量两种方式："></a>2.定义变量两种方式：</h2><p><code>var 变量名=值；</code><br><code>var 变量名； 变量名=值；</code><br>也可以一次声明多个变量 var name,age,sex；</p><p>只声明不赋值，该值是undifined<br>只赋值不声明，浏览器会根据赋值自动声明<br>既不声明也不赋值，会报错</p><p>定义变量后，存储在内存中，基本变量存储在栈中，复杂变量存储在堆中</p><h2 id="3-变量命名："><a href="#3-变量命名：" class="headerlink" title="3.变量命名："></a>3.变量命名：</h2><ul><li>变量命名规则：<br> 1.由字母、数字、下划线和$组成，开头不能是数字<br> 2.不能是关键字和保留字，不使用name<br> 3.区分大小写</li><li>变量命名规范：<br> 1.命名要有意义<br> 2.遵守驼峰命名法，首字母小写，其他单词第一个字母大写</li></ul><p><strong>练习</strong>  交换两个变量的值<br>    两种办法：使用中间变量、不使用中间变量</p><h2 id="4-获取变量类型"><a href="#4-获取变量类型" class="headerlink" title="4.获取变量类型"></a>4.获取变量类型</h2><p>使用<code>变量.typeof</code>方法</p><h1 id="六、简单数据类型"><a href="#六、简单数据类型" class="headerlink" title="六、简单数据类型"></a>六、简单数据类型</h1><h2 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h2><p>js是动态语言，数据类型是可以变化的。变量的数据类型是在程序运行过程中确定的，根据等号右边的值</p><h2 id="2-简单数据类型："><a href="#2-简单数据类型：" class="headerlink" title="2.简单数据类型："></a>2.简单数据类型：</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/3FR5jRw30AaQ.png?imageslim" alt="mark"></p><p>1）number 数字型<br>        取值可以是整数或者小数，也可以是各种进制的数。0开头是八进制数，0x开头是十六进制数<br>        js里面数字有最大值和最小值： Number.MAX_VALUE Number.MIN_VALUE<br>        数字型三个特殊值： 无穷大 Infinity  无穷小 -Infinity  非数字 NaN（not a number）<br>        isNaN() 方法用来判断变量是不是非数字<br>            如果不是数字返回true，如果是数字或者能转换成数字，则返回false<br>            NaN和任何值都不相等，包括它自己。</p><p>2）string 字符串型<br>        取值必须加引号，引号可以是””，也可以是’’， 推荐使用单引号<br>        字符串嵌套时要使用不同的引号，外双内单或者外单内双<br>        转义字符：<br>        <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/MBHUChas60WJ.png?imageslim" alt="mark">    </p><pre><code>转义字符只适用于console.log()的输出document.write() 换行使用br字符串长度属性： str.length       str[索引] 获取字符串的第几个字符 索引从0开始字符串拼接： newstr = str1 + str2;  数值相加，字符相连字符串和不同类型的值也可以拼接，结果都是字符串类型</code></pre><p>boolean和数字运算时，false和true 取值为0和1<br>undifined和数字相加结果是NaN<br>null和数字相加仍为原数字,null是对象类型</p><h1 id="七、数据类型转换"><a href="#七、数据类型转换" class="headerlink" title="七、数据类型转换"></a>七、数据类型转换</h1><p>chrome控制台输出蓝色是数字型，黑色是字符串型</p><h2 id="1-转换成字符串型"><a href="#1-转换成字符串型" class="headerlink" title="1.转换成字符串型"></a>1.转换成字符串型</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/rIMS8zHNmz8y.png?imageslim" alt="mark"></p><p> 变量.toString()  里面的变量要先声明<br> String(变量或值)  强制转换<br> 隐式转换：和字符串相加</p><h2 id="2-转换为数字型"><a href="#2-转换为数字型" class="headerlink" title="2.转换为数字型"></a>2.转换为数字型</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/my2vtLI6YeL7.png?imageslim" alt="mark"><br>    parseInt(字符串)     把字符串转换成整数，取整且去掉字母（开头要是数字）<br>    parseFloat(字符串)    把字符串转换成浮点数，去掉字母（开头要是数字）<br>        parseInt和parseFloat括号里可以逗号+进制 这样会把字符串转换为指定进制的数字<br>    Number(变量)     把变量变成数字型，变量有字母结果就是NaN，null转换为0<br>    隐式转换 在变量前面加+号、 -0 、* 1 、/ 1；</p><h2 id="3-转换为boolean类型"><a href="#3-转换为boolean类型" class="headerlink" title="3.转换为boolean类型"></a>3.转换为boolean类型</h2><p>Boolean(变量)<br>    转换为false的情况： 变量是 0 、 NaN 、 undefined 、null 、”” 、false<br>    其他都是true<br>隐式转换： !!变量</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
