<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试题汇总</title>
      <link href="/2019/07/02/0.tips/4.%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/02/0.tips/4.%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-CSS部分"><a href="#HTML-CSS部分" class="headerlink" title="HTML+CSS部分"></a>HTML+CSS部分</h1><h2 id="1、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#1、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="1、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a>1、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h2><p>IE: trident内核</p><p>Firefox：gecko内核</p><p>Safari:webkit内核</p><p>Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核</p><p>Chrome:Blink(基于webkit，<a href="http://baike.baidu.com/view/1369399.htm#1_5" target="_blank" rel="noopener">Google与Opera Software共同开发</a>)</p><h2 id="2、每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？"><a href="#2、每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？" class="headerlink" title="2、每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？"></a>2、每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？</h2><p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</p><h2 id="3、Quirks模式是什么？它和Standards模式有什么区别"><a href="#3、Quirks模式是什么？它和Standards模式有什么区别" class="headerlink" title="3、Quirks模式是什么？它和Standards模式有什么区别"></a>3、Quirks模式是什么？它和Standards模式有什么区别</h2><p>从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</p><p>在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？</p><p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。</p><p>区别：</p><p>总体会有布局、样式解析和脚本执行三个方面的区别。</p><p>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></p><p>设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。</p><p>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</p><p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p><h2 id="4、div-css的布局较table布局有什么优点？"><a href="#4、div-css的布局较table布局有什么优点？" class="headerlink" title="4、div+css的布局较table布局有什么优点？"></a>4、div+css的布局较table布局有什么优点？</h2><p>改版的时候更方便 只要改css文件。</p><p>页面加载速度更快、结构化清晰、页面显示简洁。</p><p>表现与结构相分离。</p><p>易于优化（seo）搜索引擎更友好，排名更容易靠前。</p><h2 id="5、-img的alt与title有何异同？-strong与em的异同？"><a href="#5、-img的alt与title有何异同？-strong与em的异同？" class="headerlink" title="5、 img的alt与title有何异同？ strong与em的异同？"></a>5、 img的alt与title有何异同？ strong与em的异同？</h2><p>a:alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示)</p><p>title(tool tip):该属性为设置该属性的元素提供建议性的信息。</p><p>strong:粗体强调标签，强调，表示内容的重要性</p><p>em:斜体强调标签，更强烈强调，表示内容的强调点</p><h2 id="6、你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#6、你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="6、你能描述一下渐进增强和优雅降级之间的不同吗?"></a>6、你能描述一下渐进增强和优雅降级之间的不同吗?</h2><p>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><p>“优雅降级”观点</p><p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</p><p>在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>“渐进增强”观点</p><p>“渐进增强”观点则认为应关注于内容本身。</p><p>内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h2 id="7、为什么利用多个域名来存储网站资源会更有效？"><a href="#7、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="7、为什么利用多个域名来存储网站资源会更有效？"></a>7、为什么利用多个域名来存储网站资源会更有效？</h2><p>CDN缓存更方便</p><p>突破浏览器并发限制</p><p>节约cookie带宽</p><p>节约主域名的连接数，优化页面响应速度</p><p>防止不必要的安全问题</p><h2 id="8、请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#8、请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="8、请谈一下你对网页标准和标准制定机构重要性的理解。"></a>8、请谈一下你对网页标准和标准制定机构重要性的理解。</h2><p>网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。</p><h2 id="9、请描述一下cookie，sessionStorage和localStorage的区别？"><a href="#9、请描述一下cookie，sessionStorage和localStorage的区别？" class="headerlink" title="9、请描述一下cookie，sessionStorage和localStorage的区别？"></a>9、请描述一下cookie，sessionStorage和localStorage的区别？</h2><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>web storage和cookie的区别</p><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><h2 id="10、简述一下src与href的区别。"><a href="#10、简述一下src与href的区别。" class="headerlink" title="10、简述一下src与href的区别。"></a>10、简述一下src与href的区别。</h2><p>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</p><p>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</p><p>&lt;script src =”js.js”&gt;&lt;/script&gt;</p><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><p>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</p><p>&lt;link href=”common.css” rel=”stylesheet”/&gt;</p><p>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p><h2 id="11、知道的网页制作会用到的图片格式有哪些？"><a href="#11、知道的网页制作会用到的图片格式有哪些？" class="headerlink" title="11、知道的网页制作会用到的图片格式有哪些？"></a>11、知道的网页制作会用到的图片格式有哪些？</h2><p>png-8，png-24，jpeg，gif，svg。</p><p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）</p><p>科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook<br>Ebay等知名网站已经开始测试并使用WebP格式。</p><p>在质量相同的情况下，<a href="http://baike.baidu.com/view/4447461.htm" target="_blank" rel="noopener">WebP</a>格式图像的体积要比JPEG格式图像小40%</p><h2 id="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h2><p>微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</p><p>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行google）</p><h2 id="13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"></a>13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</h2><p>答案：dns缓存，cdn缓存，浏览器缓存，服务器缓存。</p><h2 id="14、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#14、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="14、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"></a>14、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h2><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p><p>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p><p>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</p><p>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p><p>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p><h2 id="15、你如何理解HTML结构的语义化？"><a href="#15、你如何理解HTML结构的语义化？" class="headerlink" title="15、你如何理解HTML结构的语义化？　"></a>15、你如何理解HTML结构的语义化？　</h2><p>去掉或样式丢失的时候能让页面呈现清晰的结构：</p><p>html本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小2em，加粗；&lt;strong&gt;是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</p><p>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.</p><p>例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.</p><p>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）</p><p>使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.</p><p>语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.</p><p>搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重</p><p>过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是极其宝贵的用户.没有他们的话,搜索引擎将无法索引你的网站,然后一般用户将很难过来访问.</p><p>你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.</p><p>因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.</p><p>SEO主要还是靠你网站的内容和外部链接的。</p><p>便于团队开发和维护</p><p>W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至<a href="http://www.cssforest.org/blog/index.php?id=134" target="_blank" rel="noopener">实现模块化开发</a>。</p><h2 id="16、谈谈以前端角度出发做好SEO需要考虑什么？"><a href="#16、谈谈以前端角度出发做好SEO需要考虑什么？" class="headerlink" title="16、谈谈以前端角度出发做好SEO需要考虑什么？"></a>16、谈谈以前端角度出发做好SEO需要考虑什么？</h2><p>了解搜索引擎如何抓取网页和如何索引网页</p><p>你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。</p><p>Meta标签优化</p><p>主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。</p><p>如何选取关键词并在网页中放置关键词</p><p>搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</p><p>了解主要的搜索引擎</p><p>虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。</p><p>主要的互联网目录</p><p>Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。</p><p>按点击付费的搜索引擎</p><p>搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。</p><p>搜索引擎登录</p><p>网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。</p><p>链接交换和链接广泛度（Link Popularity）</p><p>网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。</p><p>合理的标签使用</p><h2 id="17、有哪项方式可以对一个DOM设置它的CSS样式？"><a href="#17、有哪项方式可以对一个DOM设置它的CSS样式？" class="headerlink" title="17、有哪项方式可以对一个DOM设置它的CSS样式？　"></a>17、有哪项方式可以对一个DOM设置它的CSS样式？　</h2><p>外部样式表，引入一个外部css文件</p><p>内部样式表，将css代码放在 &lt;head&gt; 标签内部</p><p>内联样式，将css样式直接定义在 HTML 元素内部</p><h2 id="18、CSS都有哪些选择器？"><a href="#18、CSS都有哪些选择器？" class="headerlink" title="18、CSS都有哪些选择器？"></a>18、CSS都有哪些选择器？</h2><p>派生选择器（用HTML标签申明）</p><p>id选择器（用DOM的ID申明）</p><p>类选择器（用一个样式类名申明）</p><p>属性选择器（用DOM的属性申明，属于CSS2，IE6不支持，不常用）</p><p>除了前3种基本选择器，还有一些扩展选择器，包括</p><p>后代选择器（利用空格间隔，比如div .a{  }）</p><p>群组选择器（利用逗号间隔，比如p,div,#a{  }）</p><p>那么问题来了，CSS选择器的优先级是怎么样定义的？</p><p>基本原则：</p><p>一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。</p><p>复杂的计算方法：</p><p>用1表示派生选择器的优先级</p><p>用10表示类选择器的优先级</p><p>用100标示ID选择器的优先级</p><p>div.test1 .span var 优先级 1+10 +10 +1</p><p>span#xxx .songs li 优先级1+100 + 10 + 1</p><p>#xxx li 优先级 100 +1</p><p>那么问题来了，看下列代码，&lt;p&gt;标签内的文字是什么颜色的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.classA&#123; color:blue;&#125;</span><br><span class="line">.classB&#123; color:red;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&apos;classB classA&apos;&gt; 123 &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>答案：red。与样式定义在文件中的先后顺序有关，即是后面的覆盖前面的，与在&lt;pclass=’classB classA’&gt;中的先后关系无关。</p><h2 id="19、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？"><a href="#19、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？" class="headerlink" title="19、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？"></a>19、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？</h2><p>最基本的：</p><p>设置display属性为none，或者设置visibility属性为hidden</p><p>技巧性：</p><p>设置宽高为0，设置透明度为0，设置z-index位置在-1000</p><h2 id="20、超链接访问过后hover样式就不出现的问题是什么？如何解决？"><a href="#20、超链接访问过后hover样式就不出现的问题是什么？如何解决？" class="headerlink" title="20、超链接访问过后hover样式就不出现的问题是什么？如何解决？"></a>20、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h2><p>答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</p><h2 id="21、什么是Css-Hack？ie6-7-8的hack分别是什么？"><a href="#21、什么是Css-Hack？ie6-7-8的hack分别是什么？" class="headerlink" title="21、什么是Css Hack？ie6,7,8的hack分别是什么？"></a>21、什么是Css Hack？ie6,7,8的hack分别是什么？</h2><p>答案：针对不同的浏览器写不同的CSS code的过程，就是CSS hack。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#test &#123;          </span><br><span class="line">width:300px;           </span><br><span class="line">height:300px;           </span><br><span class="line">background-color:blue;      /*firefox*/        </span><br><span class="line">background-color:red\\9;      /*all ie*/         </span><br><span class="line">background-color:yellow;    /*ie8*/         </span><br><span class="line">+background-color:pink;        /*ie7*/         </span><br><span class="line">_background-color:orange;       /*ie6*/   </span><br><span class="line">&#125;          </span><br><span class="line">#test &#123; </span><br><span class="line">background-color:purple\\9; </span><br><span class="line">&#125;  /*ie9*/     </span><br><span class="line">@media all and (min-width:0px)&#123; </span><br><span class="line">#test &#123;background-color:black;&#125; </span><br><span class="line">&#125;  /*opera*/     </span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio:0)&#123; </span><br><span class="line">#test &#123;background-color:gray;&#125; </span><br><span class="line">&#125;       /*chrome and safari*/</span><br></pre></td></tr></table></figure><h2 id="22、请用Css写一个简单的幻灯片效果页面"><a href="#22、请用Css写一个简单的幻灯片效果页面" class="headerlink" title="22、请用Css写一个简单的幻灯片效果页面"></a>22、请用Css写一个简单的幻灯片效果页面</h2><p>答案：知道是要用css3。使用animation动画实现一个简单的幻灯片效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*HTML*/         </span><br><span class="line">div.ani         </span><br><span class="line">/*css*/        </span><br><span class="line">.ani&#123;          </span><br><span class="line">width:480px;           </span><br><span class="line">height:320px;          </span><br><span class="line">margin:50px auto;           </span><br><span class="line">overflow: hidden;          </span><br><span class="line">box-shadow:0 0 5px rgba(0,0,0,1);           </span><br><span class="line">background-size: cover;           </span><br><span class="line">background-position: center;           </span><br><span class="line">-webkit-animation-name: &quot;loops&quot;;           </span><br><span class="line">-webkit-animation-duration: 20s;          </span><br><span class="line">-webkit-animation-iteration-count: infinite;        </span><br><span class="line">&#125;         </span><br><span class="line">@-webkit-keyframes &quot;loops&quot; &#123;             </span><br><span class="line">0% &#123;</span><br><span class="line">background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">25% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat;         </span><br><span class="line">&#125;             </span><br><span class="line">50% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat;            </span><br><span class="line">&#125;             </span><br><span class="line">75% &#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat;        </span><br><span class="line">&#125;             </span><br><span class="line">100% &#123; background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat;             </span><br><span class="line">&#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23、行内元素和块级元素的具体区别是什么？"><a href="#23、行内元素和块级元素的具体区别是什么？" class="headerlink" title="23、行内元素和块级元素的具体区别是什么？"></a>23、行内元素和块级元素的具体区别是什么？</h2><p>块级元素(block)特性：</p><p>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</p><p>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</p><p>内联元素(inline)特性：</p><p>和相邻的内联元素在同一行;</p><p>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。</p><p>那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？</p><p>答案：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。</p><h2 id="24、行内元素的padding和margin可设置吗？"><a href="#24、行内元素的padding和margin可设置吗？" class="headerlink" title="24、行内元素的padding和margin可设置吗？"></a>24、行内元素的padding和margin可设置吗？</h2><p>垂直方向不可设置 水平方向可设置</p><h2 id="25、什么是外边距重叠？重叠的结果是什么？"><a href="#25、什么是外边距重叠？重叠的结果是什么？" class="headerlink" title="25、什么是外边距重叠？重叠的结果是什么？"></a>25、什么是外边距重叠？重叠的结果是什么？</h2><p>外边距重叠就是margin-collapse。</p><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p><p>折叠结果遵循下列计算规则：</p><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</p><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</p><p>两个外边距一正一负时，折叠结果是两者的相加的和。</p><h2 id="26、rgba-和opacity的透明效果有什么不同？"><a href="#26、rgba-和opacity的透明效果有什么不同？" class="headerlink" title="26、rgba()和opacity的透明效果有什么不同？"></a>26、rgba()和opacity的透明效果有什么不同？</h2><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，</p><p>而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p><h2 id="27、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#27、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="27、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>27、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h2><p>垂直方向：line-height</p><p>水平方向：letter-spacing</p><p>那么问题来了，关于letter-spacing的妙用知道有哪些么？</p><p>答案:可以用于消除inline-block元素间的换行符空格间隙问题。</p><h2 id="28、如何垂直居中一个浮动元素？"><a href="#28、如何垂直居中一个浮动元素？" class="headerlink" title="28、如何垂直居中一个浮动元素？"></a>28、如何垂直居中一个浮动元素？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：已知元素的高宽</span><br><span class="line">#div1&#123;</span><br><span class="line">    background-color:#6699FF;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    position: absolute;        //父元素需要相对定位</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top:-100px ;   //二分之一的height，width</span><br><span class="line">    margin-left: -100px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//方法二:未知元素的高宽</span><br><span class="line">#div1&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: #6699FF;</span><br><span class="line">    margin:auto;</span><br><span class="line">    position: absolute;        //父元素需要相对定位</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">那么问题来了，如何垂直居中一个&lt;img&gt;?（用更简便的方法。）</span><br><span class="line">#container     //&lt;img&gt;的容器设置如下</span><br><span class="line">&#123;</span><br><span class="line">    display:table-cell;</span><br><span class="line">    text-align:center;</span><br><span class="line">    vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29、px和em的区别。"><a href="#29、px和em的区别。" class="headerlink" title="29、px和em的区别。"></a>29、px和em的区别。</h2><p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p><p>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合:<br>1em=16px。那么12px=0.75em, 10px=0.625em。</p><h2 id="30、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？"><a href="#30、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？" class="headerlink" title="30、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？"></a>30、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h2><p>重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的事发生。</p><p>你可能会用<a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize</a>来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p><p>在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。</p><h2 id="31、Sass、LESS是什么？大家为什么要使用他们？"><a href="#31、Sass、LESS是什么？大家为什么要使用他们？" class="headerlink" title="31、Sass、LESS是什么？大家为什么要使用他们？"></a>31、Sass、LESS是什么？大家为什么要使用他们？</h2><p>他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。</p><p>例如<a href="http://www.lesscss.org/" target="_blank" rel="noopener">Less</a>是一种动态样式语言.<br>将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行<br>(支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。</p><p>为什么要使用它们？</p><p>结构清晰，便于扩展。</p><p>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</p><p>可以轻松实现多重继承。</p><p>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS<br>语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</p><h2 id="32、display-none与visibility-hidden的区别是什么？"><a href="#32、display-none与visibility-hidden的区别是什么？" class="headerlink" title="32、display:none与visibility:hidden的区别是什么？"></a>32、display:none与visibility:hidden的区别是什么？</h2><p>display : 隐藏对应的元素但不挤占该元素原来的空间。</p><p>visibility: 隐藏对应的元素并且挤占该元素原来的空间。</p><p>即是，使用CSS<br>display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p><h2 id="33、这个问题被吃了………"><a href="#33、这个问题被吃了………" class="headerlink" title="33、这个问题被吃了………"></a>33、这个问题被吃了………</h2><h2 id="34、CSS中link和-import的区别是："><a href="#34、CSS中link和-import的区别是：" class="headerlink" title="34、CSS中link和@import的区别是："></a>34、CSS中link和@import的区别是：</h2><p>Link属于html标签，而@import是CSS中提供的</p><p>在页面加载的时候，link会同时被加载，而@import引用的CSS会在页面加载完成后才会加载引用的CSS</p><p>@import只有在ie5以上才可以被识别，而link是html标签，不存在浏览器兼容性问题</p><p>Link引入样式的权重大于@import的引用（@import是将引用的样式导入到当前的页面中）</p><h2 id="35、简介盒子模型："><a href="#35、简介盒子模型：" class="headerlink" title="35、简介盒子模型："></a>35、简介盒子模型：</h2><p>CSS的盒子模型有两种：IE盒子模型、标准的W3C盒子模型模型</p><p>盒模型：内容、内边距、外边距（一般不计入盒子实际宽度）、边框</p><h2 id="36、为什么要初始化样式？"><a href="#36、为什么要初始化样式？" class="headerlink" title="36、为什么要初始化样式？"></a>36、为什么要初始化样式？</h2><p>由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异</p><p>但是初始化CSS会对搜索引擎优化造成小影响</p><h2 id="37、BFC是什么"><a href="#37、BFC是什么" class="headerlink" title="37、BFC是什么?"></a>37、BFC是什么?</h2><p>BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题</p><p>BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</p><h2 id="38、html语义化是什么？"><a href="#38、html语义化是什么？" class="headerlink" title="38、html语义化是什么？"></a>38、html语义化是什么？</h2><p>当页面样式加载失败的时候能够让页面呈现出清晰的结构</p><p>有利于seo优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别）</p><p>便于项目的开发及维护，使html代码更具有可读性，便于其他设备解析。</p><h2 id="39、Doctype的作用？严格模式与混杂模式的区别？"><a href="#39、Doctype的作用？严格模式与混杂模式的区别？" class="headerlink" title="39、Doctype的作用？严格模式与混杂模式的区别？"></a>39、Doctype的作用？严格模式与混杂模式的区别？</h2><p>&lt;!DOCTYPE&gt;用于告知浏览器该以何种模式来渲染文档</p><p>严格模式下：页面排版及JS解析是以该浏览器支持的最高标准来执行</p><p>混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容</p><h2 id="40、IE的双边距BUG"><a href="#40、IE的双边距BUG" class="headerlink" title="40、IE的双边距BUG"></a>40、IE的双边距BUG</h2><p>块级元素float后设置横向margin，ie6显示的margin比设置的较大。解决：加入_display：inline</p><h2 id="41、HTML与XHTML——二者有什么区别？"><a href="#41、HTML与XHTML——二者有什么区别？" class="headerlink" title="41、HTML与XHTML——二者有什么区别？"></a>41、HTML与XHTML——二者有什么区别？</h2><ol><li><p>所有的标记都必须要有一个相应的结束标记</p></li><li><p>所有标签的元素和属性的名字都必须使用小写</p></li><li><p>所有的 XML 标记都必须合理嵌套</p></li><li><p>所有的属性必须用引号 “” 括起来</p></li><li><p>把所有 &lt; 和 &amp; 特殊符号用编码表示</p></li><li><p>给所有属性赋一个值</p></li><li><p>不要在注释内容中使用 “–”</p></li><li><p>图片必须有说明文字</p></li></ol><h2 id="42、html常见兼容性问题？"><a href="#42、html常见兼容性问题？" class="headerlink" title="42、html常见兼容性问题？"></a>42、html常见兼容性问题？</h2><p>1.双边距BUG float引起的 使用display inline</p><p>2.3像素问题 使用float引起的 使用dislpay:inline -3px</p><p>3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active</p><p>4.Ie z-index问题 给父级添加position:relative</p><p>5.Png 透明 使用js代码 改</p><p>6.Min-height 最小高度 ！Important 解决’</p><p>7.select 在ie6下遮盖 使用iframe嵌套</p><p>8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08<br>line-height:1px）</p><p>9.IE5-8不支持opacity，解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.opacity &#123;</span><br><span class="line">opacity: 0.4</span><br><span class="line">filter: alpha(opacity=60); /* for IE5-7 */</span><br><span class="line">-ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;;/* for IE8*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>IE6不支持PNG透明背景，解决办法: IE6下使用gif图片</li></ol><h2 id="43、对WEB标准以及W3C的理解与认识"><a href="#43、对WEB标准以及W3C的理解与认识" class="headerlink" title="43、对WEB标准以及W3C的理解与认识"></a>43、对WEB标准以及W3C的理解与认识</h2><p>答：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外<br>链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维<br>护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</p><h2 id="44、行内元素有哪些-块级元素有哪些-CSS的盒模型"><a href="#44、行内元素有哪些-块级元素有哪些-CSS的盒模型" class="headerlink" title="44、行内元素有哪些?块级元素有哪些?CSS的盒模型?"></a>44、行内元素有哪些?块级元素有哪些?CSS的盒模型?</h2><p>答：块级元素：div p h1 h2 h3 h4 form ul<br>行内元素: a b br i span input select<br>Css盒模型:内容，border ,margin，padding</p><h2 id="45、前端页面有哪三层构成，分别是什么-作用是什么"><a href="#45、前端页面有哪三层构成，分别是什么-作用是什么" class="headerlink" title="45、前端页面有哪三层构成，分别是什么?作用是什么?"></a>45、前端页面有哪三层构成，分别是什么?作用是什么?</h2><p>答：结构层 Html ,表示层 CSS, 行为层 js。</p><h2 id="46、Doctype作用-严格模式与混杂模式-如何触发这两种模式，区分它们有何意义"><a href="#46、Doctype作用-严格模式与混杂模式-如何触发这两种模式，区分它们有何意义" class="headerlink" title="46、Doctype作用? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?"></a>46、Doctype作用? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?</h2><p>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt;<br>标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。</p><p>（2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p><p>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p><p>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h2 id="47、行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#47、行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="47、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>47、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><p>（1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，比如div默认display属性值为“block”，成为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p><p>（2）行内元素有：a b span img input select strong（强调的语气） 块级元素有：div<br>ul ol li dl dt dd h1 h2 h3 h4…p</p><p>（3）知名的空元素：</p><p>&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;鲜为人知的是：<br>&lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt;</p><p>&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt;</p><h2 id="48、CSS的盒子模型？"><a href="#48、CSS的盒子模型？" class="headerlink" title="48、CSS的盒子模型？"></a>48、CSS的盒子模型？</h2><p>（1）两种， IE 盒子模型、标准 W3C 盒子模型；IE 的content部分包含了 border 和<br>padding;</p><p>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p><h2 id="49、CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#49、CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="49、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>49、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h2><p>1.id选择器（ # myid）</p><p>2.类选择器（.myclassname）</p><p>3.标签选择器（div, h1, p）</p><p>4.相邻选择器（h1 + p）</p><p>5.子选择器（ul &lt; li）</p><p>6.后代选择器（li a）</p><p>7.通配符选择器（ * ）</p><p>8.属性选择器（a[rel = “external”]）</p><p>9.伪类选择器（a: hover, li: nth - child）</p><p>* 可继承： font-size font-family color, UL LI DL DD DT;</p><p>* 不可继承 ：border padding margin width height ;</p><p>* 优先级就近原则，样式定义最近者为准;</p><p>* 载入样式以最后载入的定位为准;</p><p>优先级为:</p><p>!important &gt; id &gt; class &gt; tag</p><p>important 比 内联优先级高</p><p>CSS3新增伪类举例：</p><p>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</p><p>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</p><p>:enabled、:disabled 控制表单控件的禁用状态。</p><p>:checked，单选框或复选框被选中。</p><h2 id="50、如何居中div-如何居中一个浮动元素"><a href="#50、如何居中div-如何居中一个浮动元素" class="headerlink" title="50、如何居中div,如何居中一个浮动元素?"></a>50、如何居中div,如何居中一个浮动元素?</h2><p>给div设置一个宽度，然后添加margin:0 auto属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:200px;</span><br><span class="line">margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>居中一个浮动元素</p><p>确定容器的宽高 宽500 高 300 的层</p><p>设置层的外边距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.div &#123;</span><br><span class="line">Width:500px ; height:300px;//高度可以不设</span><br><span class="line">Margin: -150px 0 0 -250px;</span><br><span class="line">position:relative;相对定位</span><br><span class="line">background-color:pink;//方便看效果</span><br><span class="line">left:50%;</span><br><span class="line">top:50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51、浏览器的内核分别是什么-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#51、浏览器的内核分别是什么-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="51、浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>51、浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h2><p>* IE浏览器的内核Trident、 Mozilla的Gecko、google的WebKit、Opera内核Presto；</p><p>* png24为的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p><p>*<br>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。<br>*<br>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p><p>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</p><p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入_display:inline;将其转化为行内属性。(<code>_这个符号只有ie6会识别</code>)</p><p>渐进识别的方式，从总体中逐渐排除局部。</p><p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。</p><p>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><p>.box{</p><p>background-color:#f1ee18;/*所有识别*/</p><p>.background-color:#00deff\9; /*IE6、7、8识别*/</p><p>+background-color:#a200ff;/*IE6、7识别*/</p><p>_background-color:#1e0bd1;/*IE6识别*/</p><p>}</p><p>* IE下,可以使用获取常规属性的方法来获取自定义属性,</p><p>也可以使用getAttribute()获取自定义属性;</p><p>Firefox下,只能使用getAttribute()获取自定义属性.</p><p>解决方法:统一通过getAttribute()获取自定义属性.</p><p>* IE下,even对象有x,y属性,但是没有pageX,pageY属性;</p><p>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p><p>* （条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS<br>属性 -webkit-text-size-adjust: none; 解决.</p><p>超链接访问过后hover样式就不出现了<br>被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</p><p>L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p><h2 id="52、列出display的值，说明他们的作用。position的值，-relative和absolute定位原点是？"><a href="#52、列出display的值，说明他们的作用。position的值，-relative和absolute定位原点是？" class="headerlink" title="52、列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？"></a>52、列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？</h2><p>display的值：<br>block 象块类型元素一样显示。</p><p>none 缺省值。向行内元素类型一样显示。</p><p>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</p><p>list-item 象块类型元素一样显示，并添加样式列表标记。</p><p>position的值：</p><p>absolute</p><p>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p><p>fixed （老IE不支持）</p><p>生成绝对定位的元素，相对于浏览器窗口进行定位。</p><p>relative</p><p>生成相对定位的元素，相对于其正常位置进行定位。</p><p>static 默认值。没有定位，元素出现在正常的流中</p><p>（忽略 top, bottom, left, right z-index 声明）。</p><p>inherit 规定从父元素继承 position 属性的值。</p><h2 id="53、absolute的containing-block计算方式跟正常流有什么不同？"><a href="#53、absolute的containing-block计算方式跟正常流有什么不同？" class="headerlink" title="53、absolute的containing block计算方式跟正常流有什么不同？"></a>53、absolute的containing block计算方式跟正常流有什么不同？</h2><p>无论属于哪种,都要先找到其祖先元素中最近的 position 值不为 static<br>的元素,然后再判断：</p><p>1、若此元素为 inline 元素,则 containing block<br>为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin,<br>border 外的区域) 的最小矩形；</p><p>2、否则,则由这个祖先元素的 padding box 构成。如果都找不到,则为 initial<br>containing block。</p><h2 id="54、position跟display、margin-collapse、overflow、float这些特性相互叠加后会怎么样？"><a href="#54、position跟display、margin-collapse、overflow、float这些特性相互叠加后会怎么样？" class="headerlink" title="54、position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？"></a>54、position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</h2><p><a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyWHJ/p/3756087.html</a></p><h2 id="55、对WEB标准以及W3C的理解与认识"><a href="#55、对WEB标准以及W3C的理解与认识" class="headerlink" title="55、对WEB标准以及W3C的理解与认识"></a>55、对WEB标准以及W3C的理解与认识</h2><p>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外<br>链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维<br>护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；</p><h2 id="56、css的基本语句构成是"><a href="#56、css的基本语句构成是" class="headerlink" title="56、css的基本语句构成是?"></a>56、css的基本语句构成是?</h2><p>选择器{属性1:值1;属性2:值2;……}</p><h2 id="57、浏览器标准模式和怪异模式之间的区别是什么"><a href="#57、浏览器标准模式和怪异模式之间的区别是什么" class="headerlink" title="57、浏览器标准模式和怪异模式之间的区别是什么?"></a>57、浏览器标准模式和怪异模式之间的区别是什么?</h2><p>盒子模型 渲染模式的不同</p><p>使用 window.top.document.compatMode 可显示为什么模式</p><h2 id="58、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？"><a href="#58、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？" class="headerlink" title="58、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？"></a>58、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？</h2><p>　　最基本的：</p><p>　　设置display属性为none，或者设置visibility属性为hidden</p><p>　　技巧性：</p><p>　　设置宽高为0，设置透明度为0，设置z-index位置在-1000</p><h2 id="59、超链接访问过后hover样式就不出现的问题是什么？如何解决？"><a href="#59、超链接访问过后hover样式就不出现的问题是什么？如何解决？" class="headerlink" title="59、超链接访问过后hover样式就不出现的问题是什么？如何解决？"></a>59、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h2><p>　　答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</p><h2 id="60、什么是Css-Hack？ie6-7-8的hack分别是什么？"><a href="#60、什么是Css-Hack？ie6-7-8的hack分别是什么？" class="headerlink" title="60、什么是Css Hack？ie6,7,8的hack分别是什么？"></a>60、什么是Css Hack？ie6,7,8的hack分别是什么？</h2><p>答案：重复题目</p><h2 id="61、这个问题被吃了…"><a href="#61、这个问题被吃了…" class="headerlink" title="61、这个问题被吃了…"></a>61、这个问题被吃了…</h2><h2 id="62、请用Css写一个简单的幻灯片效果页面"><a href="#62、请用Css写一个简单的幻灯片效果页面" class="headerlink" title="62、请用Css写一个简单的幻灯片效果页面"></a>62、请用Css写一个简单的幻灯片效果页面</h2><p>答案：重复题目</p><h2 id="63、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？"><a href="#63、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？" class="headerlink" title="63、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？"></a>63、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？</h2><p>　　块级元素(block)特性：</p><ul><li><p>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</p></li><li><p>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</p></li></ul><p>　　内联元素(inline)特性：</p><ul><li><p>和相邻的内联元素在同一行;</p></li><li><p>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。</p></li></ul><p>　　那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？</p><p>　　答案：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;textarea&gt; 、&lt;label&gt;</p><h2 id="64、什么是外边距重叠？重叠的结果是什么？"><a href="#64、什么是外边距重叠？重叠的结果是什么？" class="headerlink" title="64、什么是外边距重叠？重叠的结果是什么？"></a>64、什么是外边距重叠？重叠的结果是什么？</h2><p>　　答案：外边距重叠就是margin-collapse。</p><p>　　在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p><p>　　折叠结果遵循下列计算规则：</p><ol><li><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</p></li><li><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</p></li><li><p>两个外边距一正一负时，折叠结果是两者的相加的和。</p></li></ol><h2 id="65、rgba-和opacity的透明效果有什么不同？"><a href="#65、rgba-和opacity的透明效果有什么不同？" class="headerlink" title="65、rgba()和opacity的透明效果有什么不同？"></a>65、rgba()和opacity的透明效果有什么不同？</h2><p>　　rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，</p><p>　　而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p><h2 id="66、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#66、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="66、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>66、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h2><p>　　垂直方向：line-height</p><p>　　水平方向：letter-spacing</p><p>　　那么问题来了，关于letter-spacing的妙用知道有哪些么？</p><p>　　答案:可以用于消除inline-block元素间的换行符空格间隙问题。</p><h2 id="67、如何垂直居中一个浮动元素？"><a href="#67、如何垂直居中一个浮动元素？" class="headerlink" title="67、如何垂直居中一个浮动元素？"></a>67、如何垂直居中一个浮动元素？</h2><p>和28题重复</p><h2 id="68、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？"><a href="#68、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？" class="headerlink" title="68、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？"></a>68、描述一个”reset”的CSS文件并如何使用它。知道<strong>normalize.css</strong>吗？你了解他们的不同之处？</h2><p>　　重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。</p><p>　　你可能会用<a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">Normalize</a>来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p><p>　　在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。</p><h2 id="69、说display属性有哪些？可以做什么？"><a href="#69、说display属性有哪些？可以做什么？" class="headerlink" title="69、说display属性有哪些？可以做什么？"></a>69、说display属性有哪些？可以做什么？</h2><p>display:block行内元素转换为块级元素</p><p>display:inline块级元素转换为行内元素</p><p>display:inline-block转为内联元素</p><h2 id="70、哪些css属性可以继承？"><a href="#70、哪些css属性可以继承？" class="headerlink" title="70、哪些css属性可以继承？"></a>70、哪些css属性可以继承？</h2><p>可继承： font-size font-family color, ul li dl dd dt;</p><p>不可继承 ：border padding margin width height ;</p><h2 id="71、css优先级算法如何计算？"><a href="#71、css优先级算法如何计算？" class="headerlink" title="71、css优先级算法如何计算？"></a>71、css优先级算法如何计算？</h2><p>!important &gt; id &gt; class &gt; 标签</p><p>!important 比 内联优先级高</p><p>*优先级就近原则，样式定义最近者为准;</p><p>*以最后载入的样式为准;</p><h2 id="72、b标签和strong标签-i标签和em标签的区别？"><a href="#72、b标签和strong标签-i标签和em标签的区别？" class="headerlink" title="72、b标签和strong标签,i标签和em标签的区别？"></a>72、b标签和strong标签,i标签和em标签的区别？</h2><p>后者有语义，前者则无。</p><h2 id="73、有那些行内元素、有哪些块级元素、盒模型？"><a href="#73、有那些行内元素、有哪些块级元素、盒模型？" class="headerlink" title="73、有那些行内元素、有哪些块级元素、盒模型？"></a>73、有那些行内元素、有哪些块级元素、盒模型？</h2><ul><li><p>1.内联元素(inline element)<br>a – 锚点<br>abbr – 缩写<br>acronym – 首字<br>b – 粗体(不推荐)<br>big – 大字体<br>br – 换行<br>em – 强调<br>font – 字体设定(不推荐)<br>i – 斜体<br>img – 图片<br>input – 输入框<br>label – 表格标签<br>s – 中划线(不推荐)<br>select – 项目选择<br>small – 小字体文本<br>span – 常用内联容器，定义文本内区块<br>strike – 中划线<br>strong – 粗体强调<br>sub – 下标<br>sup – 上标<br>textarea – 多行文本输入框<br>tt – 电传文本<br>u – 下划线<br>var – 定义变量</p></li><li><p>2、块级元素<br>address – 地址<br>blockquote – 块引用<br>center – 举中对齐块<br>dir – 目录列表<br>div – 常用块级容易，也是css layout的主要标签<br>dl – 定义列表<br>fieldset – form控制组<br>form – 交互表单<br>h1 – 大标题<br>h2 – 副标题<br>h3 – 3级标题<br>h4 – 4级标题<br>h5 – 5级标题<br>h6 – 6级标题<br>hr – 水平分隔线<br>isindex – input prompt<br>menu – 菜单列表<br>noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容）<br>noscript – ）可选脚本内容（对于不支持script的浏览器显示此内容）<br>ol – 排序表单<br>p – 段落<br>pre – 格式化文本<br>table – 表格<br>ul – 非排序列表</p></li><li><p>3.CSS盒子模型包含四个部分组成：<br>内容content、填充（padding）、边框（border）、外边界（margin）。</p></li></ul><h2 id="74、有哪些选择符，优先级的计算公式是什么？行内样式和！important哪个优先级高？"><a href="#74、有哪些选择符，优先级的计算公式是什么？行内样式和！important哪个优先级高？" class="headerlink" title="74、有哪些选择符，优先级的计算公式是什么？行内样式和！important哪个优先级高？"></a>74、有哪些选择符，优先级的计算公式是什么？行内样式和！important哪个优先级高？</h2><p>#ID &gt; .class &gt; 标签选择符<br>!important优先级高</p><h2 id="75、我想让行内元素跟上面的元素距离10px，加margin-top和padding-top可以吗？"><a href="#75、我想让行内元素跟上面的元素距离10px，加margin-top和padding-top可以吗？" class="headerlink" title="75、我想让行内元素跟上面的元素距离10px，加margin-top和padding-top可以吗？"></a>75、我想让行内元素跟上面的元素距离10px，加margin-top和padding-top可以吗？</h2><p>margin-top,padding-top无效</p><h2 id="76、CSS的盒模型由什么组成？"><a href="#76、CSS的盒模型由什么组成？" class="headerlink" title="76、CSS的盒模型由什么组成？"></a>76、CSS的盒模型由什么组成？</h2><p>内容，border ,margin，padding</p><h2 id="77、说说display属性有哪些？可以做什么？"><a href="#77、说说display属性有哪些？可以做什么？" class="headerlink" title="77、说说display属性有哪些？可以做什么？"></a>77、说说display属性有哪些？可以做什么？</h2><p>display:block行内元素转换为块级元素</p><p>display:inline块级元素转换为行内元素</p><p>display:inline-block转为内联元素</p><h2 id="78、哪些css属性可以继承？"><a href="#78、哪些css属性可以继承？" class="headerlink" title="78、哪些css属性可以继承？"></a>78、哪些css属性可以继承？</h2><p>可继承： font-size font-family color, ul li dl dd dt;</p><p>不可继承 ：border padding margin width height ;</p><h2 id="79、css优先级算法如何计算？"><a href="#79、css优先级算法如何计算？" class="headerlink" title="79、css优先级算法如何计算？"></a>79、css优先级算法如何计算？</h2><p>!important &gt; id &gt; class &gt; 标签</p><p>!important 比 内联优先级高</p><p>* 优先级就近原则，样式定义最近者为准;</p><p>* 以最后载入的样式为准;</p><h2 id="80、text-align-center和line-height有什么区别？"><a href="#80、text-align-center和line-height有什么区别？" class="headerlink" title="80、text-align:center和line-height有什么区别？"></a>80、text-align:center和line-height有什么区别？</h2><p>text-align是水平对齐，line-height是行间。</p><h2 id="81、前端页面由哪三层构成，分别是什么？作用是什么？"><a href="#81、前端页面由哪三层构成，分别是什么？作用是什么？" class="headerlink" title="81、前端页面由哪三层构成，分别是什么？作用是什么？"></a>81、前端页面由哪三层构成，分别是什么？作用是什么？</h2><p>结构层 Html 表示层 CSS 行为层 js</p><h2 id="82、写一个表格以及对应的CSS-使表格奇数行为白色背景，偶数行为灰色，鼠标一上去为黄色背景。"><a href="#82、写一个表格以及对应的CSS-使表格奇数行为白色背景，偶数行为灰色，鼠标一上去为黄色背景。" class="headerlink" title="82、写一个表格以及对应的CSS,使表格奇数行为白色背景，偶数行为灰色，鼠标一上去为黄色背景。"></a>82、写一个表格以及对应的CSS,使表格奇数行为白色背景，偶数行为灰色，鼠标一上去为黄色背景。</h2><hr><h1 id="JS基础部分"><a href="#JS基础部分" class="headerlink" title="JS基础部分"></a>JS基础部分</h1><h2 id="1、javascript的typeof返回哪些数据类型"><a href="#1、javascript的typeof返回哪些数据类型" class="headerlink" title="1、javascript的typeof返回哪些数据类型"></a>1、javascript的typeof返回哪些数据类型</h2><p>object number function boolean underfind string</p><p>typeof null;//object</p><p>typeof isNaN;//</p><p>typeof isNaN(123)</p><p>typeof [];//object</p><p>Array.isARRAY(); es5</p><p>toString.call([]);//”[object Array]”</p><p>var arr=[];</p><p>arr.constructor;//Array</p><h2 id="2、例举3种强制类型转换和2种隐式类型转换"><a href="#2、例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="2、例举3种强制类型转换和2种隐式类型转换?"></a>2、例举3种强制类型转换和2种隐式类型转换?</h2><p>强制（parseInt,parseFloat,Number()）</p><p>隐式（==）</p><p>1==”1”//true</p><p>null==undefined//true</p><h2 id="3、split-join-的区别"><a href="#3、split-join-的区别" class="headerlink" title="3、split() join() 的区别"></a>3、split() join() 的区别</h2><p>前者是切割成数组的形式，</p><p>后者是将数组转换成字符串</p><h2 id="4、数组方法pop-push-unshift-shift"><a href="#4、数组方法pop-push-unshift-shift" class="headerlink" title="4、数组方法pop() push() unshift() shift()"></a>4、数组方法pop() push() unshift() shift()</h2><p>Push()尾部添加 pop()尾部删除</p><p>Unshift()头部添加 shift()头部删除</p><h2 id="5、事件绑定和普通事件有什么区别"><a href="#5、事件绑定和普通事件有什么区别" class="headerlink" title="5、事件绑定和普通事件有什么区别"></a>5、事件绑定和普通事件有什么区别</h2><p>传统事件绑定和符合W3C标准的事件绑定有什么区别？</p><p>普通事件:div1.onclick=function(){};</p><p>&lt;button onmouseover=””&gt;&lt;/button&gt;</p><p>1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定</p><p>2、不支持DOM事件流 事件捕获阶段目标元素阶段=&gt;事件冒泡阶段</p><p>事件绑定:addEventListener</p><ol><li><p>如果说给同一个元素绑定了两次或者多次相同类型的事件，所以的绑定将会依次触发</p></li><li><p>支持DOM事件流的</p></li><li><p>进行事件绑定传参不需要on前缀</p></li></ol><p>addEventListener(“click”,function(){},true);//此时的事件就是在事件冒泡阶段执行</p><p>ie9开始，ie11 edge：addEventListener</p><p>ie9以前：attachEvent/detachEvent</p><ol><li><p>进行事件类型传参需要带上on前缀</p></li><li><p>这种方式只支持事件冒泡，不支持事件捕获</p></li></ol><p>事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</p><p>普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，不支持事件冒泡</p><p>而事件绑定（addEventListener）方式添加事件可以添加多个,支持事件冒泡</p><h2 id="6、IE和DOM事件流的区别"><a href="#6、IE和DOM事件流的区别" class="headerlink" title="6、IE和DOM事件流的区别"></a>6、IE和DOM事件流的区别</h2><p>1.执行顺序不一样、</p><p>2.参数不一样</p><p>3.事件加不加on</p><p>4.this指向问题</p><p><strong>IE9以前</strong>：<a href="http://www.baidu.com/link?url=fVtfIQaNBwj3KUO_767M8Y2AoHQa2q1pSY0iwTzkigv1ue0E8r5tBI4bezzlCu01KrbygrzNAJ-jw5H8FTc-1a" target="_blank" rel="noopener">attachEvent(“onclick”)、detachEvent</a>(“onclick”)</p><p><strong>IE9开始</strong>跟DOM事件流是一样的，都是addEventListener</p><h2 id="7、IE和标准下有哪些兼容性的写法"><a href="#7、IE和标准下有哪些兼容性的写法" class="headerlink" title="7、IE和标准下有哪些兼容性的写法"></a>7、IE和标准下有哪些兼容性的写法</h2><p>var ev = ev || window.event</p><p>document.documentElement.clientWidth || document.body.clientWidth</p><p>var target = ev.srcElement||ev.target</p><h2 id="8、call和apply的区别"><a href="#8、call和apply的区别" class="headerlink" title="8、call和apply的区别"></a>8、call和apply的区别</h2><p>call和apply相同点：</p><p>都是为了用一个本不属于一个对象的方法，让这个对象去执行</p><p>toString.call([],1,2,3)</p><p>toString.apply([],[1,2,3])</p><p>Object.call(this,obj1,obj2,obj3)</p><p>Object.apply(this,arguments)</p><h2 id="9、b继承a的方法"><a href="#9、b继承a的方法" class="headerlink" title="9、b继承a的方法"></a>9、b继承a的方法</h2><p>考点：继承的多种方式</p><p>function b(){}</p><p>b.prototype=new a;</p><h2 id="10、JavaScript-this指针、闭包、作用域"><a href="#10、JavaScript-this指针、闭包、作用域" class="headerlink" title="10、JavaScript this指针、闭包、作用域"></a>10、JavaScript this指针、闭包、作用域</h2><p>this：指向调用上下文</p><p>闭包：内层作用域可以访问外层作用域的变量</p><p>作用域：定义一个函数就开辟了一个局部作用域，整个js执行环境有一个全局作用域</p><h2 id="11、事件委托是什么"><a href="#11、事件委托是什么" class="headerlink" title="11、事件委托是什么"></a>11、事件委托是什么</h2><p>符合W3C标准的事件绑定addEventLisntener /attachEvent</p><p>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p><h2 id="12、闭包是什么，有什么特性，对页面有什么影响"><a href="#12、闭包是什么，有什么特性，对页面有什么影响" class="headerlink" title="12、闭包是什么，有什么特性，对页面有什么影响"></a>12、闭包是什么，有什么特性，对页面有什么影响</h2><p>闭包就是能够读取其他函数内部变量的函数。</p><p>闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数</p><h2 id="13、如何阻止事件冒泡和默认事件"><a href="#13、如何阻止事件冒泡和默认事件" class="headerlink" title="13、如何阻止事件冒泡和默认事件"></a>13、如何阻止事件冒泡和默认事件</h2><p>e.stopPropagation();//标准浏览器</p><p>event.canceBubble=true;//ie9之前</p><p>阻止默认事件：</p><p>为了不让a点击之后跳转，我们就要给他的点击事件进行阻止</p><p>return false</p><p>e.preventDefault();</p><h2 id="14、添加-删除-替换-插入到某个接点的方法"><a href="#14、添加-删除-替换-插入到某个接点的方法" class="headerlink" title="14、添加 删除 替换 插入到某个接点的方法"></a>14、添加 删除 替换 插入到某个接点的方法</h2><p>obj.appendChild()</p><p>obj.insertBefore() //原生的js中不提供insertAfter();</p><p>obj.replaceChild()//替换</p><p>obj.removeChild()//删除</p><h2 id="15、javascript的本地对象，内置对象和宿主对象"><a href="#15、javascript的本地对象，内置对象和宿主对象" class="headerlink" title="15、javascript的本地对象，内置对象和宿主对象"></a>15、javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为array obj regexp等可以new实例化</p><p>内置对象为gload Math 等不可以实例化的</p><p>宿主为浏览器自带的document,window 等</p><h2 id="16、document-load-和document-ready的区别"><a href="#16、document-load-和document-ready的区别" class="headerlink" title="16、document load 和document ready的区别"></a>16、document load 和document ready的区别</h2><p>Document.onload 是在结构和样式加载完才执行js</p><p>window.onload：不仅仅要在结构和样式加载完，还要执行完所有的样式、图片这些资源文件，全部加载完才会触发window.onload事件</p><p>Document.ready原生种没有这个方法，jquery中有 $().ready(function)</p><h2 id="17、”-”和“-”的不同"><a href="#17、”-”和“-”的不同" class="headerlink" title="17、”==”和“===”的不同"></a>17、”==”和“===”的不同</h2><p>前者会自动转换类型</p><p>后者不会</p><p>1==”1”</p><p>null==undefined</p><p>===先判断左右两边的数据类型，如果数据类型不一致，直接返回false</p><p>之后才会进行两边值的判断</p><h2 id="18、javascript的同源策略"><a href="#18、javascript的同源策略" class="headerlink" title="18、javascript的同源策略"></a>18、javascript的同源策略</h2><p>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合</p><p>http,ftp:协议</p><p>主机名；localhost</p><p>端口名：80:http协议的默认端口</p><blockquote><p>  https:默认端口是8083</p></blockquote><p>同源策略带来的麻烦：ajax在不同域名下的请求无法实现，</p><p>如果说想要请求其他来源的js文件，或者json数据，那么可以通过jsonp来解决</p><h2 id="19、编写一个数组去重的方法"><a href="#19、编写一个数组去重的方法" class="headerlink" title="19、编写一个数组去重的方法"></a>19、编写一个数组去重的方法</h2><p>var arr=[1,1,3,4,2,4,7];</p><p>=&gt;[1,3,4,2,7]</p><p>一个比较简单的实现就是：</p><ol><li><p>先创建一个空数组，用来保存最终的结果</p></li><li><p>循环原数组中的每个元素</p></li><li><p>再对每个元素进行二次循环，判断是否有与之相同的元素，如果没有，将把这个元素放到新数组中</p></li><li><p>返回这个新数组</p></li></ol><p>function oSort(arr) {<br>var result ={};<br>var newArr=[];<br>for(var i=0;i&lt;arr.length;i++){<br>if(!result[arr]) {<br>newArr.push(arr)<br>result[arr]=1<br>}  }<br>return newArr<br>}&lt;/arr.length;i++)</p><h2 id="20、JavaScript是一门什么样的语言，它有哪些特点？"><a href="#20、JavaScript是一门什么样的语言，它有哪些特点？" class="headerlink" title="20、JavaScript是一门什么样的语言，它有哪些特点？"></a>20、JavaScript是一门什么样的语言，它有哪些特点？</h2><p>没有标准答案。</p><p>运行环境：浏览器中的JS引擎（v8.。。）</p><p>语言特性：面向对象，动态语言：</p><p>//动态语言的特性<br>var <em>num</em>=10;//num是一个数字类型<br><em>num</em>=”jim”;//此时num又变成一个字符串类型<br>//我们把一个变量用来保存不同数据类型的语言称之为一个动态语言<br>//静态语言：c# java c c++<br>//静态语言在声明一个变量就已经确定了这个变量的数据类型，<br>// 而且在任何时候都不可以改变他的数据类型</p><h2 id="21、JavaScript的数据类型都有什么？"><a href="#21、JavaScript的数据类型都有什么？" class="headerlink" title="21、JavaScript的数据类型都有什么？"></a>21、JavaScript的数据类型都有什么？</h2><p>基本数据类型：String,Boolean,number,undefined,object,Null</p><p>引用数据类型：Object(Array,Date,RegExp,Function)</p><p>那么问题来了，如何判断某变量是否为数组数据类型？</p><p>方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效</p><p>方法二.obj instanceof Array 在某些IE版本中不正确</p><p>方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(),<br>保证其兼容性，最好的方法如下：</p><p>toString.call(18);//”[object Number]”</p><p>toString.call(“”);//”[object String]”</p><p>解析这种简单的数据类型直接通过typeof就可以直接判断</p><p>toString.call常用于判断数组、正则这些复杂类型</p><p>toString.call(/[0-9]{10}/)//”[object RegExp]”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray===&quot;undefined&quot;)&#123;   </span><br><span class="line">Array.isArray = function(arg)&#123;         </span><br><span class="line">return Object.prototype.toString.call(arg)===&quot;[object Array]&quot;   </span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架"><a href="#22、已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架" class="headerlink" title="22、已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)"></a>22、已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)</h2><p>document.getElementById(“ID”).value</p><h2 id="23、希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#23、希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="23、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>23、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var domList = document.getElementsByTagName(‘input’) </span><br><span class="line">var checkBoxList = [];//返回的所有的checkbox</span><br><span class="line">var len = domList.length;　　//缓存到局部变量 </span><br><span class="line">while (len--) &#123;　　//使用while的效率会比for循环更高 　　</span><br><span class="line">if (domList[len].type == ‘checkbox’) &#123;     　　</span><br><span class="line">checkBoxList.push(domList[len]); 　　</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架"><a href="#24、设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架" class="headerlink" title="24、设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)"></a>24、设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(“ID”); </span><br><span class="line">dom.innerHTML = “xxxx” dom.style.color = “\#000”</span><br></pre></td></tr></table></figure><h2 id="25、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><a href="#25、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？" class="headerlink" title="25、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"></a>25、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？</h2><p>直接在DOM里绑定事件：&lt;div onclick=”test()”&gt;&lt;/div&gt;</p><p>在JS里通过onclick绑定：xxx.onclick = test</p><p>通过事件添加进行绑定：addEventListener(xxx, ‘click’, test)</p><p>那么问题来了，Javascript的事件流模型都有什么？</p><p>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播</p><p>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的</p><p>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</p><h2 id="26、看下列代码输出为何？解释原因。"><a href="#26、看下列代码输出为何？解释原因。" class="headerlink" title="26、看下列代码输出为何？解释原因。"></a>26、看下列代码输出为何？解释原因。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a; </span><br><span class="line">alert(typeof a); // “undefined” </span><br><span class="line">alert(b); // 报错 </span><br><span class="line">b=10; </span><br><span class="line">alert(typeof b);//”number”</span><br></pre></td></tr></table></figure><p>解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。</p><p><strong>undefined</strong>会在以下三种情况下产生：</p><ol><li><p>一个变量定义了却没有被赋值</p></li><li><p>想要获取一个对象上不存在的属性或者方法:</p></li><li><p>一个数组中没有被赋值的元素</p></li></ol><p>注意区分undefined跟not defnied(语法错误)是不一样的</p><h2 id="27、看下列代码-输出什么？解释原因。"><a href="#27、看下列代码-输出什么？解释原因。" class="headerlink" title="27、看下列代码,输出什么？解释原因。"></a>27、看下列代码,输出什么？解释原因。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = null; </span><br><span class="line">alert(typeof a); //object</span><br></pre></td></tr></table></figure><p>解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。</p><h2 id="28、看下列代码-输出什么？解释原因。"><a href="#28、看下列代码-输出什么？解释原因。" class="headerlink" title="28、看下列代码,输出什么？解释原因。"></a>28、看下列代码,输出什么？解释原因。</h2><p>var undefined;//此时undefined这个变量的值是undefined<br>undefined == null; // true<br>1 == true;   // true<br>此时会把布尔类型的值转换为数字类型 true=1 false=0<br>2 == true;   // false<br>0 == false;  // true<br>0 == ‘’;     // true<br>NaN == NaN;  // false<br>[] == false; // true<br>[] == ![];   // true</p><p>undefined与null相等，但不恒等（===）<br>一个是number一个是string时，会尝试将string转换为number<br>尝试将boolean转换为number，0或1<br>尝试将Object转换成number或string，取决于另外一个对比量的类型<br>所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。</p><p>那么问题来了，看下面的代码，输出什么，foo的值为什么？</p><p> var foo = “11”+2-“1”;<br> console.log(foo);//111<br> console.log(typeof foo); </p><p>执行完后foo的值为111，foo的类型为number。</p><h2 id="29、看代码给答案。"><a href="#29、看代码给答案。" class="headerlink" title="29、看代码给答案。"></a>29、看代码给答案。</h2><p>var a = new Object();<br>a.value = 1;<br>b = a; {value:1}<br>b.value = 2;<br>alert(a.value);//2</p><p>答案：2（考察引用数据类型细节）</p><h2 id="30、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。"><a href="#30、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。" class="headerlink" title="30、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。"></a>30、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。</h2><p>答案：alert(stringArray.join(“ ”))</p><p>已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function combo(msg)&#123;</span><br><span class="line">    var arr=msg.split(&quot;-&quot;);//[get,element,by,id]</span><br><span class="line">    for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line"> arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);//Element</span><br><span class="line">    &#125;</span><br><span class="line">    msg=arr.join(&quot;&quot;);//msg=” getElementById”</span><br><span class="line">    return msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(考察基础API)</p><h2 id="31、var-numberArray-3-6-2-4-1-5-（考察基础API）"><a href="#31、var-numberArray-3-6-2-4-1-5-（考察基础API）" class="headerlink" title="31、var numberArray = [3,6,2,4,1,5]; （考察基础API）"></a>31、var numberArray = [3,6,2,4,1,5]; （考察基础API）</h2><p>1) 实现对该数组的倒排，输出[5,1,4,2,6,3]</p><p>2) 实现对该数组的降序排列，输出[6,5,4,3,2,1]</p><h2 id="32、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"><a href="#32、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26" class="headerlink" title="32、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"></a>32、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</h2><h2 id="33、将字符串”-lt-tr-gt-lt-td-gt-id-lt-td-gt-lt-td-gt-name-lt-td-gt-lt-tr-gt-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）"><a href="#33、将字符串”-lt-tr-gt-lt-td-gt-id-lt-td-gt-lt-td-gt-name-lt-td-gt-lt-tr-gt-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）" class="headerlink" title="33、将字符串”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）"></a>33、将字符串”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）</h2><h2 id="34、为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-lt-gt-amp-“进行转义"><a href="#34、为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-lt-gt-amp-“进行转义" class="headerlink" title="34、为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义"></a>34、为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function escapeHtml(str) &#123;</span><br><span class="line">//[&lt;&gt;”&amp;]:中括号中字符只要其中的一个出现就代表满足条件</span><br><span class="line">//给replace第二个参数传递一个回调函数，回调函数中参数就是匹配结果，如果匹配不到就是null</span><br><span class="line">return str.replace(/[&lt;&gt;”&amp;]/g, function(match) &#123;</span><br><span class="line">    switch (match) &#123;</span><br><span class="line">      case “&lt;”:</span><br><span class="line">         return “&amp;lt;”;</span><br><span class="line">      case “&gt;”:</span><br><span class="line">          return “&amp;gt;”;</span><br><span class="line">      case “&amp;”:</span><br><span class="line">          return “&amp;amp;”;</span><br><span class="line">      case “\””:</span><br><span class="line">         return “&amp;quot;”;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35、foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#35、foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="35、foo = foo||bar ，这行代码是什么意思？为什么要这样写？"></a>35、foo = foo||bar ，这行代码是什么意思？为什么要这样写？</h2><p>这种写法称之为短路表达式</p><p>答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。</p><p>短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</p><p>注意if条件的真假判定，<strong>记住以下是false的情况</strong>：</p><p><strong>空字符串、false、undefined、null、0</strong></p><h2 id="36、看下列代码，将会输出什么-变量声明提升"><a href="#36、看下列代码，将会输出什么-变量声明提升" class="headerlink" title="36、看下列代码，将会输出什么?(变量声明提升)"></a>36、看下列代码，将会输出什么?(变量声明提升)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1; </span><br><span class="line">function()&#123;     </span><br><span class="line">console.log(foo);     </span><br><span class="line">var foo = 2;    </span><br><span class="line">console.log(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：输出undefined 和 2。上面代码相当于：</p><p>函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。</p><h2 id="37、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"><a href="#37、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。" class="headerlink" title="37、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"></a>37、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</h2><h2 id="38、把两个数组合并，并删除第二个元素。"><a href="#38、把两个数组合并，并删除第二个元素。" class="headerlink" title="38、把两个数组合并，并删除第二个元素。"></a>38、把两个数组合并，并删除第二个元素。</h2><p>var array1 = [‘a’,’b’,’c’];<br>var bArray = [‘d’,’e’,’f’];<br>var cArray = array1.<strong>concat</strong>(bArray); cArray.splice(1,1); |</p><h2 id="39、怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"><a href="#39、怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）" class="headerlink" title="39、怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"></a>39、怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）</h2><p>1）创建新节点</p><p>createDocumentFragment()    //创建一个DOM片段</p><p>createElement()   //创建一个具体的元素</p><p>createTextNode()   //创建一个文本节点</p><p>2）添加、移除、替换、插入</p><p>appendChild()      //添加</p><p>removeChild()      //移除</p><p>replaceChild()      //替换</p><p>insertBefore()      //插入</p><p>3）查找</p><p>getElementsByTagName()    //通过标签名称</p><p>getElementsByName()     //通过元素的Name属性的值</p><p>getElementById()        //通过元素Id，唯一性</p><h2 id="40、有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-1′-b-2′-c-’’-d-’xxx’-e-undefined-。"><a href="#40、有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-1′-b-2′-c-’’-d-’xxx’-e-undefined-。" class="headerlink" title="40、有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:1′, b:2′, c:’’, d:’xxx’, e:undefined}。"></a>40、有这样一个URL：<code>http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</code>，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:1′, b:2′, c:’’, d:’xxx’, e:undefined}。</h2><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&apos;;  </span><br><span class="line">var result = &#123;&#125;;  </span><br><span class="line">url = url.split(&quot;?&quot;)[1];  </span><br><span class="line">var map = url.split(&quot;&amp;&quot;);</span><br><span class="line">console.log(map); </span><br><span class="line">for(var i = 0; i &lt; map.length; i++) &#123;  </span><br><span class="line">var arr = map[i].split(&apos;=&apos;);</span><br><span class="line">result[arr[0]] = arr[1];  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h2 id="41、正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#41、正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="41、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？"></a>41、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？</h2><p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\\表示一个\）。使用正则表达字面量的效率更高。 </p><p>邮箱的正则匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/</span><br></pre></td></tr></table></figure><p>24.看下面代码，给出输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i\&lt;=3;i++)&#123;   </span><br><span class="line">setTimeout(function()&#123;       </span><br><span class="line">console.log(i);      </span><br><span class="line">&#125;,0);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>答案：4 4 4。</p><p>原因：Javascript事件处理器在线程空闲之前不会运行。追问，如何让上述代码输出1 2<br>3？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i\&lt;=3;i++)&#123;    </span><br><span class="line">setTimeout((function(a)&#123;  //改成立即执行函数        </span><br><span class="line">console.log(a);       </span><br><span class="line">&#125;)(i),0);  </span><br><span class="line">&#125;;           //输出 1 2 3</span><br></pre></td></tr></table></figure><h2 id="42、写一个function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#42、写一个function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="42、写一个function，清除字符串前后的空格。（兼容所有浏览器）"></a>42、写一个function，清除字符串前后的空格。（兼容所有浏览器）</h2><p>使用自带接口trim()，考虑兼容性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.trim) &#123; </span><br><span class="line"> String.prototype.trim = function() &#123; </span><br><span class="line"> return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;);</span><br><span class="line">//\s匹配空白字符：回车、换行、制表符tab 空格</span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"> // test the function </span><br><span class="line">var str = &quot; \t\n test string &quot;.trim(); </span><br><span class="line">alert(str == &quot;test string&quot;); // alerts &quot;true&quot;</span><br></pre></td></tr></table></figure><h2 id="43、Javascript中callee和caller的作用？"><a href="#43、Javascript中callee和caller的作用？" class="headerlink" title="43、Javascript中callee和caller的作用？"></a>43、Javascript中callee和caller的作用？</h2><p>arguments.callee：获得当前函数的引用</p><p>caller是返回一个对函数的引用，该函数调用了当前函数；</p><p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p><p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var result=[];</span><br><span class="line">function fn(n)&#123;  //典型的斐波那契数列</span><br><span class="line">   if(n==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">   &#125;else if(n==2)&#123;</span><br><span class="line">           return 1;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">        if(result[n])&#123;</span><br><span class="line">                return result[n];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                //argument.callee()表示fn()</span><br><span class="line">                result[n]=arguments.callee(n-1)+arguments.callee(n-2);</span><br><span class="line">                return result[n];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44、Javascript中-以下哪条语句一定会产生运行错误？-答案-BC"><a href="#44、Javascript中-以下哪条语句一定会产生运行错误？-答案-BC" class="headerlink" title="44、Javascript中, 以下哪条语句一定会产生运行错误？ 答案( BC )"></a>44、Javascript中, 以下哪条语句一定会产生运行错误？ 答案( BC )</h2><p>A、var _变量=NaN;<br>B、var 0bj = [];<br>C、var obj = //;<br>D、var obj = {};</p><h2 id="45、以下两个变量a和b，a-b的哪个结果是NaN？-答案-C"><a href="#45、以下两个变量a和b，a-b的哪个结果是NaN？-答案-C" class="headerlink" title="45、以下两个变量a和b，a+b的哪个结果是NaN？ 答案( C )"></a>45、以下两个变量a和b，a+b的哪个结果是NaN？ 答案( C )</h2><p>A、var a=undefind; b=NaN // undefind拼写错误</p><p>B、var a=‘123’; b=NaN//字符串’中文输入法</p><p>C、var a =undefined , b =NaN</p><p>D、var a=NaN , b=’undefined’//” NaNundefined”</p><h2 id="46、var-a-10-b-20-c-4-b-c-a-以下哪个结果是正确的？答案-B"><a href="#46、var-a-10-b-20-c-4-b-c-a-以下哪个结果是正确的？答案-B" class="headerlink" title="46、var a=10; b=20; c=4; ++b+c+a++ 以下哪个结果是正确的？答案( B )"></a>46、var a=10; b=20; c=4; ++b+c+a++ 以下哪个结果是正确的？答案( B )</h2><p>A、34<br>B、35<br>C、36<br>D、37</p><h2 id="47、下面的JavaScript语句中，（-D-）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空"><a href="#47、下面的JavaScript语句中，（-D-）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空" class="headerlink" title="47、下面的JavaScript语句中，（ D ）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空"></a>47、下面的JavaScript语句中，（ D ）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A. for(vari=0;i&lt;form1.elements.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">if(form1.elements.type==”text”)</span><br><span class="line"></span><br><span class="line">form1.elements.value=”&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B. for(vari=0;i&lt;document.forms.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">if(forms[0].elements.type==”text”)</span><br><span class="line"></span><br><span class="line">forms[0].elements.value=”&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C. if(document.form.elements.type==”text”)&#123;</span><br><span class="line"></span><br><span class="line">form.elements.value=”&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D. for(vari=0;i\&lt;document.forms.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">for(var j=0;j\&lt;document.forms.elements.length; j++)&#123;</span><br><span class="line"></span><br><span class="line">if(document.forms.elements[j].type==”text”)&#123;</span><br><span class="line"></span><br><span class="line">document.forms.elements[j].value=”&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48、要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是（-A-）"><a href="#48、要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是（-A-）" class="headerlink" title="48、要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是（ A ）"></a>48、要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是（ A ）</h2><p>A. window.status=”已经选中该文本框”<br>B. document.status=”已经选中该文本框”<br>C. window.screen=”已经选中该文本框”<br>D. document.screen=”已经选中该文本框”</p><h2 id="49、以下哪条语句会产生运行错误：（A、D）"><a href="#49、以下哪条语句会产生运行错误：（A、D）" class="headerlink" title="49、以下哪条语句会产生运行错误：（A、D）"></a>49、以下哪条语句会产生运行错误：（A、D）</h2><p>A.var obj = ();<br>B.var obj = [];<br>C.var obj = {};<br>D.var obj = //;</p><h2 id="50、以下哪个单词不属于javascript保留字：（B）"><a href="#50、以下哪个单词不属于javascript保留字：（B）" class="headerlink" title="50、以下哪个单词不属于javascript保留字：（B）"></a>50、以下哪个单词不属于javascript保留字：（B）</h2><p>A.with<br>B.parent<br>C.class<br>D.void</p><h2 id="51、请选择结果为真的表达式：（C）"><a href="#51、请选择结果为真的表达式：（C）" class="headerlink" title="51、请选择结果为真的表达式：（C）"></a>51、请选择结果为真的表达式：（C）</h2><p>A.null instanceof Object<br>B.null === undefined<br>C.null == undefined<br>D.NaN == NaN</p><h2 id="52、Javascript中-如果已知HTML页面中的某标签对象的id-”username”，用-document-getElementById-‘username’-方法获得该标签对象。"><a href="#52、Javascript中-如果已知HTML页面中的某标签对象的id-”username”，用-document-getElementById-‘username’-方法获得该标签对象。" class="headerlink" title="52、Javascript中, 如果已知HTML页面中的某标签对象的id=”username”，用__document.getElementById(‘username’)_ _方法获得该标签对象。"></a>52、Javascript中, 如果已知HTML页面中的某标签对象的id=”username”，用<strong>__document.getElementById(‘username’)</strong>_ _方法获得该标签对象。</h2><h2 id="53、typeof运算符返回值中有一个跟javascript数据类型不一致，它是-”function”-。"><a href="#53、typeof运算符返回值中有一个跟javascript数据类型不一致，它是-”function”-。" class="headerlink" title="53、typeof运算符返回值中有一个跟javascript数据类型不一致，它是____”function”_____。"></a>53、typeof运算符返回值中有一个跟javascript数据类型不一致，它是<strong>____</strong>”function”<strong>_____</strong>。</h2><p>typeof Number</p><p>typeof Object</p><h2 id="54、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示undefined-。"><a href="#54、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示undefined-。" class="headerlink" title="54、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示undefined___ 。"></a>54、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示<strong><em>undefined__</em></strong>_ 。</h2><h2 id="55、分析代码，得出正确的结果。"><a href="#55、分析代码，得出正确的结果。" class="headerlink" title="55、分析代码，得出正确的结果。"></a>55、分析代码，得出正确的结果。</h2><p>var a=10, b=20 , c=30;<br>++a;<br>a++;<br>e=++a+(++b)+(c++)+a++;<br>alert(e);</p><p>弹出提示对话框：77</p><h2 id="56、写出函数DateDemo的返回结果，系统时间假定为今天"><a href="#56、写出函数DateDemo的返回结果，系统时间假定为今天" class="headerlink" title="56、写出函数DateDemo的返回结果，系统时间假定为今天"></a>56、写出函数DateDemo的返回结果，系统时间假定为今天</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function DateDemo()&#123;</span><br><span class="line">var d, s=&quot;今天日期是：&quot;;</span><br><span class="line">d = new Date();</span><br><span class="line">s += d.getMonth() + &quot;/&quot;;</span><br><span class="line">s += d.getDate() + &quot;/&quot;;</span><br><span class="line">s += d.**getFullYear**();</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：今天日期是：7/17/2010</p><h2 id="57、写出程序运行的结果？"><a href="#57、写出程序运行的结果？" class="headerlink" title="57、写出程序运行的结果？"></a>57、写出程序运行的结果？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123;</span><br><span class="line">k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：10</p><h2 id="58、阅读以下代码，请分析出结果："><a href="#58、阅读以下代码，请分析出结果：" class="headerlink" title="58、阅读以下代码，请分析出结果："></a>58、阅读以下代码，请分析出结果：</h2><p>var arr = new Array(1 ,3 ,5);</p><p>arr[4]=’z’;//[1,3,5,undefined,’z’]</p><p>arr2 = arr.<strong>reverse</strong>();//arr2=[’z’,undefined,5,3,1];</p><p>//arr=[’z’,undefined,5,3,1]</p><p>arr3 = arr.concat(arr2);</p><p>alert(arr3);</p><p>弹出提示对话框：z,,5,3,1,z,,5,3,1</p><p><strong>reverse 方法颠倒数组中元素的位置，并返回该数组的引用。</strong></p><h2 id="59、补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口；-lt-html-gt"><a href="#59、补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口；-lt-html-gt" class="headerlink" title="59、补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口； &lt;html&gt;"></a>59、补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口； &lt;html&gt;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script type=”text/javascript” &gt;</span><br><span class="line">function closeWin()&#123;</span><br><span class="line">//在此处添加代码</span><br><span class="line">if(confirm(“确定要退出吗？”))&#123;</span><br><span class="line">window.close(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=”button”value=”关闭窗口”onclick=”closeWin()”/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="60、写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"><a href="#60、写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉" class="headerlink" title="60、写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"></a>60、写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = “&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;</span><br><span class="line">&lt;script type=”text/javascript”&gt;</span><br><span class="line">var reg = /&lt;\/?\w+\/?&gt;/gi;//</span><br><span class="line">var str = “&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;</span><br><span class="line">alert(str.replace(reg,”&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="61、完成foo-函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。"><a href="#61、完成foo-函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。" class="headerlink" title="61、完成foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。"></a>61、完成foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=”text/javascript” &gt;</span><br><span class="line">function foo() &#123;</span><br><span class="line">//在此处添加代码</span><br><span class="line">var rdo = document.getElementsByTagName(&apos;input&apos;);</span><br><span class="line">for(var i =0 ;i&lt;rdo.length-1;i++)&#123;</span><br><span class="line">if(rdo.checked)&#123;</span><br><span class="line">alert(“您选择的是第”+(i+1)+”个单选框”);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form name=”form1″ &gt;</span><br><span class="line">&lt;input type=”radio” name=”radioGroup” /&gt;</span><br><span class="line">&lt;input type=”radio” name=”radioGroup”/&gt;</span><br><span class="line">&lt;input type=”radio” name=”radioGroup”/&gt;</span><br><span class="line">&lt;input type=”radio” name=”radioGroup”/&gt;</span><br><span class="line">&lt;input type=”submit”/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="62、完成函数showImg-，要求能够动态根据下拉列表的选项变化，更新图片的显示"><a href="#62、完成函数showImg-，要求能够动态根据下拉列表的选项变化，更新图片的显示" class="headerlink" title="62、完成函数showImg()，要求能够动态根据下拉列表的选项变化，更新图片的显示"></a>62、完成函数showImg()，要求能够动态根据下拉列表的选项变化，更新图片的显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=”text/javascript” &gt;</span><br><span class="line">function showImg (oSel) &#123;</span><br><span class="line">//在此处添加代码 </span><br><span class="line">var str = oSel.value;</span><br><span class="line">document.getElementById(“pic”).src= str+”.jpg”;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;img id=”pic”src=”img1.jpg”width=”200″ height=”200″ /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;select id=”sel”&gt;</span><br><span class="line">&lt;option value=”img1“&gt;城市生活&lt;/option&gt;</span><br><span class="line">&lt;option value=”img2“&gt;都市早报&lt;/option&gt;</span><br><span class="line">&lt;option value=”img3“&gt;青山绿水&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="63、截取字符串abcdefg的efg"><a href="#63、截取字符串abcdefg的efg" class="headerlink" title="63、截取字符串abcdefg的efg"></a>63、截取字符串abcdefg的efg</h2><p>alert(‘abcdefg’.<strong>substring</strong>(4));</p><h2 id="64、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个"><a href="#64、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个" class="headerlink" title="64、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个"></a>64、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个</h2><p>对象：Window document location screen history navigator</p><p>方法：alert() confirm() prompt() open() close()</p><h2 id="65、简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明"><a href="#65、简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明" class="headerlink" title="65、简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明"></a>65、简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明</h2><p>Document.getElementById 根据元素id查找元素</p><p>Document.getElementByName 根据元素name查找元素</p><p>Document.getElementTagName 根据指定的元素名查找元素</p><h2 id="66、希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#66、希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="66、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>66、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var domList = document.getElementsByTagName(‘input’)</span><br><span class="line">var checkBoxList = [];</span><br><span class="line">var len = domList.length;　　//缓存到局部变量</span><br><span class="line">while (len--) &#123;　　//使用while的效率会比for循环更高</span><br><span class="line">　　if (domList[len].type == ‘checkbox’) &#123;</span><br><span class="line">    　　checkBoxList.push(domList[len]);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="67、JavaScript的数据类型都有什么？"><a href="#67、JavaScript的数据类型都有什么？" class="headerlink" title="67、JavaScript的数据类型都有什么？"></a>67、JavaScript的数据类型都有什么？</h2><p>基本数据类型：String,Boolean,Number,Undefined,Null</p><p>引用数据类型：Object(Array,Date,RegExp,Function)</p><h2 id="68、javascript中有哪几种数据类型，分别写出中文和英文。"><a href="#68、javascript中有哪几种数据类型，分别写出中文和英文。" class="headerlink" title="68、javascript中有哪几种数据类型，分别写出中文和英文。"></a>68、javascript中有哪几种数据类型，分别写出中文和英文。</h2><p>string boolean number null undefined object</p><p>字符串 布尔 数值 空值 未定义 对象</p><h2 id="69、javascript中-和-的区别是什么？举例说明。"><a href="#69、javascript中-和-的区别是什么？举例说明。" class="headerlink" title="69、javascript中==和===的区别是什么？举例说明。"></a>69、javascript中==和===的区别是什么？举例说明。</h2><p>==会自动进行类型转换， ===不会</p><h2 id="70、简述创建函数的几种方式"><a href="#70、简述创建函数的几种方式" class="headerlink" title="70、简述创建函数的几种方式"></a>70、简述创建函数的几种方式</h2><p>第一种（函数声明）：</p><p>function sum1(num1,num2){</p><p>return num1+num2;</p><p>}</p><p>第二种（函数表达式）：</p><p>var sum2 = function(num1,num2){</p><p>return num1+num2;</p><p>}</p><p>匿名函数：</p><p>function(){}:只能自己执行自己</p><p>第三种（函数对象方式）：</p><p>var sum3 = new Function(“num1”,”num2”,”return num1+num2”);</p><h2 id="71、Javascript如何实现继承？"><a href="#71、Javascript如何实现继承？" class="headerlink" title="71、Javascript如何实现继承？"></a>71、Javascript如何实现继承？</h2><p>原型链继承，借用构造函数继承，组合继承，寄生式继承，寄生组合继承</p><h2 id="72、Javascript创建对象的几种方式？"><a href="#72、Javascript创建对象的几种方式？" class="headerlink" title="72、Javascript创建对象的几种方式？"></a>72、Javascript创建对象的几种方式？</h2><p>工厂方式，构造函数方式，原型模式，混合构造函数原型模式，动态原型方式</p><h2 id="73、把-Script-标签-放在页面的最底部的body封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#73、把-Script-标签-放在页面的最底部的body封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="73、把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？"></a>73、把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</h2><p>如果说放在body的封闭之前，将会阻塞其他资源的加载</p><p>如果放在body封闭之后，不会影响body内元素的加载</p><h2 id="74、iframe的优缺点？"><a href="#74、iframe的优缺点？" class="headerlink" title="74、iframe的优缺点？"></a>74、iframe的优缺点？</h2><p>优点：</p><ol><li><p>解决加载缓慢的第三方内容如图标和广告等的加载问题</p></li><li><p>Security sandbox</p></li><li><p>并行加载脚本</p></li></ol><p>缺点：</p><ol><li><p>iframe会阻塞主页面的Onload事件</p></li><li><p>即时内容为空，加载也需要时间</p></li><li><p>没有语意</p></li></ol><h2 id="75、请你谈谈Cookie的弊端？"><a href="#75、请你谈谈Cookie的弊端？" class="headerlink" title="75、请你谈谈Cookie的弊端？"></a>75、请你谈谈Cookie的弊端？</h2><p>缺点：</p><p>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p><p>Firefox每个域名cookie限制为50个。</p><p>Opera每个域名cookie限制为30个。</p><p>Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过<a href="http://product.it168.com/files/0402search.shtml" target="_blank" rel="noopener">服务器</a>的处理的限制，会导致错误发生。</p><p>注：“每个域名cookie限制为20个”将不再正确！</p><p>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p><p>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><h2 id="76、DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#76、DOM操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="76、DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>76、DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h2><ol><li>创建新节点</li></ol><p>createDocumentFragment() // 创建一个DOM片段</p><p>createElement() // 创建一个具体的元素</p><p>createTextNode() // 创建一个文本节点</p><ol start="2"><li>添加、移除、替换、插入</li></ol><p>appendChild()</p><p>removeChild()</p><p>replaceChild()</p><p>insertBefore() // 在已有的子节点前插入一个新的子节点</p><ol start="3"><li>查找</li></ol><p>getElementsByTagName() // 通过标签名称</p><p>getElementsByName() //<br>通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</p><p>getElementById() // 通过元素Id，唯一性</p><h2 id="77、js延迟加载的方式有哪些？"><a href="#77、js延迟加载的方式有哪些？" class="headerlink" title="77、js延迟加载的方式有哪些？"></a>77、js延迟加载的方式有哪些？</h2><ol><li><p>defer和async</p></li><li><p>动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）</p></li><li><p>按需异步载入js</p></li></ol><h2 id="78、documen-write和-innerHTML-的区别？"><a href="#78、documen-write和-innerHTML-的区别？" class="headerlink" title="78、documen.write和 innerHTML 的区别？"></a>78、documen.write和 innerHTML 的区别？</h2><p>document.write 只能重绘整个页面</p><p>innerHTML 可以重绘页面的一部分</p><h2 id="79、哪些操作会造成内存泄漏？"><a href="#79、哪些操作会造成内存泄漏？" class="headerlink" title="79、哪些操作会造成内存泄漏？"></a>79、哪些操作会造成内存泄漏？</h2><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为<br>0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><ol><li><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p></li><li><p>闭包</p></li><li><p>控制台日志</p></li><li><p>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p></li></ol><h2 id="80、javascript的typeof返回哪些数据类型"><a href="#80、javascript的typeof返回哪些数据类型" class="headerlink" title="80、javascript的typeof返回哪些数据类型?"></a>80、javascript的typeof返回哪些数据类型?</h2><p>答：object、 number、 function 、boolean、 underfind</p><h2 id="81、split-join-的区别"><a href="#81、split-join-的区别" class="headerlink" title="81、split() join() 的区别"></a>81、split() join() 的区别</h2><p>答：前者是切割成数组的形式，后者是将数组转换成字符串</p><h2 id="82、数组方法pop-push-unshift-shift-各表示什么意思？"><a href="#82、数组方法pop-push-unshift-shift-各表示什么意思？" class="headerlink" title="82、数组方法pop() push() unshift() shift()各表示什么意思？"></a>82、数组方法pop() push() unshift() shift()各表示什么意思？</h2><p>答：Push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除</p><h2 id="83、判断一个字符串中出现次数最多的字符，统计这个次数"><a href="#83、判断一个字符串中出现次数最多的字符，统计这个次数" class="headerlink" title="83、判断一个字符串中出现次数最多的字符，统计这个次数"></a>83、判断一个字符串中出现次数最多的字符，统计这个次数</h2><p>答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'asdfssaaasasasasaa'</span>;  </span><br><span class="line"><span class="keyword">var</span> json = &#123;&#125;;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i \&lt; str.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!json[str.charAt(i)])&#123;  </span><br><span class="line">                json[str.charAt(i)] = <span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                json[str.charAt(i)]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> iMax = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">var</span> iIndex = <span class="string">''</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> json)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(json[i]\&gt;iMax)&#123;  </span><br><span class="line">                iMax = json[i];  </span><br><span class="line">                iIndex = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">alert(<span class="string">'出现次数最多的是:'</span>+iIndex+<span class="string">'出现'</span>+iMax+<span class="string">'次'</span>);</span><br></pre></td></tr></table></figure><h2 id="84、javascript的typeof返回哪些数据类型"><a href="#84、javascript的typeof返回哪些数据类型" class="headerlink" title="84、javascript的typeof返回哪些数据类型"></a>84、javascript的typeof返回哪些数据类型</h2><p>Object number function boolean underfind</p><h2 id="85、例举3种强制类型转换和2种隐式类型转换"><a href="#85、例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="85、例举3种强制类型转换和2种隐式类型转换?"></a>85、例举3种强制类型转换和2种隐式类型转换?</h2><p>强制（parseInt,parseFloat,number）</p><p>隐式（== – ===）</p><h2 id="86、split-join-的区别"><a href="#86、split-join-的区别" class="headerlink" title="86、split() join() 的区别"></a>86、split() join() 的区别</h2><p>前者是切割成数组的形式，后者是将数组转换成字符串</p><h2 id="87、数组方法pop-push-unshift-shift"><a href="#87、数组方法pop-push-unshift-shift" class="headerlink" title="87、数组方法pop() push() unshift() shift()"></a>87、数组方法pop() push() unshift() shift()</h2><p>Push()尾部添加 shift() 尾部删除</p><p>Unshift() 头部添加 shift() 头部删除</p><h2 id="88、这道题被吃了………"><a href="#88、这道题被吃了………" class="headerlink" title="88、这道题被吃了………"></a>88、这道题被吃了………</h2><h2 id="89、IE和DOM事件流的区别"><a href="#89、IE和DOM事件流的区别" class="headerlink" title="89、IE和DOM事件流的区别"></a>89、IE和DOM事件流的区别</h2><p>1.执行顺序不一样、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt; </span><br><span class="line">&lt;div&gt; </span><br><span class="line">&lt;button&gt;点击这里&lt;/button&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line"></span><br><span class="line">冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) </span><br><span class="line">捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流)</span><br><span class="line">DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)</span><br></pre></td></tr></table></figure><p>2.参数不一样<br>3.事件加不加on<br>4.this指向问题</p><h2 id="90、IE和标准下有哪些兼容性的写法"><a href="#90、IE和标准下有哪些兼容性的写法" class="headerlink" title="90、IE和标准下有哪些兼容性的写法"></a>90、IE和标准下有哪些兼容性的写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ev = ev || window.event</span><br><span class="line">document.documentElement.clientWidth || document.body.clientWidth</span><br><span class="line">var target = ev.srcElement||ev.target</span><br></pre></td></tr></table></figure><h2 id="91、call和apply的区别"><a href="#91、call和apply的区别" class="headerlink" title="91、call和apply的区别"></a>91、call和apply的区别</h2><p>Object.call(this,obj1,obj2,obj3)</p><p>Object.apply(this,arguments)</p><h2 id="92、这道题被吃了………"><a href="#92、这道题被吃了………" class="headerlink" title="92、这道题被吃了………"></a>92、这道题被吃了………</h2><h2 id="93、写一个获取非行间样式的函数"><a href="#93、写一个获取非行间样式的函数" class="headerlink" title="93、写一个获取非行间样式的函数"></a>93、写一个获取非行间样式的函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(obj,attr,value)</span><br><span class="line">&#123;</span><br><span class="line">if(!value)</span><br><span class="line">&#123;</span><br><span class="line">if(obj.currentStyle)//ie</span><br><span class="line">&#123;</span><br><span class="line">return obj.currentStyle(attr);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;//标准浏览器</span><br><span class="line">obj.getComputedStyle(attr,false);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">obj.style[attr] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="94、这道题被吃了………"><a href="#94、这道题被吃了………" class="headerlink" title="94、这道题被吃了………"></a>94、这道题被吃了………</h2><h2 id="95、闭包是什么，有什么特性，对页面有什么影响"><a href="#95、闭包是什么，有什么特性，对页面有什么影响" class="headerlink" title="95、闭包是什么，有什么特性，对页面有什么影响"></a>95、闭包是什么，有什么特性，对页面有什么影响</h2><p>闭包就是能够读取其他函数内部变量的函数。<br><a href="http://blog.csdn.net/gaoshanwudi/article/details/7355794" target="_blank" rel="noopener">http://blog.csdn.net/gaoshanwudi/article/details/7355794</a><br>此链接可查看（问这个问题的不是一个公司）</p><h2 id="96、解释jsonp的原理，以及为什么不是真正的ajax"><a href="#96、解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="96、解释jsonp的原理，以及为什么不是真正的ajax"></a>96、解释jsonp的原理，以及为什么不是真正的ajax</h2><p>动态创建script标签，回调函数</p><p>Ajax是页面无刷新请求数据操作</p><h2 id="97、javascript的本地对象，内置对象和宿主对象"><a href="#97、javascript的本地对象，内置对象和宿主对象" class="headerlink" title="97、javascript的本地对象，内置对象和宿主对象"></a>97、javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为array obj regexp等可以new实例化</p><p>内置对象为gload Math 等不可以实例化的</p><p>宿主为浏览器自带的document,window 等</p><h2 id="98、document-load-和document-ready的区别"><a href="#98、document-load-和document-ready的区别" class="headerlink" title="98、document load 和document ready的区别"></a>98、document load 和document ready的区别</h2><p>Document.onload 是在结构和样式加载完才执行js</p><p>Document.ready原生种没有这个方法，jquery中有 $().ready(function)</p><h2 id="99、字符串反转，如将-‘12345678’-变成-‘87654321’"><a href="#99、字符串反转，如将-‘12345678’-变成-‘87654321’" class="headerlink" title="99、字符串反转，如将 ‘12345678’ 变成 ‘87654321’"></a>99、字符串反转，如将 ‘12345678’ 变成 ‘87654321’</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串</span><br><span class="line">var str = &apos;12345678&apos;;</span><br><span class="line">str = str.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br></pre></td></tr></table></figure><h2 id="100、将数字-12345678-转化成-RMB形式-如：-12-345-678"><a href="#100、将数字-12345678-转化成-RMB形式-如：-12-345-678" class="headerlink" title="100、将数字 12345678 转化成 RMB形式 如： 12,345,678 "></a>100、将数字 12345678 转化成 RMB形式 如： 12,345,678 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//个人方法；</span><br><span class="line">//思路：先将数字转为字符， str= str + &apos;&apos; ;</span><br><span class="line">//利用反转函数，每三位字符加一个 &apos;,&apos;最后一位不加； re()是自定义的反转函数，最后再反转回去！</span><br><span class="line">for(var i = 1; i &lt;= re(str).length; i++)&#123;</span><br><span class="line">    tmp += re(str)[i - 1];</span><br><span class="line">    if(i % 3 == 0 &amp;&amp; i != re(str).length)&#123;</span><br><span class="line">        tmp += &apos;,&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101、生成5个不同的随机数；"><a href="#101、生成5个不同的随机数；" class="headerlink" title="101、生成5个不同的随机数；"></a>101、生成5个不同的随机数；</h2><p>//思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var num1 = [];</span><br><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">    num1[i] = Math.floor(Math.random()*10) + 1; //范围是 [1, 10]</span><br><span class="line">    for(var j = 0; j &lt; i; j++)&#123;</span><br><span class="line">        if(num1[i] == num1[j])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="102、去掉数组中重复的数字"><a href="#102、去掉数组中重复的数字" class="headerlink" title="102、去掉数组中重复的数字 "></a>102、去掉数组中重复的数字 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">//思路：每遍历一次就和之前的所有做比较，不相等则放入新的数组中！</span><br><span class="line">//这里用的原型 个人做法；</span><br><span class="line">Array.prototype.unique = function()&#123;</span><br><span class="line">    var len = this.length,</span><br><span class="line">        newArr = [],</span><br><span class="line">        flag = 1;</span><br><span class="line">    for(var i = 0; i &lt; len; i++, flag = 1)&#123;</span><br><span class="line">        for(var j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            if(this[i] == this[j])&#123;</span><br><span class="line">                flag = 0;        //找到相同的数字后，不执行添加数据</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag ? newArr.push(this[i]) : &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">方法二：</span><br><span class="line">(function(arr)&#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        newArr = [], </span><br><span class="line">        flag;</span><br><span class="line">    for(var i = 0; i &lt; len; i+=1, flag = 1)&#123;</span><br><span class="line">        for(var j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            if(arr[i] == arr[j])&#123;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        flag?newArr.push(arr[i]):&apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(newArr);</span><br><span class="line">&#125;)([1, 1, 22, 3, 4, 55, 66]);</span><br></pre></td></tr></table></figure><h2 id="103、阶乘函数；9-8-7-6-5…-1"><a href="#103、阶乘函数；9-8-7-6-5…-1" class="headerlink" title="103、阶乘函数；9*8*7*6*5…*1"></a>103、阶乘函数；9*8*7*6*5…*1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//原型方法</span><br><span class="line">Number.prototype.N = function()&#123;</span><br><span class="line">    var re = 1;</span><br><span class="line">    for(var i = 1; i &lt;= this; i++)&#123;</span><br><span class="line">        re *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br><span class="line">var num = 5;</span><br><span class="line">alert(num.N());</span><br></pre></td></tr></table></figure><h2 id="104、window-location-search返回的是什么？"><a href="#104、window-location-search返回的是什么？" class="headerlink" title="104、window.location.search返回的是什么？"></a>104、window.location.search返回的是什么？</h2><p>答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值</p><p>返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！</p><h2 id="105、window-location-hash-返回的是什么？"><a href="#105、window-location-hash-返回的是什么？" class="headerlink" title="105、window.location.hash 返回的是什么？"></a>105、window.location.hash 返回的是什么？</h2><p>答：锚点；</p><p>//url:<a href="http://www.sina.com/getage?\#age" target="_blank" rel="noopener">http://www.sina.com/getage?\#age</a></p><p>这时就返回”#age”</p><h2 id="106、window-location-reload-作用？"><a href="#106、window-location-reload-作用？" class="headerlink" title="106、window.location.reload() 作用？"></a>106、window.location.reload() 作用？</h2><p>答：刷新当前页面。</p><h2 id="107、阻止冒泡函数"><a href="#107、阻止冒泡函数" class="headerlink" title="107、阻止冒泡函数"></a>107、阻止冒泡函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function stopPropagation(e) &#123;  </span><br><span class="line">    e = e || window.event;  </span><br><span class="line">    if(e.stopPropagation) &#123; //W3C阻止冒泡方法  </span><br><span class="line">        e.stopPropagation();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        e.cancelBubble = true; //IE阻止冒泡方法  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">document.getElementById(&apos;need_hide&apos;).onclick = function(e) &#123;  </span><br><span class="line">    stopPropagation(e);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="108、什么是闭包？-写一个简单的闭包？；"><a href="#108、什么是闭包？-写一个简单的闭包？；" class="headerlink" title="108、什么是闭包？ 写一个简单的闭包？；"></a>108、什么是闭包？ 写一个简单的闭包？；</h2><p>答：我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    function inner()&#123;</span><br><span class="line">        var n = 2;</span><br><span class="line">        alert(n + num);</span><br><span class="line">    &#125;</span><br><span class="line">    return inner;</span><br><span class="line">&#125;</span><br><span class="line">outer()();</span><br></pre></td></tr></table></figure><h2 id="109、javascript-中的垃圾回收机制？"><a href="#109、javascript-中的垃圾回收机制？" class="headerlink" title="109、javascript 中的垃圾回收机制？"></a>109、javascript 中的垃圾回收机制？</h2><pre><code>答：在Javascript中，如果一个对象不再被引用，那么这个对象就会被**GC**回收。如果两个对象互相引用，而不再</code></pre><p> 被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么<br> 函数a执行后不会被回收的原因。</p><h2 id="110、看题做答："><a href="#110、看题做答：" class="headerlink" title="110、看题做答："></a>110、看题做答：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    var tmp = 1;</span><br><span class="line">    this.x = 3;</span><br><span class="line">    console.log(tmp);    //A</span><br><span class="line">    console.log(this.x)；     //B</span><br><span class="line">&#125;</span><br><span class="line">var obj = new f1(); //1</span><br><span class="line">console.log(obj.x)     //2</span><br><span class="line">console.log(f1());        //3</span><br></pre></td></tr></table></figure><h2 id="111、下面输出多少？"><a href="#111、下面输出多少？" class="headerlink" title="111、下面输出多少？"></a>111、下面输出多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o1 = new Object();</span><br><span class="line">var o2 = o1;</span><br><span class="line">o2.name = &quot;CSSer&quot;;</span><br><span class="line">console.log(o1.name);</span><br></pre></td></tr></table></figure><p>如果不看答案，你回答真确了的话，那么说明你对javascript的数据类型了解的还是比较清楚了。js中有两种数据类型，分别是：基本数据类型和引用数据类型（object Array）。对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值。对于保存引用类型值的变量，变量是按引用访问的，<em>我们操作的是变量值所引用（指向）的对象。答案就清楚了：//CSSer;</em></p><h2 id="112、再来一个"><a href="#112、再来一个" class="headerlink" title="112、再来一个"></a>112、再来一个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function changeObjectProperty (o) &#123;</span><br><span class="line">    o.siteUrl = &quot;http://www.csser.com/&quot;;</span><br><span class="line">    o = new Object();</span><br><span class="line">    o.siteUrl = &quot;http://www.popcg.com/&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var CSSer = new Object();</span><br><span class="line">changeObjectProperty(CSSer);</span><br><span class="line">console.log(CSSer.siteUrl); //</span><br></pre></td></tr></table></figure><pre><code>如果CSSer参数是按引用传递的，那么结果应该是&quot;http://www.popcg.com/&quot;，但实际结果却仍是&quot;http://www.csser.com/&quot;。事实是这样的：在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存。    （补充：内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能。）</code></pre><h2 id="113、输出多少？"><a href="#113、输出多少？" class="headerlink" title="113、输出多少？"></a>113、输出多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 6;</span><br><span class="line">setTimeout(function () &#123;    </span><br><span class="line">    var a = 666;//由于变量a是一个局部变量</span><br><span class="line">    alert(a);      // 输出666，</span><br><span class="line">&#125;, 1000);</span><br><span class="line">a = 66;</span><br></pre></td></tr></table></figure><p>因为var a = 666;定义了局部变量a，并且赋值为666，根据变量作用域链，<br>全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 6;</span><br><span class="line">setTimeout(function () &#123;    </span><br><span class="line">                             //变量声明提前</span><br><span class="line">    alert(a);      // 输出undefined </span><br><span class="line">    var a = 666;</span><br><span class="line">&#125;, 1000);</span><br><span class="line">a = 66;</span><br></pre></td></tr></table></figure><p>因为var a = 666;定义了局部变量a，同样覆盖了全局变量，但是在alert(a);之前<br>a并未赋值，所以输出undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var *a* = 6;            </span><br><span class="line">setTimeout(function()&#123;  </span><br><span class="line">alert(a);               </span><br><span class="line">var a = 66;             </span><br><span class="line">&#125;, 1000);               </span><br><span class="line">*a* = 666;              </span><br><span class="line">alert(*a*);             </span><br><span class="line">//结果：666 undefined</span><br></pre></td></tr></table></figure><p>记住： 异步处理，一切OK 声明提前</p><h2 id="114、输出多少？"><a href="#114、输出多少？" class="headerlink" title="114、输出多少？"></a>114、输出多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setN(obj)&#123;</span><br><span class="line">    obj.name=&apos;屌丝&apos;;</span><br><span class="line">    obj = new Object(); </span><br><span class="line">    obj.name = &apos;腐女&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var per = new Object();</span><br><span class="line">setN(per);</span><br><span class="line">alert(per.name);  //屌丝 内部</span><br></pre></td></tr></table></figure><h2 id="115、JS的继承性"><a href="#115、JS的继承性" class="headerlink" title="115、JS的继承性"></a>115、JS的继承性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123;color: &apos;blue&apos;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">考点：1、this的指向</span><br><span class="line">      2、call的用法</span><br><span class="line">sayColor(); //red</span><br><span class="line">sayColor.call(this); //red this指向的是window对象</span><br><span class="line">sayColor.call(window); //red</span><br><span class="line">sayColor.call(o); //blue</span><br></pre></td></tr></table></figure><h2 id="116、精度问题-JS-精度不能精确到-0-1-同时存在于值和差值中"><a href="#116、精度问题-JS-精度不能精确到-0-1-同时存在于值和差值中" class="headerlink" title="116、精度问题: JS 精度不能精确到 0.1 同时存在于值和差值中"></a>116、精度问题: JS 精度不能精确到 0.1 同时存在于值和差值中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var n = 0.3,m = 0.2, i = 0.2, j = 0.1;</span><br><span class="line">alert((n - m) == (i - j)); //false</span><br><span class="line">alert((n-m) == 0.1); //false</span><br><span class="line">alert((i-j)==0.1); //true</span><br></pre></td></tr></table></figure><h2 id="117、加减运算"><a href="#117、加减运算" class="headerlink" title="117、加减运算"></a>117、加减运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;5&apos;+3); //53 string</span><br><span class="line">alert(&apos;5&apos;+&apos;3&apos;); //53 string</span><br><span class="line">alert(&apos;5&apos;-3); //2 number</span><br><span class="line">alert(&apos;5&apos;-&apos;3&apos;); //2 number</span><br></pre></td></tr></table></figure><h2 id="118、什么是同源策略？"><a href="#118、什么是同源策略？" class="headerlink" title="118、什么是同源策略？"></a>118、什么是同源策略？</h2><pre><code>指： 同协议、端口、域名的安全策略，由网景(Netscape)公司提出来的安全协议！</code></pre><h2 id="119、call和apply的区别是什么？"><a href="#119、call和apply的区别是什么？" class="headerlink" title="119、call和apply的区别是什么？"></a>119、call和apply的区别是什么？</h2><pre><code>参数形式不同，call(obj, pra, pra)后面是单个参数。apply(obj,</code></pre><p>[args])后面是数组。</p><h2 id="120、为什么不能定义1px左右的div容器？"><a href="#120、为什么不能定义1px左右的div容器？" class="headerlink" title="120、为什么不能定义1px左右的div容器？   "></a>120、为什么不能定义1px左右的div容器？   </h2><p>IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：</p><p>overflow:hidden | zoom:0.08 | line-height:1px</p><h2 id="121、结果是什么？"><a href="#121、结果是什么？" class="headerlink" title="121、结果是什么？"></a>121、结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    foo.a = function()&#123;alert(1)&#125;; </span><br><span class="line">    this.a = function()&#123;alert(2)&#125;;</span><br><span class="line">    a = function()&#123;alert(3)&#125;;</span><br><span class="line">    var a = function()&#123;alert(4)&#125;;</span><br><span class="line">&#125;; </span><br><span class="line">foo.prototype.a = function()&#123;alert(5)&#125;;</span><br><span class="line">foo.a = function()&#123;alert(6)&#125;;</span><br><span class="line">foo.a(); //6</span><br><span class="line">var obj = new foo();</span><br><span class="line">obj.a(); //2</span><br><span class="line">foo.a(); //1</span><br></pre></td></tr></table></figure><h2 id="122、输出结果"><a href="#122、输出结果" class="headerlink" title="122、输出结果"></a>122、输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 5; </span><br><span class="line">function test()&#123;</span><br><span class="line">    a = 0; </span><br><span class="line">    alert(a); </span><br><span class="line">    alert(this.a); //没有定义 a这个属性</span><br><span class="line">    var a; </span><br><span class="line">    alert(a)</span><br><span class="line">&#125;</span><br><span class="line">test(); // 0, 5, 0</span><br><span class="line">new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined</span><br></pre></td></tr></table></figure><h2 id="123、计算字符串字节数："><a href="#123、计算字符串字节数：" class="headerlink" title="123、计算字符串字节数："></a>123、计算字符串字节数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new function(s)&#123; </span><br><span class="line">     if(!arguments.length||!s) return null;  </span><br><span class="line">     if(&quot;&quot;==s) return 0;     //无效代码，因为上一句!s已经判断过</span><br><span class="line">     var l=0;</span><br><span class="line">     for(var i=0;i&lt;s.length;i++)&#123;        </span><br><span class="line">         if(s.charCodeAt(i)&gt;255) l+=2; else l+=1;  //charCodeAt()得到的是unCode码   </span><br><span class="line">     &#125;     //汉字的unCode码大于 255bit 就是两个字节</span><br><span class="line">     alert(l); </span><br><span class="line">&#125;(&quot;hello world!&quot;);</span><br></pre></td></tr></table></figure><h2 id="124、结果是："><a href="#124、结果是：" class="headerlink" title="124、结果是："></a>124、结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bool = !!2; alert(bool)；//true;</span><br></pre></td></tr></table></figure><p>技巧：双向非操作可以把字符串和数字转换为布尔值。</p><h2 id="125、声明对象，添加属性，输出属性"><a href="#125、声明对象，添加属性，输出属性" class="headerlink" title="125、声明对象，添加属性，输出属性"></a>125、声明对象，添加属性，输出属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">        name: &apos;leipeng&apos;,</span><br><span class="line">        showName: function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">obj.showName();</span><br></pre></td></tr></table></figure><h2 id="126、匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或者下划线构成，长度5-20"><a href="#126、匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或者下划线构成，长度5-20" class="headerlink" title="126、匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或者下划线构成，长度5-20"></a>126、匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或者下划线构成，长度5-20</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[a-zA-Z_][a-zA-Z0-9_]&#123;4,19&#125;/,</span><br><span class="line">            name1 = &apos;leipeng&apos;,</span><br><span class="line">            name2 = &apos;0leipeng&apos;,</span><br><span class="line">            name3 = &apos;你好leipeng&apos;,</span><br><span class="line">            name4 = &apos;hi&apos;;</span><br><span class="line">     </span><br><span class="line">        alert(reg.test(name1));</span><br><span class="line">        alert(reg.test(name2));</span><br><span class="line">        alert(reg.test(name3));</span><br><span class="line">        alert(reg.test(name4));</span><br></pre></td></tr></table></figure><h2 id="127、检测变量类型"><a href="#127、检测变量类型" class="headerlink" title="127、检测变量类型"></a>127、检测变量类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function checkStr(str)&#123;</span><br><span class="line">       typeof str == &apos;string&apos;? alert(&apos;true&apos;):alert(&apos;false&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">   checkStr(&apos;leipeng&apos;);</span><br></pre></td></tr></table></figure><h2 id="128、如何在HTML中添加事件，几种方法？"><a href="#128、如何在HTML中添加事件，几种方法？" class="headerlink" title="128、如何在HTML中添加事件，几种方法？"></a>128、如何在HTML中添加事件，几种方法？</h2><p>1、标签之中直接添加 onclick=”fun()”;</p><p>2、JS添加 Eobj.onclick = method;</p><p>3、现代事件 IE9以前： obj.attachEvent(‘onclick’, method)；</p><p>标准浏览器: obj.addEventListener(‘click’, method, false);</p><h2 id="129、BOM对象有哪些，列举window对象？"><a href="#129、BOM对象有哪些，列举window对象？" class="headerlink" title="129、BOM对象有哪些，列举window对象？"></a>129、BOM对象有哪些，列举window对象？</h2><p>1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；</p><p>2、document对象，文档对象；</p><p>3、location对象，浏览器当前URL信息；</p><p>4、navigator对象，浏览器本身信息；</p><p>5、screen对象，客户端屏幕信息；</p><p>6、history对象，浏览器访问历史信息；</p><h2 id="130、请用代码实现-outerHTML"><a href="#130、请用代码实现-outerHTML" class="headerlink" title="130、请用代码实现 outerHTML"></a>130、请用代码实现 outerHTML</h2><p>//说明：outerHTML其实就是innerHTML再加上本身；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.outerHTML = function () &#123;</span><br><span class="line">var innerCon = this.innerHTML, //获得里面的内容</span><br><span class="line">outerCon = this.appendChild(innerCon); //添加到里面</span><br><span class="line">alert(outerCon);</span><br><span class="line">&#125;</span><br><span class="line">演示代码：</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">hello</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Object.prototype.outerHTML = function () &#123;</span><br><span class="line">var innerCon = this.innerHTML, //获得里面的内容</span><br><span class="line">outerCon = this.appendChild(innerCon); //添加到里面</span><br><span class="line">alert(outerCon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function $(id) &#123;</span><br><span class="line">return document.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">alert($(&apos;outer&apos;).innerHTML);</span><br><span class="line">alert($(&apos;outer&apos;).outerHTML);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="131、JS中的简单继承-call方法！"><a href="#131、JS中的简单继承-call方法！" class="headerlink" title="131、JS中的简单继承 call方法！"></a>131、JS中的简单继承 call方法！</h2><p>//顶一个父母类，注意：类名都是首字母大写的哦！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, money)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.money = money;</span><br><span class="line">            this.info = function()&#123;</span><br><span class="line">                alert(&apos;姓名： &apos;+this.name+&apos; 钱： &apos;+ this.money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义孩子类</span><br><span class="line">        function Children(name)&#123;</span><br><span class="line">            Parent.call(this, name); //继承 姓名属性，不要钱。  </span><br><span class="line">            this.info = function()&#123;</span><br><span class="line">                alert(&apos;姓名： &apos;+this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //实例化类</span><br><span class="line">        var per = new Parent(&apos;parent&apos;, 800000000000);</span><br><span class="line">        var chi = new Children(&apos;child&apos;);</span><br><span class="line">        per.info();</span><br><span class="line">        chi.info();</span><br></pre></td></tr></table></figure><h2 id="132、bind-live-delegate-的区别"><a href="#132、bind-live-delegate-的区别" class="headerlink" title="132、bind(), live(), delegate()的区别"></a>132、bind(), live(), delegate()的区别</h2><p>bind：<br>绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。</p><p>live：<br>方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。</p><p>delegate：<br>方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。</p><p>最佳实现：on() off()</p><h2 id="133、typeof-的返回类型有哪些？"><a href="#133、typeof-的返回类型有哪些？" class="headerlink" title="133、typeof 的返回类型有哪些？"></a>133、typeof 的返回类型有哪些？</h2><pre><code>alert(typeof &apos;leipeng&apos;); //stringvar i = true; alert(typeof i); //booleanalert(typeof 1); //numbervar a; alert(typeof a); //undefinedfunction a(){;};alert(typeof a) //function</code></pre><h2 id="134、简述link和import的区别？"><a href="#134、简述link和import的区别？" class="headerlink" title="134、简述link和import的区别？"></a>134、简述link和import的区别？</h2><p>区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p><p>区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p><p>区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p><p>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</p><h2 id="135、window-onload-和-document-ready的区别？"><a href="#135、window-onload-和-document-ready的区别？" class="headerlink" title="135、window.onload 和 document.ready的区别？"></a>135、window.onload 和 document.ready的区别？</h2><p>load要等到图片和包含的文件都加在进来之后执行；</p><p>ready是不包含图片和非文字文件的文档结构准备好就执行；</p><h2 id="136、-解析URL成一个对象？"><a href="#136、-解析URL成一个对象？" class="headerlink" title="136、 解析URL成一个对象？"></a>136、 解析URL成一个对象？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.urlQueryString = function()&#123;</span><br><span class="line">                var url = this.split(&apos;?&apos;)[1].split(&apos;&amp;&apos;),</span><br><span class="line">                    len = url.length;</span><br><span class="line">         </span><br><span class="line">                this.url = &#123;&#125;;</span><br><span class="line">                for(var i = 0; i &lt; len; i += 1)&#123;</span><br><span class="line">                    var cell = url[i].split(&apos;=&apos;),    </span><br><span class="line">                        key = cell[0],</span><br><span class="line">                        val = cell[1];</span><br><span class="line">                    this.url[&apos;&apos;+key+&apos;&apos;] = val;</span><br><span class="line">                &#125; </span><br><span class="line">                return this.url;</span><br><span class="line">            &#125;</span><br><span class="line">            var url = &apos;?name=12&amp;age=23&apos;;</span><br><span class="line">            console.log(url.urlQueryString().age);</span><br></pre></td></tr></table></figure><h2 id="137、看下列代码输出什么？"><a href="#137、看下列代码输出什么？" class="headerlink" title="137、看下列代码输出什么？"></a>137、看下列代码输出什么？</h2><p>var foo = “11”+2-“1”;<br>console.log(foo);<br>console.log(typeof foo);<br>执行完后foo的值为111，foo的类型为Number。</p><h2 id="138、看下列代码-输出什么？"><a href="#138、看下列代码-输出什么？" class="headerlink" title="138、看下列代码,输出什么？"></a>138、看下列代码,输出什么？</h2><p>var a = new Object();<br>a.value = 1;<br>b = a;<br>b.value = 2;<br>alert(a.value);</p><p>执行完后输出结果为2</p><h2 id="139、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。"><a href="#139、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。" class="headerlink" title="139、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。"></a>139、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。</h2><p>答案：alert(stringArray.join(“ “))</p><h2 id="140、已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。"><a href="#140、已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。" class="headerlink" title="140、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。"></a>140、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</h2><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function combo(msg)&#123;</span><br><span class="line">  var arr = msg.split(&quot;-&quot;);</span><br><span class="line">  var len = arr.length;  //将arr.length存储在一个局部变量可以提高for循环效率</span><br><span class="line">  for(var i=1;i\&lt;len;i++)&#123;</span><br><span class="line">    arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);</span><br><span class="line">  &#125;</span><br><span class="line">  msg=arr.join(&quot;&quot;);</span><br><span class="line">  return msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="141、怎样添加、移除、移动、复制、创建和查找节点"><a href="#141、怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="141、怎样添加、移除、移动、复制、创建和查找节点"></a>141、怎样添加、移除、移动、复制、创建和查找节点</h2><p>1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点</p><p>2）添加、移除、替换、插入<br>appendChild() //添加<br>removeChild() //移除<br>replaceChild() //替换<br>insertBefore() //插入</p><p>3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值<br>getElementById() //通过元素Id，唯一性</p><h2 id="142、原生JS的window-onload与Jquery的-document-ready-function-有什么不同？"><a href="#142、原生JS的window-onload与Jquery的-document-ready-function-有什么不同？" class="headerlink" title="142、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？"></a>142、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？</h2><p>window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</p><p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 </p><h2 id="143、你如何优化自己的代码？"><a href="#143、你如何优化自己的代码？" class="headerlink" title="143、你如何优化自己的代码？"></a>143、你如何优化自己的代码？</h2><p>代码重用<br>避免全局变量（命名空间，封闭空间，模块化mvc..）<br>拆分函数避免函数过于臃肿：<strong>单一职责</strong>原则<br><strong>适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程</strong><br>内存管理，尤其是闭包中的变量释放</p><h2 id="144、请描述出下列代码运行的结果"><a href="#144、请描述出下列代码运行的结果" class="headerlink" title="144、请描述出下列代码运行的结果"></a>144、请描述出下列代码运行的结果</h2><p>function d(){<br>console.log(this);<br>}d();//window</p><h2 id="145、需要将变量e的值修改为“a-b-c-d”-请写出对应的代码"><a href="#145、需要将变量e的值修改为“a-b-c-d”-请写出对应的代码" class="headerlink" title="145、需要将变量e的值修改为“a+b+c+d”,请写出对应的代码"></a>145、需要将变量e的值修改为“a+b+c+d”,请写出对应的代码</h2><p>var e=”abcd”;</p><p>设计一段代码能够遍历下列整个DOM节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span&gt;&lt;a/&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&lt;a/&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="146、怎样实现两栏等高？"><a href="#146、怎样实现两栏等高？" class="headerlink" title="146、怎样实现两栏等高？"></a>146、怎样实现两栏等高？</h2><h2 id="147、使用js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“”-只需要考虑在行尾按下enter键的情况"><a href="#147、使用js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“”-只需要考虑在行尾按下enter键的情况" class="headerlink" title="147、使用js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“”,(只需要考虑在行尾按下enter键的情况)."></a>147、使用js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“”,(只需要考虑在行尾按下enter键的情况).</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textarea.onkeydown=function(e)&#123;</span><br><span class="line">e.preventDefault();//为了阻止enter键的默认换行效果</span><br><span class="line">if(e.keycode==”enter键码”)&#123;</span><br><span class="line">testarea.value+=”&#123;&#123;enter&#125;&#125;”;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="148、以下代码中end字符串什么时候输出"><a href="#148、以下代码中end字符串什么时候输出" class="headerlink" title="148、以下代码中end字符串什么时候输出"></a>148、以下代码中end字符串什么时候输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var t=true;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(123);</span><br><span class="line">t=false;</span><br><span class="line">&#125;,1000);</span><br><span class="line"></span><br><span class="line">while(t)&#123;&#125;// **此时是一个死循环，永远不可能执行setTimeout中的回调函数**</span><br><span class="line">console.log(‘end’);</span><br></pre></td></tr></table></figure><h2 id="149、specify-‘hello-world’-gt-’h-e-l-l-o-w-o-r-l-d’实现specify函数"><a href="#149、specify-‘hello-world’-gt-’h-e-l-l-o-w-o-r-l-d’实现specify函数" class="headerlink" title="149、specify(‘hello,world’)//=&gt;’h,e,l,l,o,w,o,r,l,d’实现specify函数"></a>149、specify(‘hello,world’)//=&gt;’h,e,l,l,o,w,o,r,l,d’实现specify函数</h2><h2 id="150、请将一个URL的search部分参数与值转换成一个json对象"><a href="#150、请将一个URL的search部分参数与值转换成一个json对象" class="headerlink" title="150、请将一个URL的search部分参数与值转换成一个json对象"></a>150、请将一个URL的search部分参数与值转换成一个json对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//search部分的参数格式：a=1&amp;b=2&amp;c=3</span><br><span class="line">function getJsonFromUrlSearch( * search * ) &#123;</span><br><span class="line">var item;</span><br><span class="line">var result = &#123;&#125;;</span><br><span class="line">if ( * search * .indexOf(&apos;&amp;&apos;)\ &lt; 0) &#123;</span><br><span class="line">item = * search * .split(&apos;=&apos;);</span><br><span class="line">result[item[0]] = item[1];</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">var splitArray = * search * .split(&apos;\&amp;&apos;);</span><br><span class="line">for (var i = 0; i\ &lt; splitArray.length; i++) &#123;</span><br><span class="line">var obj = splitArray[i];</span><br><span class="line">item = obj.split(&apos;=&apos;);</span><br><span class="line">result[item[0]] = item[1];</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">var * c *= getJsonFromUrlSearch(&quot;a=1\&amp;b=2&amp;c=3&quot;);</span><br></pre></td></tr></table></figure><h2 id="151、请用原生js实现jquery的get-post功能，以及跨域情况下"><a href="#151、请用原生js实现jquery的get-post功能，以及跨域情况下" class="headerlink" title="151、请用原生js实现jquery的get\post功能，以及跨域情况下 "></a>151、请用原生js实现jquery的get\post功能，以及跨域情况下 </h2><h2 id="152、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？"><a href="#152、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？" class="headerlink" title="152、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？"></a>152、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？</h2><p>//参见雅虎14web优化规则<br>//减少http请求：<br>//1、小图弄成大图，<br>//2、合理的设置缓存<br>//3、资源合并、压缩<br>//将外部的js文件置底</p><h2 id="153、简述readonly与disabled的区别"><a href="#153、简述readonly与disabled的区别" class="headerlink" title="153、简述readonly与disabled的区别"></a>153、简述readonly与disabled的区别</h2><p>readonly只针对input(text / password)和textarea有效，</p><p>而disabled对于所有的表单元素都有效，当表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去</p><h2 id="154、判断一个字符串出现次数最多的字符，统计这个次数并输出"><a href="#154、判断一个字符串出现次数最多的字符，统计这个次数并输出" class="headerlink" title="154、判断一个字符串出现次数最多的字符，统计这个次数并输出"></a>154、判断一个字符串出现次数最多的字符，统计这个次数并输出</h2><h2 id="155、编写一个方法，去掉一个数组的复重元素"><a href="#155、编写一个方法，去掉一个数组的复重元素" class="headerlink" title="155、编写一个方法，去掉一个数组的复重元素"></a>155、编写一个方法，去掉一个数组的复重元素</h2><h2 id="156、写出3个使用this的典型应用"><a href="#156、写出3个使用this的典型应用" class="headerlink" title="156、写出3个使用this的典型应用"></a>156、写出3个使用this的典型应用</h2><p>构造函数中使用this，原型中使用this，对象字面量使用this</p><h2 id="157、请尽可能详尽的解释ajax的工作原理"><a href="#157、请尽可能详尽的解释ajax的工作原理" class="headerlink" title="157、请尽可能详尽的解释ajax的工作原理"></a>157、请尽可能详尽的解释ajax的工作原理</h2><p><strong>思路：</strong>先解释异步，再解释ajax如何使用</p><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。</p><p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p><h2 id="158、为什么扩展javascript内置对象不是好的做法？"><a href="#158、为什么扩展javascript内置对象不是好的做法？" class="headerlink" title="158、为什么扩展javascript内置对象不是好的做法？"></a>158、为什么扩展javascript内置对象不是好的做法？</h2><p>因为扩展内置对象会影响整个程序中所使用到的该内置对象的原型属性</p><h2 id="159、请解释一下javascript的同源策略"><a href="#159、请解释一下javascript的同源策略" class="headerlink" title="159、请解释一下javascript的同源策略"></a>159、请解释一下javascript的同源策略</h2><p>域名、协议、端口相同</p><h2 id="160、什么是三元表达式？“三元”表示什么意思？"><a href="#160、什么是三元表达式？“三元”表示什么意思？" class="headerlink" title="160、什么是三元表达式？“三元”表示什么意思？"></a>160、什么是三元表达式？“三元”表示什么意思？</h2><p>xxx? xxxx:xxxx;</p><p>因为运算符会涉及3个表达式</p><h2 id="161、浏览器标准模式和怪异模式之间的区别是什么？"><a href="#161、浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="161、浏览器标准模式和怪异模式之间的区别是什么？"></a>161、浏览器标准模式和怪异模式之间的区别是什么？</h2><p>标准模式是指，浏览器按W3C标准解析执行代码；</p><p>怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。</p><p>浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式</p><h2 id="162、如果设计中使用了非标准的字体，你该如何去实现？"><a href="#162、如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="162、如果设计中使用了非标准的字体，你该如何去实现？"></a>162、如果设计中使用了非标准的字体，你该如何去实现？</h2><p>先通过font-face定义字体，再引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\@font-face</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">font-family: myFirstFont;</span><br><span class="line"></span><br><span class="line">src: url(&apos;Sansation_Light.ttf&apos;),</span><br><span class="line"></span><br><span class="line">url(&apos;Sansation_Light.eot&apos;); /\* IE9+ \*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="163、用css分别实现某个div元素上下居中和左右居中"><a href="#163、用css分别实现某个div元素上下居中和左右居中" class="headerlink" title="163、用css分别实现某个div元素上下居中和左右居中"></a>163、用css分别实现某个div元素上下居中和左右居中</h2><p>margin:0 auto;</p><h2 id="164、module-12-5-2-实现满足这个结果的module函数"><a href="#164、module-12-5-2-实现满足这个结果的module函数" class="headerlink" title="164、module(12,5)//2 实现满足这个结果的module函数"></a>164、module(12,5)//2 实现满足这个结果的module函数</h2><p>function module(<em>a</em>,<em>b</em>){<br>return a%b;<br>}</p><h2 id="165、HTTP协议中，GET和POST有什么区别？分别适用什么场景-？"><a href="#165、HTTP协议中，GET和POST有什么区别？分别适用什么场景-？" class="headerlink" title="165、HTTP协议中，GET和POST有什么区别？分别适用什么场景 ？"></a>165、HTTP协议中，GET和POST有什么区别？分别适用什么场景 ？</h2><p>get传送的数据长度有限制，post没有</p><p>get通过url传递，在浏览器地址栏可见，post是在报文中传递</p><p>适用场景：</p><p>post一般用于表单提交</p><p>get一般用于简单的数据查询，严格要求不是那么高的场景</p><h2 id="166、HTTP状态消息200-302-304-403-404-500分别表示什么"><a href="#166、HTTP状态消息200-302-304-403-404-500分别表示什么" class="headerlink" title="166、HTTP状态消息200 302 304 403 404 500分别表示什么"></a>166、HTTP状态消息200 302 304 403 404 500分别表示什么</h2><p>200：请求已成功，请求所希望的响应头或数据体将随此响应返回。</p><p>302：请求的资源临时从不同的<br>URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的</p><p>304：如果客户端发送了一个带条件的 GET<br>请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><p>403：服务器已经理解请求，但是拒绝执行它。</p><p>404：请求失败，请求所希望得到的资源未被在服务器上发现。</p><p>500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p><h2 id="167、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified-cache-control-Expires分别代表什么）"><a href="#167、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified-cache-control-Expires分别代表什么）" class="headerlink" title="167、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified,cache-control,Expires分别代表什么）"></a>167、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified,cache-control,Expires分别代表什么）</h2><p>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档 才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</p><p>Expires  应该在什么时候认为文档已经过期，从而不再缓存它？               </p><h2 id="168、HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？"><a href="#168、HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？" class="headerlink" title="168、HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？"></a>168、HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？</h2><p>http1.0<br>http1.1 keeplive</p><h2 id="169、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css-js-服务器等方面介绍）"><a href="#169、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css-js-服务器等方面介绍）" class="headerlink" title="169、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）"></a>169、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）</h2><h2 id="170、列举常用的web页面开发，调试以及优化工具"><a href="#170、列举常用的web页面开发，调试以及优化工具" class="headerlink" title="170、列举常用的web页面开发，调试以及优化工具"></a>170、列举常用的web页面开发，调试以及优化工具</h2><p>sublime<br>vscode<br>webstorm<br>hbuilder<br>dw</p><p>httpwatch=&gt;ie</p><p>ff:firebug</p><p>chrome</p><h2 id="171、解释什么是sql注入，xss漏洞"><a href="#171、解释什么是sql注入，xss漏洞" class="headerlink" title="171、解释什么是sql注入，xss漏洞"></a>171、解释什么是sql注入，xss漏洞</h2><h2 id="172、如何判断一个js变量是数组类型"><a href="#172、如何判断一个js变量是数组类型" class="headerlink" title="172、如何判断一个js变量是数组类型"></a>172、如何判断一个js变量是数组类型</h2><p>ES5:Array.isArray()</p><p>[] instanceof Array</p><p>Object.prototype.toString.call([]);//“[object Array]”</p><h2 id="173、请列举js数组类型中的常用方法"><a href="#173、请列举js数组类型中的常用方法" class="headerlink" title="173、请列举js数组类型中的常用方法"></a>173、请列举js数组类型中的常用方法</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp" target="_blank" rel="noopener">concat()</a></td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_join.asp" target="_blank" rel="noopener">join()</a></td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_pop.asp" target="_blank" rel="noopener">pop()</a></td><td>删除并返回数组的最后一个元素</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_push.asp" target="_blank" rel="noopener">push()</a></td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_reverse.asp" target="_blank" rel="noopener">reverse()</a></td><td>颠倒数组中元素的顺序。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_shift.asp" target="_blank" rel="noopener">shift()</a></td><td>删除并返回数组的第一个元素</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_slice_array.asp" target="_blank" rel="noopener">slice()</a></td><td>从某个已有的数组返回选定的元素</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_sort.asp" target="_blank" rel="noopener">sort()</a></td><td>对数组的元素进行排序</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_splice.asp" target="_blank" rel="noopener">splice()</a></td><td>删除元素，并向数组添加新元素。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_tosource_array.asp" target="_blank" rel="noopener">toSource()</a></td><td>返回该对象的源代码。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_toString_array.asp" target="_blank" rel="noopener">toString()</a></td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_toLocaleString_array.asp" target="_blank" rel="noopener">toLocaleString()</a></td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_unshift.asp" target="_blank" rel="noopener">unshift()</a></td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.w3school.com.cn/jsref/jsref_valueof_array.asp" target="_blank" rel="noopener">valueOf()</a></td><td>返回数组对象的原始值</td></tr></tbody></table><h2 id="174、FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素"><a href="#174、FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素" class="headerlink" title="174、FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素"></a>174、FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素</h2><h2 id="175、列举常用的js框架以及分别适用的领域"><a href="#175、列举常用的js框架以及分别适用的领域" class="headerlink" title="175、列举常用的js框架以及分别适用的领域"></a>175、列举常用的js框架以及分别适用的领域</h2><p>jquery：简化了js的一些操作，并且提供了一些非常好用的API<br>jquery ui、jquery-easyui：在jqeury的基础上提供了一些常用的组件<br>日期，下拉框，表格这些组件<br>require.js、sea.js（阿里的玉帛）+》模块化开发使用的<br>zepto：精简版的jquery，常用于手机web前端开发 提供了一些手机页面实用功能,touch<br>ext.js：跟jquery差不多，但是不开源，也没有jquery轻量<br>angular、knockoutjs、avalon(去哪儿前端总监)：MV*框架，适合用于单页应用开发(SPA)</p><h2 id="176、js中如何实现一个map"><a href="#176、js中如何实现一个map" class="headerlink" title="176、js中如何实现一个map"></a>176、js中如何实现一个map</h2><p>数组的map方法：</p><p>概述</p><p><strong>map()</strong> 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</p><p>语法</p><p><em>array</em>.map(<em>callback</em>[, <em>thisArg</em>])</p><p>参数</p><p><strong>callback</strong></p><p>原数组中的元素经过该方法后返回一个新的元素。</p><p><strong>currentValue</strong></p><p>callback 的第一个参数，数组中当前被传递的元素。</p><p><strong>index</strong></p><p>callback 的第二个参数，数组中当前被传递的元素的索引。</p><p><strong>array</strong></p><p>callback 的第三个参数，调用 map 方法的数组。</p><p><strong>thisArg</strong></p><p>执行 callback 函数时 this 指向的对象。</p><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map2=function(callback)&#123;  </span><br><span class="line">for (var i = 0; i \&lt; this.length; i++) &#123;  </span><br><span class="line">this[i]=callback(this[i]);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="177、js可否实现面向对象编程，如果可以如何实现js对象的继承"><a href="#177、js可否实现面向对象编程，如果可以如何实现js对象的继承" class="headerlink" title="177、js可否实现面向对象编程，如果可以如何实现js对象的继承"></a>177、js可否实现面向对象编程，如果可以如何实现js对象的继承</h2><p>创建对象的几种方式</p><p>实现继承的几种方式</p><p><strong>原型链</strong></p><h2 id="178、约瑟夫环—已知n个人（以编号1，2，3…分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。"><a href="#178、约瑟夫环—已知n个人（以编号1，2，3…分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。" class="headerlink" title="178、约瑟夫环—已知n个人（以编号1，2，3…分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。"></a>178、约瑟夫环—已知n个人（以编号1，2，3…分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</h2><h2 id="179、有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数？"><a href="#179、有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数？" class="headerlink" title="179、有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数？"></a>179、有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数？</h2><h2 id="180、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）"><a href="#180、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）" class="headerlink" title="180、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）"></a>180、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）</h2><p>Object.keys——IE9+</p><p>或者使用<strong>for…in</strong>并过滤出继承的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(o in obj)&#123;</span><br><span class="line"></span><br><span class="line">if(obj.hasOwnproperty(o))&#123;</span><br><span class="line"></span><br><span class="line">//把o这个属性放入到一个数组中</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="181、有下面这样一段HTML结构，使用css实现这样的效果："><a href="#181、有下面这样一段HTML结构，使用css实现这样的效果：" class="headerlink" title="181、有下面这样一段HTML结构，使用css实现这样的效果："></a>181、有下面这样一段HTML结构，使用css实现这样的效果：</h2><p>左边容器无论宽度如何变动，右边容器都能自适应填满父容器剩余的宽度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=”warp”&gt;</span><br><span class="line">&lt;div class=”left”&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=”right”&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="182、下面这段代码想要循环输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果"><a href="#182、下面这段代码想要循环输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果" class="headerlink" title="182、下面这段代码想要循环输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果"></a>182、下面这段代码想要循环输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i\&lt;5;++i)&#123;</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"></span><br><span class="line">console.log(i+’’);</span><br><span class="line"></span><br><span class="line">&#125;,100\*i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="183、解释下这个css选择器什么发生什么？"><a href="#183、解释下这个css选择器什么发生什么？" class="headerlink" title="183、解释下这个css选择器什么发生什么？"></a>183、解释下这个css选择器什么发生什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[role=nav]&gt;ul a:not([href^-mailto])&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="184、JavaScript以下哪条语句会产生运行错误"><a href="#184、JavaScript以下哪条语句会产生运行错误" class="headerlink" title="184、JavaScript以下哪条语句会产生运行错误 "></a>184、JavaScript以下哪条语句会产生运行错误 </h2><p>A. var obj = ();<br>B. var obj = [];<br>C. var obj = {};<br>D. var obj = //;</p><p>答案：AD</p><h2 id="185、以下哪些是javascript的全局函数：（ABCDE）"><a href="#185、以下哪些是javascript的全局函数：（ABCDE）" class="headerlink" title="185、以下哪些是javascript的全局函数：（ABCDE）"></a>185、以下哪些是javascript的全局函数：（ABCDE）</h2><p>A. escape<br>函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。ECMAScript v3<br>反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。</p><p>B. parseFloat parseFloat() 函数可解析一个字符串，并返回一个浮点数。</p><p>该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。</p><p>C. eval 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p><p>D. setTimeout</p><p>E. alert</p><h2 id="186、关于IE的window对象表述正确的有：（CD）"><a href="#186、关于IE的window对象表述正确的有：（CD）" class="headerlink" title="186、关于IE的window对象表述正确的有：（CD）"></a>186、关于IE的window对象表述正确的有：（CD）</h2><p>A. window.opener属性本身就是指向window对象</p><p>window.opener返回打开当前窗口的那个窗口的引用.</p><p>如果当前窗口是由另一个窗口打开的, <strong>window.opener</strong>保留了那个窗口的引用.<br>如果当前窗口不是由其他窗口打开的, 则该属性返回 null.</p><p>B. window.reload()方法可以用来刷新当前页面<br>//正确答案：应该是location.reload或者window.location.reload</p><p>C.<br>window.location=”a.html”和window.location.href=”a.html”的作用都是把当前页面替换成a.html页面</p><p>D. 定义了全局变量g；可以用window.g的方式来存取该变量</p><h2 id="187、描述错误的是-D"><a href="#187、描述错误的是-D" class="headerlink" title="187、描述错误的是 D"></a>187、描述错误的是 D</h2><p>A：Http状态码302表示暂时性转移 对</p><p>B:domContentLoaded事件早于onload事件 //正确</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p><p>C: IE678不支持事件捕获</p><p>D:localStorage 存储的数据在电脑重启后丢失 //错误，因为没有时间限制</p><p>try…catch 语句。(在 IE5+、Mozilla 1.0、和 Netscape 6 中可用)</p><h2 id="188、关于link和-import的区别正确的是-A"><a href="#188、关于link和-import的区别正确的是-A" class="headerlink" title="188、关于link和@import的区别正确的是 A"></a>188、关于link和@import的区别正确的是 A</h2><p>A: link属于XHTML标签，而@import是CSS提供的；</p><p>B：页面被加载时，link会同时被加载，而后者引用的CSS会等到页面被加载完再加载</p><p>C：import只在IE5以上才能识别 而link是XHTML标签，无兼容问题</p><p>D: link方式的样式的权重高于@import的权重</p><h2 id="189、下面正确的是-A"><a href="#189、下面正确的是-A" class="headerlink" title="189、下面正确的是 A"></a>189、下面正确的是 A</h2><p>A: 跨域问题能通过JsonP方案解决</p><p>B：不同子域名间仅能通过修改window.name解决跨域 //还可以通过script标签src jsonp</p><p>C：只有在IE中可通过iframe嵌套跨域 //任何浏览器都可以使用iframe</p><p>D：MediaQuery属性是进行视频格式检测的属性是做响应式的</p><h2 id="190、基本数据类型的专业术语以及单词拼写"><a href="#190、基本数据类型的专业术语以及单词拼写" class="headerlink" title="190、基本数据类型的专业术语以及单词拼写"></a>190、基本数据类型的专业术语以及单词拼写</h2><h2 id="191、变量的命名规范以及命名推荐"><a href="#191、变量的命名规范以及命名推荐" class="headerlink" title="191、变量的命名规范以及命名推荐"></a>191、变量的命名规范以及命名推荐</h2><h2 id="192、三种弹窗的单词以及三种弹窗的功能"><a href="#192、三种弹窗的单词以及三种弹窗的功能" class="headerlink" title="192、三种弹窗的单词以及三种弹窗的功能"></a>192、三种弹窗的单词以及三种弹窗的功能</h2><p>alert</p><p>confirm</p><p>prompt</p><h2 id="193、console-log-8-1-输出值是多少？"><a href="#193、console-log-8-1-输出值是多少？" class="headerlink" title="193、console.log( 8 | 1 ); 输出值是多少？"></a>193、console.log( 8 | 1 ); 输出值是多少？</h2><p>答案：9</p><h2 id="194、只允许使用-和-Math-，求一个函数-y-f-x-a-b-当x-gt-100-时返回-a-的值，否则返回-b-的值，不能使用-if-else-等条件语句，也不能使用-数组。"><a href="#194、只允许使用-和-Math-，求一个函数-y-f-x-a-b-当x-gt-100-时返回-a-的值，否则返回-b-的值，不能使用-if-else-等条件语句，也不能使用-数组。" class="headerlink" title="194、只允许使用 + - * / 和 Math.* ，求一个函数 y = f(x, a, b);当x &gt; 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用|,?:,数组。"></a>194、只允许使用 + - * / 和 Math.* ，求一个函数 y = f(x, a, b);当x &gt; 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用|,?:,数组。</h2><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(x, a, b) &#123;</span><br><span class="line">var temp = Math.ceil(Math.min(Math.max(x - 100, 0), 1));</span><br><span class="line"> return a \* temp + b \* (1 - temp);</span><br><span class="line"> &#125;</span><br><span class="line">console.log(f(-10, 1, 2));</span><br></pre></td></tr></table></figure><h2 id="195、JavaScript-alert-0-4-0-2-结果是多少？和你预期的一样吗？如果不一样该如何处理？"><a href="#195、JavaScript-alert-0-4-0-2-结果是多少？和你预期的一样吗？如果不一样该如何处理？" class="headerlink" title="195、JavaScript alert(0.4*0.2);结果是多少？和你预期的一样吗？如果不一样该如何处理？"></a>195、JavaScript alert(0.4*0.2);结果是多少？和你预期的一样吗？如果不一样该如何处理？</h2><p>有误差，应该比准确结果偏大。<br>一般我会将小数变为整数来处理。当前之前遇到这个问题时也上网查询发现有人用try<br>catch return写了一个函数，</p><p>当然原理也是一致先转为整数再计算。看起来挺麻烦的，我没用过。</p><h2 id="196、一个div，有几种方式得到这个div的jQuery对象？-lt-div-class-’aabbcc’-id-’nodesView’-gt-lt-div-gt-想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？"><a href="#196、一个div，有几种方式得到这个div的jQuery对象？-lt-div-class-’aabbcc’-id-’nodesView’-gt-lt-div-gt-想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？" class="headerlink" title="196、一个div，有几种方式得到这个div的jQuery对象？&lt;div class=’aabbcc’ id=’nodesView’&gt;&lt;/div&gt;想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？"></a>196、一个div，有几种方式得到这个div的jQuery对象？&lt;div class=’aabbcc’ id=’nodesView’&gt;&lt;/div&gt;想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？</h2><p>var domView=document.getElementById(“nodesView”)</p><p>document.getElementsByClassName(“aabbcc”);</p><p>document.querySelector(“.aabbcc#nodesView”);</p><p>转换为jquery对象：$( domView)</p><h2 id="197、主流浏览器内核"><a href="#197、主流浏览器内核" class="headerlink" title="197、主流浏览器内核"></a>197、主流浏览器内核</h2><p>IE trident<br>火狐gecko<br>谷歌苹果webkit<br>Opera：Presto</p><h2 id="198、如何显示-隐藏一个dom元素？请用原生的JavaScript方法实现"><a href="#198、如何显示-隐藏一个dom元素？请用原生的JavaScript方法实现" class="headerlink" title="198、如何显示/隐藏一个dom元素？请用原生的JavaScript方法实现"></a>198、如何显示/隐藏一个dom元素？请用原生的JavaScript方法实现</h2><p>dom.style.display=”none”;</p><p>dom.style.display=””;</p><h2 id="199、JavaScript有哪几种数据类型"><a href="#199、JavaScript有哪几种数据类型" class="headerlink" title="199、JavaScript有哪几种数据类型"></a>199、JavaScript有哪几种数据类型</h2><p>Number String Boolean Null Undefined Object</p><h2 id="200、jQuery框架中-ajax-的常用参数有哪些？"><a href="#200、jQuery框架中-ajax-的常用参数有哪些？" class="headerlink" title="200、jQuery框架中$.ajax()的常用参数有哪些？ "></a>200、jQuery框架中$.ajax()的常用参数有哪些？ </h2><p><strong>type</strong><br>类型：String<br>默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP<br>请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。</p><p><strong>url</strong><br>类型：String<br>默认值: 当前页地址。发送请求的地址。</p><p><strong>success</strong><br>类型：Function<br>请求成功后的回调函数。<br>参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。<br>这是一个 Ajax 事件。</p><p><strong>options</strong><br>类型：Object<br>可选。AJAX 请求设置。所有选项都是可选的。</p><p><strong>async</strong><br>类型：Boolean<br>默认值:true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为<br>false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。</p><p><strong>beforeSend(XHR)</strong></p><p>类型：Function<br>发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。<br>XMLHttpRequest 对象是唯一的参数。<br>这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。</p><p><strong>cache</strong><br>类型：Boolean<br>默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false<br>将不缓存此页面。<br>jQuery 1.2 新功能。</p><p><strong>contentType</strong><br>类型：String<br>默认值:”application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。<br>默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax()<br>那么它必定会发送给服务器（即使没有数据要发送）。</p><p><strong>data</strong><br>类型：String<br>发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”,”bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。</p><p><strong>dataFilter</strong><br>类型：Function<br>给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType参数。函数返回的值将由 jQuery 进一步处理。</p><p><strong>dataType</strong><br>类型：String<br>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON就会生成一个 JavaScript 对象，而 script<br>则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:</p><ul><li>“xml”: 返回 XML 文档，可用 jQuery 处理。</li><li>“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。</li><li>“script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache”<br>参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET<br>请求。（因为将使用 DOM 的 script标签来加载）</li><li>“json”: 返回 JSON 数据 。</li><li>“jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery<br>将自动替换 ? 为正确的函数名，以执行回调函数。</li><li>“text”: 返回纯文本字符串</li></ul><p><strong>error</strong><br>类型：Function<br>默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。<br>有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。<br>如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是”timeout”, “error”, “notmodified” 和 “parsererror”。<br>这是一个 Ajax 事件。</p><p>写一个post请求并带有发送数据和返回数据的样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">url:&quot;1.html&quot;,  </span><br><span class="line">data:&#123;name:&quot;张三&quot;,age:18&#125;,//post数据  </span><br><span class="line">dataType:&quot;json&quot;,  </span><br><span class="line">type:&quot;POST&quot;,  </span><br><span class="line">success:function(*data*)&#123;  </span><br><span class="line">//data：返回的数据  </span><br><span class="line">&#125;,  </span><br><span class="line">error:function()&#123;  </span><br><span class="line">//异常处理  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="201、JavaScript数组元素添加、删除、排序等方法有哪些？"><a href="#201、JavaScript数组元素添加、删除、排序等方法有哪些？" class="headerlink" title="201、JavaScript数组元素添加、删除、排序等方法有哪些？"></a>201、JavaScript数组元素添加、删除、排序等方法有哪些？</h2><p>Array.concat( ) 连接数组</p><p>Array.join( ) 将数组元素连接起来以构建一个字符串</p><p>Array.length 数组的大小</p><p>Array.pop( ) 删除并返回数组的最后一个元素</p><p>Array.push( ) 给数组添加元素</p><p>Array.reverse( ) 颠倒数组中元素的顺序</p><p>Array.shift( ) 将元素移出数组</p><p>Array.slice( ) 返回数组的一部分</p><p>Array.sort( ) 对数组元素进行排序</p><p>Array.splice( ) 插入、删除或替换数组的元素</p><p>Array.toLocaleString( ) 把数组转换成局部字符串</p><p>Array.toString( ) 将数组转换成一个字符串</p><p>Array.unshift( ) 在数组头部插入一个元素</p><h2 id="202、如何添加html元素的事件，有几种方法？请列举"><a href="#202、如何添加html元素的事件，有几种方法？请列举" class="headerlink" title="202、如何添加html元素的事件，有几种方法？请列举"></a>202、如何添加html元素的事件，有几种方法？请列举</h2><p>a、直接在标签里添加：&lt;div onclick=”alert(你好)”&gt;这是一个层&lt;/div&gt;</p><p>b、在元素上通过js添加:</p><p>c、使用事件注册函数添加</p><h2 id="203、JavaScript的循环语句有哪些？"><a href="#203、JavaScript的循环语句有哪些？" class="headerlink" title="203、JavaScript的循环语句有哪些？"></a>203、JavaScript的循环语句有哪些？</h2><p>while for do while for…in</p><h2 id="204、作用域-编译期执行期以及全局局部作用域问题"><a href="#204、作用域-编译期执行期以及全局局部作用域问题" class="headerlink" title="204、作用域-编译期执行期以及全局局部作用域问题"></a>204、作用域-编译期执行期以及全局局部作用域问题</h2><p>理解js执行主要的两个阶段：预解析和执行期</p><h2 id="205、闭包：下面这个ul，如何点击每一列的时候alert其index？"><a href="#205、闭包：下面这个ul，如何点击每一列的时候alert其index？" class="headerlink" title="205、闭包：下面这个ul，如何点击每一列的时候alert其index？"></a>205、闭包：下面这个ul，如何点击每一列的时候alert其index？</h2><p>&lt;ul id=”test”&gt;</p><p>&lt;li&gt;这是第一条&lt;/li&gt;</p><p>&lt;li&gt;这是第二条&lt;/li&gt;</p><p>&lt;li&gt;这是第三条&lt;/li&gt;</p><p>&lt;/ul&gt;</p><p>//非闭包实现</p><p>var <em>lis</em>=document.querySelectorAll(‘li’);<br>document.querySelector(‘#test’).onclick=function(<em>e</em>){<br>for (var i = 0; i &lt; <em>lis</em>.length; i++) {<br>var li = <em>lis</em>[i];<br>if(li==<em>e</em>.target){<br>alert(i);<br>}  }<br>};</p><p>//闭包实现</p><p>var <em>lis</em>=document.querySelectorAll(‘li’);<br>for (var <em>i</em> = 0; <em>i</em> &lt; <em>lis</em>.length; <em>i</em>++) {<br>var <em>li</em> = <em>lis</em>[<em>i</em>];<br><em>li</em>.onclick=(function(<em>index</em>){<br>return function(<em>e</em>){<br>alert(<em>index</em>);<br>};<br>})(<em>i</em>);<br>}</p><h2 id="206、列出3条以上ff和IE的脚本兼容问题"><a href="#206、列出3条以上ff和IE的脚本兼容问题" class="headerlink" title="206、列出3条以上ff和IE的脚本兼容问题"></a>206、列出3条以上ff和IE的脚本兼容问题</h2><p>1、在IE下可通过document.frames[“id”];得到该IFRAME对象，</p><p>而在火狐下则是通过document.getElementById(“content_panel_if”).contentWindow;</p><p>2、IE的写法： _tbody=_table.childNodes[0]</p><p>在FF中，firefox会在子节点中包含空白则第一个子节点为空白””， 而ie不会返回空白</p><p>可以通过if(“” != node.nodeName)过滤掉空白子对象</p><p>3、模拟点击事件</p><p>if(document.all){ //ie下</p><p>document.getElementById(“a3”).click();</p><p>}</p><p>else{ //非IE</p><p>var evt = document.createEvent(“MouseEvents”);</p><p>evt.initEvent(“click”, true, true);</p><p>document.getElementById(“a3”).dispatchEvent(evt);</p><p>}</p><p>4、事件注册</p><p>if (isIE){window.attachEvent(“onload”,<br>init);}else{window.addEventListener(“load”, init, false);}</p><h2 id="207、列举可以哪些方面对前端开发进行优化"><a href="#207、列举可以哪些方面对前端开发进行优化" class="headerlink" title="207、列举可以哪些方面对前端开发进行优化"></a>207、列举可以哪些方面对前端开发进行优化</h2><p>代码压缩、合并减少http请求，图片制作精灵图、代码优化</p><h2 id="208、至少列出一种JavaScript继承的实现方式"><a href="#208、至少列出一种JavaScript继承的实现方式" class="headerlink" title="208、至少列出一种JavaScript继承的实现方式"></a>208、至少列出一种JavaScript继承的实现方式</h2><h2 id="209、如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？"><a href="#209、如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？" class="headerlink" title="209、如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？"></a>209、如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？</h2><p>//答案见：J:\代码,PPT,笔记,电子书\面试题\面试题02.html</p><h2 id="210、call与apply有什么作用？又有什么什么区别？用callee属性实现函数递归？"><a href="#210、call与apply有什么作用？又有什么什么区别？用callee属性实现函数递归？" class="headerlink" title="210、call与apply有什么作用？又有什么什么区别？用callee属性实现函数递归？"></a>210、call与apply有什么作用？又有什么什么区别？用callee属性实现函数递归？</h2><p>apply的参数是数组,call的参数是单个的值，除此之外，两者没有差别，重点理解this的改变，callee已经不推荐使用</p><h2 id="211、用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6-30的字符串？"><a href="#211、用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6-30的字符串？" class="headerlink" title="211、用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？"></a>211、用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？</h2><p>var reg=/^[a-ZA-Z][\da-zA-Z_]{5,29}/;</p><h2 id="212、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个-（10分）"><a href="#212、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个-（10分）" class="headerlink" title="212、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个 （10分）"></a>212、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个 （10分）</h2><p>对象：window document location screen history navigator</p><p>方法：alert() confirm() prompt() open() close() setInterval() setTimeout()<br>clearInterval() clearTimeout()</p><p>(详细参见：J:\代码,PPT,笔记,电子书\面试题\window对象方法.png)</p><h2 id="213、Javascript中callee和caller的作用？"><a href="#213、Javascript中callee和caller的作用？" class="headerlink" title="213、Javascript中callee和caller的作用？"></a>213、Javascript中callee和caller的作用？</h2><p>caller是返回一个对函数的引用，该函数调用了当前函数；</p><p>用法：fn.caller</p><p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p><p>用法：arguments.callee</p><h2 id="214、对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由-thisObj-指定的新对象。"><a href="#214、对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由-thisObj-指定的新对象。" class="headerlink" title="214、对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。"></a>214、对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</h2><p>但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数：?apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。?如<br>func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])<br>。</p><h2 id="215、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#215、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="215、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"></a>215、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</h2><p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。</p><p>可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。</p><h2 id="216、写一个函数可以计算-sum-5-0-5-输出0-sum-1-2-3-4-输出10"><a href="#216、写一个函数可以计算-sum-5-0-5-输出0-sum-1-2-3-4-输出10" class="headerlink" title="216、写一个函数可以计算 sum(5,0,-5);输出0; sum(1,2,3,4);输出10;"></a>216、写一个函数可以计算 sum(5,0,-5);输出0; sum(1,2,3,4);输出10;</h2><p>function calc(){<br>var result=0;<br>for (var i = 0; i &lt; arguments.length; i++) {<br>var obj = arguments[i];<br>result+=obj;<br>}  return result;<br>}  alert(calc(1,2,3,4));</p><p>Js基本功</p><h2 id="217、事件代理怎么实现？"><a href="#217、事件代理怎么实现？" class="headerlink" title="217、事件代理怎么实现？"></a>217、事件代理怎么实现？</h2><p>在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件</p><h2 id="218、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号"><a href="#218、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号" class="headerlink" title="218、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号"></a>218、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号</h2><p>常用正则表达式语法要熟悉</p><p>/0[0-9]{2,3}-\d{7,8}/</p><h2 id="219、《算法》-一下A-B可任选一题作答，两题全答加分"><a href="#219、《算法》-一下A-B可任选一题作答，两题全答加分" class="headerlink" title="219、《算法》 一下A,B可任选一题作答，两题全答加分"></a>219、《算法》 一下A,B可任选一题作答，两题全答加分</h2><p>A:农场买了一只羊，第一年是小羊，第二年底生一只，第三年不生，第四年底再生一只，第五年死掉。</p><p>B:写出代码对下列数组去重并从大到小排列{5,2,3,6,8,6,5,4,7,1,9}</p><p>先去重再排序</p><p>去重方法参考：J:\代码,PPT,笔记,电子书\面试题</p><h2 id="220、请写出一张图片的HTML代码，已知道图片地址为“images-abc-jpg”-宽100px，高50px"><a href="#220、请写出一张图片的HTML代码，已知道图片地址为“images-abc-jpg”-宽100px，高50px" class="headerlink" title="220、请写出一张图片的HTML代码，已知道图片地址为“images/abc.jpg”,宽100px，高50px"></a>220、请写出一张图片的HTML代码，已知道图片地址为“images/abc.jpg”,宽100px，高50px</h2><h2 id="221、请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成"><a href="#221、请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成" class="headerlink" title="221、请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成"></a>221、请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成</h2><p>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{6,20}$</p><h2 id="222、统计1到400亿之间的自然数中含有多少个1？比如1-21中，有1、10、11、12、13、14、15、16、17、18、19、20、21这么多自然数有13个1"><a href="#222、统计1到400亿之间的自然数中含有多少个1？比如1-21中，有1、10、11、12、13、14、15、16、17、18、19、20、21这么多自然数有13个1" class="headerlink" title="222、统计1到400亿之间的自然数中含有多少个1？比如1-21中，有1、10、11、12、13、14、15、16、17、18、19、20、21这么多自然数有13个1"></a>222、统计1到400亿之间的自然数中含有多少个1？比如1-21中，有1、10、11、12、13、14、15、16、17、18、19、20、21这么多自然数有13个1</h2><p>答案参考：J:\代码,PPT,笔记,电子书\面试题\面试题_222.html</p><h2 id="223、删除与某个字符相邻且相同的字符，比如fdaffdaaklfjklja字符串处理之后成为“fdafdaklfjklja”"><a href="#223、删除与某个字符相邻且相同的字符，比如fdaffdaaklfjklja字符串处理之后成为“fdafdaklfjklja”" class="headerlink" title="223、删除与某个字符相邻且相同的字符，比如fdaffdaaklfjklja字符串处理之后成为“fdafdaklfjklja”"></a>223、删除与某个字符相邻且相同的字符，比如fdaffdaaklfjklja字符串处理之后成为“fdafdaklfjklja”</h2><p>答案参考：J:\代码,PPT,笔记,电子书\面试题\面试题_223.html</p><h2 id="224、请写出三种以上的Firefox有但InternetExplorer没有的属性和函数"><a href="#224、请写出三种以上的Firefox有但InternetExplorer没有的属性和函数" class="headerlink" title="224、请写出三种以上的Firefox有但InternetExplorer没有的属性和函数"></a>224、请写出三种以上的Firefox有但InternetExplorer没有的属性和函数</h2><p>1、在IE下可通过document.frames[“id”];得到该IFRAME对象，</p><p>而在火狐下则是通过document.getElementById(“content_panel_if”).contentWindow;</p><p>2、IE的写法： _tbody=_table.childNodes[0]</p><p>在FF中，firefox会在子节点中包含空白则第一个子节点为空白””， 而ie不会返回空白</p><p>可以通过if(“” != node.nodeName)过滤掉空白子对象</p><p>3、模拟点击事件</p><p>if(document.all){ //ie下</p><p>document.getElementById(“a3”).click();</p><p>}</p><p>else{ //非IE</p><p>var evt = document.createEvent(“MouseEvents”);</p><p>evt.initEvent(“click”, true, true);</p><p>document.getElementById(“a3”).dispatchEvent(evt);</p><p>}</p><p>4、事件注册</p><p>if (isIE){window.attachEvent(“onload”,<br>init);}else{window.addEventListener(“load”, init, false);}</p><h2 id="225、请写出一个程序，在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：http-127-0-0-1-save-php"><a href="#225、请写出一个程序，在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：http-127-0-0-1-save-php" class="headerlink" title="225、请写出一个程序，在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：http://127.0.0.1/save.php"></a>225、请写出一个程序，在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：<a href="http://127.0.0.1/save.php" target="_blank" rel="noopener">http://127.0.0.1/save.php</a></h2><p>答案参考：J:\代码,PPT,笔记,电子书\面试题\面试题_225.html</p><h2 id="226、用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、24"><a href="#226、用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、24" class="headerlink" title="226、用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、24"></a>226、用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、24</h2><p>面试经常遇到的排序，查找算法要熟悉</p><h2 id="227、解释一下什么叫闭包，并实现一段闭包代码"><a href="#227、解释一下什么叫闭包，并实现一段闭包代码" class="headerlink" title="227、解释一下什么叫闭包，并实现一段闭包代码"></a>227、解释一下什么叫闭包，并实现一段闭包代码</h2><p>简单理解就是函数的嵌套形成闭包，闭包包括函数本身及其外部作用域</p><h2 id="228、简述一下什么叫事件委托以及其原理"><a href="#228、简述一下什么叫事件委托以及其原理" class="headerlink" title="228、简述一下什么叫事件委托以及其原理"></a>228、简述一下什么叫事件委托以及其原理</h2><p>在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件</p><h2 id="229、前端代码优化的方法"><a href="#229、前端代码优化的方法" class="headerlink" title="229、前端代码优化的方法"></a>229、前端代码优化的方法</h2><p>var User = { 对象</p><p>count = 1，属性</p><p>getCount：function（）{ 方法</p><p>return this.count;</p><p>}</p><p>}</p><p>console.log(User.getCount());</p><p>var func = User.getCount;</p><p>console.log(func());</p><p>1 undefined（window）;</p><h2 id="230、下列JavaScript代码执行后，依次alert的结果是"><a href="#230、下列JavaScript代码执行后，依次alert的结果是" class="headerlink" title="230、下列JavaScript代码执行后，依次alert的结果是"></a>230、下列JavaScript代码执行后，依次alert的结果是</h2><p>(function test(){</p><p>var a=b=5;</p><p>alert(typeof a);</p><p>alert(typeof b);</p><p>})();</p><p>alert(typeof a);</p><p>alert(typeof b);</p><p>//number number undefined number</p><h2 id="231、下列JavaScript代码执行后，iNum的值是"><a href="#231、下列JavaScript代码执行后，iNum的值是" class="headerlink" title="231、下列JavaScript代码执行后，iNum的值是"></a>231、下列JavaScript代码执行后，iNum的值是</h2><p>var iNum = 0;</p><p>for(var i = 1; i&lt; 10; i++){</p><p>if(i % 5 == 0){</p><p>continue;</p><p>}</p><p>iNum++;</p><p>}</p><p>分析：</p><p>i=1 1</p><p>i=2 2</p><p>i=3 3</p><p>i=4 4</p><p>i=5</p><p>i=6 6</p><p>i=7 7</p><p>i=8 8</p><p>i=9 9</p><h2 id="232、输出结果是多少？"><a href="#232、输出结果是多少？" class="headerlink" title="232、输出结果是多少？"></a>232、输出结果是多少？</h2><p>1） var a;</p><p>var b = a * 0;</p><p>if (b == b) {</p><p>console.log(b * 2 + “2” - 0 + 4);</p><p>} else {</p><p>console.log(!b * 2 + “2” - 0 + 4);</p><p>}</p><p>答案：26</p><p>扩展：关于乘法操作符：J:\代码,PPT,笔记,电子书\面试题\乘性操作符.png</p><p>2） &lt;script&gt;</p><p>var a = 1;</p><p>&lt;/script&gt;</p><p>&lt;script&gt;</p><p>var a;</p><p>var b = a * 0;</p><p>if (b == b) { <strong>//b=0</strong></p><p>console.log(b * 2 + “2” - 0 + 4);</p><p>} else {</p><p>console.log(!b * 2 + “2” - 0 + 4);</p><p>}</p><p>&lt;/script&gt;</p><p>答案：6</p><p>3） var t = 10;</p><p>function test(t){</p><p>var t = t++;//此时的t是一个局部变量，全局变量没有任何变化</p><p>console.log(t);//此时的结果又是多少？</p><p>}test(t);</p><p>console.log(t);</p><p>答案：10</p><p>4） var t = 10;</p><p>function test(test){</p><p>var t = test++;</p><p>}test(t);</p><p>console.log(t);</p><p>答案：10</p><p>6） var t = 10;</p><p>function test(test){</p><p>t = test++;</p><p>}test(t);</p><p>console.log(t);</p><p>答案：10</p><p>7） var t = 10;</p><p>function test(test){</p><p>t = t + test;//undefined+10=NaN</p><p>console.log(t);</p><p>var t = 3;</p><p>}test(t);</p><p>console.log(t);</p><p>答案：NaN 10</p><p>8）var a;</p><p>var b = a / 0;</p><p>if (b == b) {//b=NaN</p><p>console.log(!b * 2 + “2” - 0 + 4);</p><p>} else {</p><p>console.log(!b * 2 + “2” - 0 + 4);</p><p>}</p><p>答案：26</p><p>9）&lt;script&gt;</p><p>var a = 1;</p><p>&lt;/script&gt;</p><p>&lt;script&gt;</p><p>var a;</p><p>var b = a / 0;</p><p>if (b == b) { <strong>//b=Infinity</strong></p><p>console.log(b * 2 + “2” + 4);</p><p>} else {</p><p>console.log(!b * 2 + “2” + 4);</p><p>}</p><p>&lt;/script&gt;</p><p>答案：Infinity24</p><h2 id="233、用程序实现找到html中id名相同的元素？"><a href="#233、用程序实现找到html中id名相同的元素？" class="headerlink" title="233、用程序实现找到html中id名相同的元素？"></a>233、用程序实现找到html中id名相同的元素？</h2><p>&lt;body&gt;</p><p>&lt;form id=’form1’&gt;</p><p>&lt;div id=’div1’&gt;&lt;/div&gt;</p><p>&lt;div id=’div2’&gt;&lt;/div&gt;</p><p>&lt;div id=’div3’&gt;&lt;/div&gt;</p><p>&lt;div id=’div4’&gt;&lt;/div&gt;</p><p>&lt;div id=’div5’&gt;&lt;/div&gt;</p><p>&lt;div id=’div3’&gt;id名重复的元素&lt;/div&gt;</p><p>&lt;/form&gt;</p><p>&lt;/body&gt;</p><h2 id="234、下列JavaScript代码执行后，运行的结果是"><a href="#234、下列JavaScript代码执行后，运行的结果是" class="headerlink" title="234、下列JavaScript代码执行后，运行的结果是"></a>234、下列JavaScript代码执行后，运行的结果是</h2><p>&lt;button id=’btn’&gt;点击我&lt;/button&gt;</p><p>var btn = document.getElementById(‘btn’);</p><p>var handler = {</p><p>id: ‘_eventHandler’,</p><p>exec: function(){</p><p>alert(this.id);</p><p>}</p><p>}</p><p>btn.addEventListener(‘click’, handler.exec);</p><p>答案：btn，因为handler.exec是由btn这个按钮执行的</p><h2 id="235、☆☆☆下列JavaScript代码执行后，依次alert的结果是"><a href="#235、☆☆☆下列JavaScript代码执行后，依次alert的结果是" class="headerlink" title="235、☆☆☆下列JavaScript代码执行后，依次alert的结果是"></a>235、☆☆☆下列JavaScript代码执行后，依次alert的结果是</h2><p>var obj = {proto: {a:1,b:2}};</p><p>function F(){};</p><p>F.prototype = obj.proto;</p><p>var f = new F();</p><p>obj.proto.c = 3;</p><p>obj.proto = {a:-1, b:-2};</p><p>alert(f.a);//1</p><p>alert(f.c);//3</p><p>delete F.prototype[‘a’];</p><p>alert(f.a);//undefined</p><p>alert(obj.proto.a);//-1</p><h2 id="236、下列JavaScript代码执行后的效果是"><a href="#236、下列JavaScript代码执行后的效果是" class="headerlink" title="236、下列JavaScript代码执行后的效果是"></a>236、下列JavaScript代码执行后的效果是</h2><p>&lt;ul id=’list’&gt;</p><p>&lt;li&gt;item&lt;/li&gt;</p><p>&lt;li&gt;item&lt;/li&gt;</p><p>&lt;li&gt;item&lt;/li&gt;</p><p>&lt;li&gt;item&lt;/li&gt;</p><p>&lt;li&gt;item&lt;/li&gt;</p><p>&lt;/ul&gt;</p><p>var items = document.querySelectorAll(‘#list&gt;li’);</p><p>for(var i = 0;i &lt; items.length; i++){</p><p>setTimeout(function(){</p><p>items[i].style.backgroundColor = ‘#fee’; //元素不存在</p><p>}, 5);</p><p>}</p><p>答案：异常</p><h2 id="237、下列JavaScript代码执行后的li元素的数量是"><a href="#237、下列JavaScript代码执行后的li元素的数量是" class="headerlink" title="237、下列JavaScript代码执行后的li元素的数量是"></a>237、下列JavaScript代码执行后的li元素的数量是</h2><p>&lt;ul&gt;</p><p>&lt;li&gt;Item&lt;/li&gt;</p><p>&lt;li&gt;&lt;/li&gt;</p><p>&lt;li&gt;&lt;/li&gt;</p><p>&lt;li&gt;Item&lt;/li&gt;</p><p>&lt;li&gt;Item&lt;/li&gt;</p><p>&lt;/ul&gt;</p><p>var items = document.getElementsByTagName(‘li’);</p><p>for(var i = 0; i&lt; items.length; i++){</p><p>if(items[i].innerHTML == ‘’){</p><p>items[i].parentNode.removeChild(items[i]);</p><p>}</p><p>}</p><p>答案：4个 //删除后长度变化导致</p><h2 id="238、程序中捕获异常的方法？"><a href="#238、程序中捕获异常的方法？" class="headerlink" title="238、程序中捕获异常的方法？"></a>238、程序中捕获异常的方法？</h2><p>window.error</p><p>try{}catch(){}finally{}</p><h2 id="239、将字符串”-lt-tr-gt-lt-td-gt-id-lt-td-gt-lt-td-gt-name-lt-td-gt-lt-tr-gt-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）"><a href="#239、将字符串”-lt-tr-gt-lt-td-gt-id-lt-td-gt-lt-td-gt-name-lt-td-gt-lt-tr-gt-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）" class="headerlink" title="239、将字符串”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）"></a>239、将字符串”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）</h2><p>答案：”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$id}_{$name}&lt;/td&gt;&lt;/tr&gt;”.replace(/{\$id}/g,’10′).replace(/{\$name}/g,‘Tony’);</p><h2 id="240、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如："><a href="#240、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：" class="headerlink" title="240、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如："></a>240、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：</h2><p>addSpace(“hello world”) // -&gt; ‘h e l l o ?w o r l d’</p><p>String.prototype.spacify = function(){</p><p>return this.split(‘’).join(‘ ‘);</p><p>};</p><h2 id="241、写出函数DateDemo的返回结果，系统时间假定为今天"><a href="#241、写出函数DateDemo的返回结果，系统时间假定为今天" class="headerlink" title="241、写出函数DateDemo的返回结果，系统时间假定为今天"></a>241、写出函数DateDemo的返回结果，系统时间假定为今天</h2><p>function DateDemo(){</p><p>var d, s=”今天日期是：”;</p><p>d = new Date();</p><p>s += d.getMonth() + “/“;</p><p>s += d.getDate() + “/“;</p><p>s += d.getFullYear();</p><p>return s;</p><p>}</p><p>结果：今天日期是：7/17/2010</p><h2 id="242、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"><a href="#242、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26" class="headerlink" title="242、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"></a>242、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</h2><p>var d = new Date();</p><p>// 获取年，getFullYear()返回4位的数字</p><p>var year = d.getFullYear();</p><p>// 获取月，月份比较特殊，0是1月，11是12月</p><p>var month = d.getMonth() + 1;</p><p>// 变成两位</p><p>month = month &lt; 10 ? ‘0’ + month : month;</p><p>// 获取日</p><p>var day = d.getDate();</p><p>day = day &lt; 10 ? ‘0’ + day : day;</p><p>alert(year + ‘-‘ + month + ‘-‘ + day);</p><h2 id="243、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。"><a href="#243、已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。" class="headerlink" title="243、已知数组var?stringArray?=?[“This”,?“is”,?“Baidu”,?“Campus”]，Alert出”This?is?Baidu?Campus”。"></a>243、已知数组var?stringArray?=?[“This”,?“is”,?“Baidu”,?“Campus”]，Alert出”This?is?Baidu?Campus”。</h2><p>答案：alert(stringArray.join(“”))</p><h2 id="244、已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。"><a href="#244、已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。" class="headerlink" title="244、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。"></a>244、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</h2><p>function combo(msg){</p><p>var arr=msg.split(“-“);</p><p>for(var i=1;i&lt;arr.length;i++){</p><p>arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);</p><p>}</p><p>msg=arr.join(“”);</p><p>return msg;</p><p>}</p><h2 id="245、-var-numberArray-3-6-2-4-1-5-（考察基础API）"><a href="#245、-var-numberArray-3-6-2-4-1-5-（考察基础API）" class="headerlink" title="245、.var numberArray=[3,6,2,4,1,5]; （考察基础API）"></a>245、.var numberArray=[3,6,2,4,1,5]; （考察基础API）</h2><p>1)实现对该数组的倒排，输出[5,1,4,2,6,3]</p><p>2)实现对该数组的降序排列，输出[6,5,4,3,2,1]</p><p>function combo(msg){</p><p>var arr=msg.split(“-“);</p><p>for(var i=1;i&lt;arr.length;i++){</p><p>arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);</p><p>}</p><p>msg=arr.join(“”);</p><p>return msg;</p><p>}</p><h2 id="246、把两个数组合并，并删除第二个元素。"><a href="#246、把两个数组合并，并删除第二个元素。" class="headerlink" title="246、把两个数组合并，并删除第二个元素。"></a>246、把两个数组合并，并删除第二个元素。</h2><p>var array1 = [‘a’,’b’,’c’];</p><p>var bArray = [‘d’,’e’,’f’];</p><p>var cArray = array1</p><p>答案：</p><p>array1=array1.concat(bArray)</p><p>array1.splice(1,1)</p><h2 id="247、如何消除一个数组里面重复的元素？"><a href="#247、如何消除一个数组里面重复的元素？" class="headerlink" title="247、如何消除一个数组里面重复的元素？"></a>247、如何消除一个数组里面重复的元素？</h2><p>var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];</p><p>function deRepeat(){</p><p>var newArr=[];</p><p>var obj={};</p><p>var index=0;</p><p>var l=arr.length;</p><p>for(var i=0;i&lt;l;i++){</p><p>if(obj[arr[i]]==undefined)</p><p>{</p><p>obj[arr[i]]=1;</p><p>newArr[index++]=arr[i];</p><p>}</p><p>else if(obj[arr[i]]==1)</p><p>}</p><p>return newArr;</p><p>}</p><p>var newArr2=deRepeat(arr);</p><p>alert(newArr2); //输出1,2,3,4,5,6,9,25</p><h2 id="248、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"><a href="#248、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。" class="headerlink" title="248、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"></a>248、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</h2><p>var iArray = [];</p><p>funtion getRandom(istart, iend){</p><p>var iChoice = istart - iend +1;</p><p>return Math.floor(Math.random() * iChoice + istart;</p><p>}</p><p>for(var i=0; i&lt;10; i++){</p><p>iArray.push(getRandom(10,100));</p><p>}</p><p>iArray.sort();</p><h2 id="249、正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#249、正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="249、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？"></a>249、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？</h2><p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\\表示一个\）。使用正则表达字面量的效率更高。?</p><h2 id="250、1-var-regMail-a-zA-Z0-9-a-zA-Z0-9-a-zA-Z0-9-2-3-1-2"><a href="#250、1-var-regMail-a-zA-Z0-9-a-zA-Z0-9-a-zA-Z0-9-2-3-1-2" class="headerlink" title="250、1 var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;"></a>250、1 var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;</h2><p>正则表达式对象3 – 清除空格</p><p>写一个function，清除字符串前后的空格。（兼容所有浏览器）</p><p>使用自带接口trim()，考虑兼容性：</p><p>if (!String.prototype.trim) {</p><p>String.prototype.trim = function() {</p><p>return this.replace(/^\s+/, “”).replace(/\s+$/,””);</p><p>} }</p><p>// test the function</p><p>var str = “ \t\n test string “.trim();</p><p>alert(str == “test string”); // alerts “true”</p><h2 id="251、数组和字符串"><a href="#251、数组和字符串" class="headerlink" title="251、数组和字符串"></a>251、数组和字符串</h2><p>&lt;script lang=”JavaScript” type=”text/javascript”&gt;</p><p>function outPut(s) {</p><p>document.writeln(s);</p><p>}</p><p>var a = “lashou”;</p><p>var b = a;</p><p>outPut(b);</p><p>a = “拉手”;</p><p>outPut(a);</p><p>outPut(b);</p><p>var a_array = [1, 2, 3];</p><p>var b_array = a_array;</p><p>outPut(b_array);</p><p>a_array[3] = 4;</p><p>outPut(a_array);</p><p>outPut(b_array);</p><p>&lt;/script&gt;</p><p>输出结果：</p><p>答案：lashou 拉手 lashou 1,2,3 1,2,3,4 1,2,3,4</p><h2 id="252、第1题："><a href="#252、第1题：" class="headerlink" title="252、第1题："></a>252、第1题：</h2><p>function setName(){</p><p>name=”张三”;</p><p>}</p><p>setName();</p><p>console.log(name);</p><p>答案：”张三”</p><h2 id="253、第2题："><a href="#253、第2题：" class="headerlink" title="253、第2题："></a>253、第2题：</h2><p>//考点：1、变量声明提升 2、变量搜索机制</p><p>var a=1;</p><p>function test(){</p><p>console.log(a);</p><p>var a=1;</p><p>}</p><p>test();</p><p>答案：undefined</p><h2 id="254、第3题："><a href="#254、第3题：" class="headerlink" title="254、第3题："></a>254、第3题：</h2><p>var b=2;</p><p>function test2(){</p><p>window.b=3;</p><p>console.log(b);</p><p>}</p><p>test2();</p><p>答案：3</p><h2 id="255、第4题："><a href="#255、第4题：" class="headerlink" title="255、第4题："></a>255、第4题：</h2><p>c=5;//声明一个全局变量c</p><p>function test3(){</p><p>window.c=3;</p><p>console.log(c);<br>//答案：undefined，原因：由于此时的c是一个局部变量c，并且没有被赋值</p><p>var c;</p><p>console.log(window.c);//答案：3，原因：这里的c就是一个全局变量c</p><p>}</p><p>test3();</p><h2 id="256、第5题："><a href="#256、第5题：" class="headerlink" title="256、第5题："></a>256、第5题：</h2><p>var arr = [];</p><p>arr[0] = ‘a’;</p><p>arr[1] = ‘b’;</p><p>arr[10] = ‘c’;</p><p>alert(arr.length); //答案：11</p><p>console.log(arr[5]); //答案：undefined</p><h2 id="257、第6题："><a href="#257、第6题：" class="headerlink" title="257、第6题："></a>257、第6题：</h2><p>var a=1;</p><p>console.log(a++); //答案：1</p><p>console.log(++a); //答案：3</p><h2 id="258、第7题："><a href="#258、第7题：" class="headerlink" title="258、第7题："></a>258、第7题：</h2><p>console.log(null==undefined); //答案：true</p><p>console.log(“1”==1); //答案：true，因为会将数字1先转换为字符串1</p><p>console.log(“1”===1); //答案：false，因为数据类型不一致</p><h2 id="259、第8题："><a href="#259、第8题：" class="headerlink" title="259、第8题："></a>259、第8题：</h2><p>typeof 1; “number”</p><p>typeof “hello”; “string”</p><p>typeof /[0-9]/; “object”</p><p>typeof {}; “object”</p><p>typeof null; “object”</p><p>typeof undefined; “undefined”</p><p>typeof [1,2,3]; “object”</p><p>typeof function(){}; //“function”</p><h2 id="260、第9题："><a href="#260、第9题：" class="headerlink" title="260、第9题："></a>260、第9题：</h2><p>parseInt(3.14); //3</p><p>parseFloat(“3asdf”); //3</p><p>parseInt(“1.23abc456”);</p><p>parseInt(true);//“true” NaN</p><h2 id="261、第10题："><a href="#261、第10题：" class="headerlink" title="261、第10题："></a>261、第10题：</h2><p>//考点：函数声明提前</p><p>function bar() {</p><p>return foo;</p><p>foo = 10;</p><p>function foo() {}</p><p>//var foo = 11;</p><p>}</p><p>alert(typeof bar());//“function”</p><h2 id="262、第11题："><a href="#262、第11题：" class="headerlink" title="262、第11题："></a>262、第11题：</h2><p>考点：函数声明提前</p><p>var foo = 1;</p><p>function bar() {</p><p>foo = 10;</p><p>return;</p><p>function foo() {}</p><p>}</p><p>bar();</p><p>alert(foo);//答案：1</p><h2 id="263、第12题："><a href="#263、第12题：" class="headerlink" title="263、第12题："></a>263、第12题：</h2><p>console.log(a);//是一个函数</p><p>var a = 3;</p><p>function a(){}</p><p>console.log(a);////3</p><h2 id="264、第13题："><a href="#264、第13题：" class="headerlink" title="264、第13题："></a>264、第13题：</h2><p>//考点：对arguments的操作</p><p>function foo(a) {</p><p>arguments[0] = 2;</p><p>alert(a);//答案：2，因为：a、arguments是对实参的访问，b、通过arguments[i]可以修改指定实参的值</p><p>}</p><p>foo(1);</p><h2 id="265、第14题："><a href="#265、第14题：" class="headerlink" title="265、第14题："></a>265、第14题：</h2><p>function foo(a) {</p><p>alert(arguments.length);//答案：3，因为arguments是对实参的访问</p><p>}</p><p>foo(1, 2, 3);</p><h2 id="266、第15题"><a href="#266、第15题" class="headerlink" title="266、第15题"></a>266、第15题</h2><p>bar();//报错</p><p>var foo = function bar(name) {</p><p>console.log(“hello”+name);</p><p>console.log(bar);</p><p>};</p><p>//alert(typeof bar);</p><p>foo(“world”);//“hello”</p><p>console.log(bar);//undefined</p><p>console.log(foo.toString());</p><p>bar();//报错</p><h2 id="267、第16题"><a href="#267、第16题" class="headerlink" title="267、第16题"></a>267、第16题</h2><p>function test(){</p><p>console.log(“test函数”);</p><p>}</p><p>setTimeout(function(){</p><p>console.log(“定时器回调函数”);</p><p>}, 0)</p><p>test();</p><p>function foo(){</p><p>var name=”hello”;</p><p>}</p><hr><h1 id="H5-C3部分"><a href="#H5-C3部分" class="headerlink" title="H5+C3部分"></a>H5+C3部分</h1><h2 id="1、CSS3有哪些新特性？"><a href="#1、CSS3有哪些新特性？" class="headerlink" title="1、CSS3有哪些新特性？"></a>1、CSS3有哪些新特性？</h2><ol><li><p>CSS3实现圆角（border-radius），阴影（box-shadow），</p></li><li><p>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</p></li></ol><p>3.transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px)<br>skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</p><ol start="4"><li><p>增加了更多的CSS选择器 多背景 rgba</p></li><li><p>在CSS3中唯一引入的伪元素是 ::selection.</p></li><li><p>媒体查询，多栏布局</p></li><li><p>border-image</p></li></ol><h2 id="2、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#2、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="2、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>2、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p>新特性：</p><ol><li><p>拖拽释放(Drag and drop) API</p></li><li><p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p></li><li><p>音频、视频API(audio,video)</p></li><li><p>画布(Canvas) API</p></li><li><p>地理(Geolocation) API</p></li><li><p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</p></li><li><p>sessionStorage 的数据在浏览器关闭后自动删除</p></li><li><p>表单控件，calendar、date、time、email、url、search</p></li><li><p>新的技术webworker, websocket, Geolocation</p></li></ol><p>移除的元素：</p><ol><li><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p></li><li><p>对可用性产生负面影响的元素：frame，frameset，noframes；</p></li></ol><p>支持HTML5新标签：</p><ol><li>IE8/IE7/IE6支持通过 document.createElement<br>方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5<br>新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&lt;!--[if lt IE 9]\&gt;</span><br><span class="line"></span><br><span class="line">\&lt;script\&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;\&lt;/script\&gt;</span><br><span class="line"></span><br><span class="line">\&lt;![endif]--\&gt;</span><br></pre></td></tr></table></figure></li></ol><p>如何区分：</p><p>DOCTYPE声明新增的结构元素、功能元素</p><h2 id="3、本地存储（Local-Storage-）和cookies（储存在用户本地终端上的数据）之间的区别是什么？"><a href="#3、本地存储（Local-Storage-）和cookies（储存在用户本地终端上的数据）之间的区别是什么？" class="headerlink" title="3、本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？"></a>3、本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</h2><p>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；</p><p>本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除</p><h2 id="4、如何实现浏览器内多个标签页之间的通信"><a href="#4、如何实现浏览器内多个标签页之间的通信" class="headerlink" title="4、如何实现浏览器内多个标签页之间的通信?"></a>4、如何实现浏览器内多个标签页之间的通信?</h2><p>调用 localstorge、cookies 等本地存储方式</p><h2 id="5、你如何对网站的文件和资源进行优化？"><a href="#5、你如何对网站的文件和资源进行优化？" class="headerlink" title="5、你如何对网站的文件和资源进行优化？"></a>5、你如何对网站的文件和资源进行优化？</h2><p>文件合并</p><p>文件最小化/文件压缩</p><p>使用CDN托管</p><p>缓存的使用</p><h2 id="6、什么是响应式设计？"><a href="#6、什么是响应式设计？" class="headerlink" title="6、什么是响应式设计？"></a>6、什么是响应式设计？</h2><p>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常</p><h2 id="7、新的-HTML5-文档类型和字符集是？"><a href="#7、新的-HTML5-文档类型和字符集是？" class="headerlink" title="7、新的 HTML5 文档类型和字符集是？"></a>7、新的 HTML5 文档类型和字符集是？</h2><blockquote><p>  答：HTML5文档类型：&lt;!doctype html&gt;</p></blockquote><blockquote><p>  HTML5使用的编码&lt;meta charset=”UTF-8”&gt;</p></blockquote><h2 id="8、HTML5-Canvas-元素有什么用？"><a href="#8、HTML5-Canvas-元素有什么用？" class="headerlink" title="8、HTML5 Canvas 元素有什么用？"></a>8、HTML5 Canvas 元素有什么用？</h2><p>答：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML<br>上进行图形操作。</p><h2 id="9、HTML5-存储类型有什么区别？"><a href="#9、HTML5-存储类型有什么区别？" class="headerlink" title="9、HTML5 存储类型有什么区别？"></a>9、HTML5 存储类型有什么区别？</h2><p>答：Media API、Text Track API、Application Cache API、User Interaction、Data<br>Transfer API、Command API、Constraint Validation API、History API</p><h2 id="10、用H5-CSS3解决下导航栏最后一项掉下来的问题"><a href="#10、用H5-CSS3解决下导航栏最后一项掉下来的问题" class="headerlink" title="10、用H5+CSS3解决下导航栏最后一项掉下来的问题"></a>10、用H5+CSS3解决下导航栏最后一项掉下来的问题</h2><h2 id="11、CSS3新增伪类有那些？"><a href="#11、CSS3新增伪类有那些？" class="headerlink" title="11、CSS3新增伪类有那些？"></a>11、CSS3新增伪类有那些？</h2><p>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</p><p>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</p><p>:enabled、:disabled 控制表单控件的禁用状态。</p><p>:checked，单选框或复选框被选中。</p><h2 id="12、请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。"><a href="#12、请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。" class="headerlink" title="12、请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。"></a>12、请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。</h2><p>css属性的熟练程度和实践经验</p><h2 id="13、描述下CSS3里实现元素动画的方法"><a href="#13、描述下CSS3里实现元素动画的方法" class="headerlink" title="13、描述下CSS3里实现元素动画的方法"></a>13、描述下CSS3里实现元素动画的方法</h2><p>动画相关属性的熟悉程度</p><h2 id="14、html5-CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#14、html5-CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="14、html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>14、html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p>此题重复</p><h2 id="15、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作-一个满屏-品-字布局-如何设计"><a href="#15、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作-一个满屏-品-字布局-如何设计" class="headerlink" title="15、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?"></a>15、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?</h2><p>* 首先划分成头部、body、脚部；。。。。。</p><p>* 实现效果图是最基本的工作，精确到2px；</p><p>与设计师，产品经理的沟通和项目的参与</p><p>做好的页面结构，页面重构和用户体验</p><p>处理hack，兼容、写出优美的代码格式</p><p>针对服务器的优化、拥抱 HTML5。</p><h2 id="16、你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#16、你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="16、你能描述一下渐进增强和优雅降级之间的不同吗?"></a><strong>16、你能描述一下渐进增强和优雅降级之间的不同吗?</strong></h2><blockquote><p>  渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p></blockquote><blockquote><p>  优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p></blockquote><p>　　区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。　</p><p>　　“优雅降级”观点</p><p>　　“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</p><p>　　在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>　　“渐进增强”观点</p><p>　　“渐进增强”观点则认为应关注于内容本身。</p><p>　　内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>　　那么问题了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h2 id="17、为什么利用多个域名来存储网站资源会更有效？"><a href="#17、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="17、为什么利用多个域名来存储网站资源会更有效？"></a><strong>17、为什么利用多个域名来存储网站资源会更有效？</strong></h2><p>CDN缓存更方便<br>突破浏览器并发限制<br>节约cookie带宽<br>节约主域名的连接数，优化页面响应速度<br>防止不必要的安全问题</p><h2 id="18、请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#18、请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="18、请谈一下你对网页标准和标准制定机构重要性的理解。"></a>18、<strong>请谈一下你对网页标准和标准制定机构重要性的理解。</strong></h2><p>　　（无标准答案）网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。</p><h2 id="19、请描述一下cookies，sessionStorage和localStorage的区别？"><a href="#19、请描述一下cookies，sessionStorage和localStorage的区别？" class="headerlink" title="19、请描述一下cookies，sessionStorage和localStorage的区别？　　"></a>19、<strong>请描述一下cookies，sessionStorage和localStorage的区别？</strong>　　</h2><p>　　sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>web storage和cookie的区别</p><blockquote><p>  Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p></blockquote><blockquote><p>  除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p></blockquote><h2 id="20、知道css有个content属性吗？有什么作用？有什么应用？"><a href="#20、知道css有个content属性吗？有什么作用？有什么应用？" class="headerlink" title="20、知道css有个content属性吗？有什么作用？有什么应用？"></a><strong>20、知道css有个content属性吗？有什么作用？有什么应用？</strong></h2><p>知道。css的content属性专门应用在 before/after<br>伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。</p><p>//一种常见利用伪类清除浮动的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">content:&quot;.&quot;; //这里利用到了content属性</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both; </span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after伪元素通过 content<br>在元素的后面生成了内容为一个点的块级素，再利用clear:both清除浮动。<br>　　那么问题继续还有，知道css计数器（序列数字字符自动递增）吗？如何通过css<br>content属性实现css计数器？<br>答案：css计数器是通过设置counter-reset 、counter-increment 两个属性 、及<br>counter()/counters()一个方法配合after / before 伪类实现。 </p><h2 id="21、如何在-HTML5-页面中嵌入音频"><a href="#21、如何在-HTML5-页面中嵌入音频" class="headerlink" title="21、如何在 HTML5 页面中嵌入音频?"></a>21、如何在 HTML5 页面中嵌入音频?</h2><p>HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：</p><p>&lt;audio controls&gt; </p><p>  &lt;source src=”jamshed.mp3” type=”audio/mpeg”&gt; </p><p>   Your browser does’nt support audio embedding feature. </p><p>&lt;/audio&gt;</p><h2 id="22、如何在-HTML5-页面中嵌入视频？"><a href="#22、如何在-HTML5-页面中嵌入视频？" class="headerlink" title="22、如何在 HTML5 页面中嵌入视频？"></a>22、如何在 HTML5 页面中嵌入视频？</h2><p>和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：</p><p>&lt;video width=”450” height=”340” controls&gt; </p><p>  &lt;source src=”jamshed.mp4” type=”video/mp4”&gt; </p><p>   Your browser does’nt support video embedding feature. </p><p>&lt;/video&gt; </p><h2 id="23、HTML5-引入什么新的表单属性？"><a href="#23、HTML5-引入什么新的表单属性？" class="headerlink" title="23、HTML5 引入什么新的表单属性？"></a>23、HTML5 引入什么新的表单属性？</h2><p>Datalist datetime output keygen date month week time number range emailurl</p><h2 id="24、CSS3新增伪类有那些？"><a href="#24、CSS3新增伪类有那些？" class="headerlink" title="24、CSS3新增伪类有那些？"></a>24、CSS3新增伪类有那些？</h2><p>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</p><p>p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</p><p>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</p><p>:enabled、:disabled 控制表单控件的禁用状态。</p><p>:checked，单选框或复选框被选中。</p><h2 id="25、-写-描述一段语义的html代码吧。"><a href="#25、-写-描述一段语义的html代码吧。" class="headerlink" title="25、(写)描述一段语义的html代码吧。"></a>25、(写)描述一段语义的html代码吧。</h2><p>（HTML5中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt;和&lt;footer&gt;等）</p><p>就是基于语义化设计原则）</p><p>&lt; div id=”header”&gt;</p><p>&lt; h1&gt;标题&lt; /h1&gt;</p><p>&lt; h2&gt;专注Web前端技术&lt; /h2&gt;</p><p>&lt; /div&gt;</p><p>语义 HTML 具有以下特性：</p><p>文字包裹在元素中，用以反映内容。例如：</p><p>段落包含在 &lt;p&gt; 元素中。</p><p>顺序表包含在&lt;ol&gt;元素中。</p><p>从其他来源引用的大型文字块包含在&lt;blockquote&gt;元素中。</p><p>HTML 元素不能用作语义用途以外的其他目的。例如：</p><p>&lt;h1&gt;包含标题，但并非用于放大文本。</p><p>&lt;blockquote&gt;包含大段引述，但并非用于文本缩进。</p><p>空白段落元素 ( &lt;p&gt;&lt;/p&gt; ) 并非用于跳行。</p><p>文本并不直接包含任何样式信息。例如：</p><p>不使用 &lt;font&gt; 或 &lt;center&gt; 等格式标记。</p><p>类或 ID 中不引用颜色或位置。</p><h2 id="26-cookie相比sessionStorage和localStorage，有什么区别"><a href="#26-cookie相比sessionStorage和localStorage，有什么区别" class="headerlink" title="26.cookie相比sessionStorage和localStorage，有什么区别"></a>26.cookie相比sessionStorage和localStorage，有什么区别</h2><p>sessionStorage和localStorage的存储空间更大；</p><p>sessionStorage和localStorage有更多丰富易用的接口；</p><p>sessionStorage和localStorage各自独立的存储空间；</p><h2 id="27、这道题重复"><a href="#27、这道题重复" class="headerlink" title="27、这道题重复"></a>27、这道题重复</h2><h2 id="28、如何区分：-DOCTYPE声明-新增的结构元素-功能元素"><a href="#28、如何区分：-DOCTYPE声明-新增的结构元素-功能元素" class="headerlink" title="28、如何区分： DOCTYPE声明\新增的结构元素\功能元素"></a>28、如何区分： DOCTYPE声明\新增的结构元素\功能元素</h2><h2 id="29、语义化的理解？"><a href="#29、语义化的理解？" class="headerlink" title="29、语义化的理解？"></a>29、语义化的理解？</h2><p>用正确的标签做正确的事情！</p><p>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</p><p>在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。</p><p>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。</p><p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p><h2 id="30、HTML5的离线储存？"><a href="#30、HTML5的离线储存？" class="headerlink" title="30、HTML5的离线储存？"></a>30、HTML5的离线储存？</h2><p>localStorage 长期存储数据，浏览器关闭后数据不丢失；</p><p>sessionStorage 数据在浏览器关闭后自动删除。</p><h2 id="31、写出HTML5的文档声明方式"><a href="#31、写出HTML5的文档声明方式" class="headerlink" title="31、写出HTML5的文档声明方式"></a>31、写出HTML5的文档声明方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DOCYPE html&gt;</span><br></pre></td></tr></table></figure><h2 id="32、HTML5和CSS3的新标签"><a href="#32、HTML5和CSS3的新标签" class="headerlink" title="32、HTML5和CSS3的新标签     "></a>32、HTML5和CSS3的新标签     </h2><p>HTML5： nav, footer, header, section, hgroup, video, time, canvas, audio… </p><p>CSS3: RGBA, opacity, text-shadow, box-shadow, border-radius, border-image,  border-color, transform…;</p><h2 id="33、自己对标签语义化的理解"><a href="#33、自己对标签语义化的理解" class="headerlink" title="33、自己对标签语义化的理解"></a>33、自己对标签语义化的理解</h2><p>在我看来，语义化就是比如说一个段落， 那么我们就应该用<br>&lt;p&gt;标签来修饰，标题就应该用 &lt;h?&gt;标签等。符合文档语义的标签。</p><hr><h1 id="JQuery部分"><a href="#JQuery部分" class="headerlink" title="JQuery部分"></a>JQuery部分</h1><h2 id="1、jQuery-的-slideUp动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢"><a href="#1、jQuery-的-slideUp动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢" class="headerlink" title="1、jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?"></a>1、jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</h2><p>先stop(true,true)后slideUp()</p><p>示例代码参考：J:\代码,PPT,笔记,电子书\面试题\面试题_jquery_slideup.html</p><p>关于stop()参考：J:\代码,PPT,笔记,电子书\面试题\面试题_jquery.png</p><hr><h1 id="移动端部分"><a href="#移动端部分" class="headerlink" title="移动端部分"></a>移动端部分</h1><h2 id="1、移动端常用类库及优缺点"><a href="#1、移动端常用类库及优缺点" class="headerlink" title="1、移动端常用类库及优缺点"></a>1、移动端常用类库及优缺点</h2><p>知识面宽度，多多益善</p><p>Jquery,zepto</p><p>Underscore 提供类似prototype.js的功能,但没有继承任何js内置对象</p><p>RequireJS 你可以顺序读取仅需要相关依赖模块</p><hr><h1 id="AJAX部分"><a href="#AJAX部分" class="headerlink" title="AJAX部分"></a>AJAX部分</h1><h2 id="1、Ajax-是什么-如何创建一个Ajax？"><a href="#1、Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="1、Ajax 是什么? 如何创建一个Ajax？"></a>1、Ajax 是什么? 如何创建一个Ajax？</h2><p>Ajax并不算是一种新的技术，全称是asynchronous javascript and<br>xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持</p><p>使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果</p><p>基本步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var xhr =null;//创建对象</span><br><span class="line"></span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line"></span><br><span class="line">xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(“方式”,”地址”,”标志位”);//初始化请求</span><br><span class="line"></span><br><span class="line">xhr.setRequestHeader(“”,””);//设置http头信息</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange =function()&#123;&#125;//指定回调函数</span><br><span class="line"></span><br><span class="line">xhr.send();//发送请求</span><br></pre></td></tr></table></figure><p>js框架（jQuery/EXTJS等）提供的ajax<br>API对原生的ajax进行了封装，熟悉了基础理论，再学习别的框架就会得心应手，好多都是换汤不换药的内容</p><h2 id="2、同步和异步的区别"><a href="#2、同步和异步的区别" class="headerlink" title="2、同步和异步的区别?"></a>2、同步和异步的区别?</h2><p>同步：阻塞的</p><p>-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面</p><p>异步：非阻塞的</p><p>-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</p><h2 id="3、如何解决跨域问题"><a href="#3、如何解决跨域问题" class="headerlink" title="3、如何解决跨域问题?"></a>3、如何解决跨域问题?</h2><p>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p>出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是<strong>函数调用</strong>，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案</p><h2 id="4、页面编码和被请求的资源编码如果不一致如何处理？"><a href="#4、页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="4、页面编码和被请求的资源编码如果不一致如何处理？"></a>4、页面编码和被请求的资源编码如果不一致如何处理？</h2><p>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用<br>encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码</p><h2 id="5、简述ajax-的过程。"><a href="#5、简述ajax-的过程。" class="headerlink" title="5、简述ajax 的过程。"></a>5、简述ajax 的过程。</h2><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h2 id="6、阐述一下异步加载。"><a href="#6、阐述一下异步加载。" class="headerlink" title="6、阐述一下异步加载。"></a>6、阐述一下异步加载。</h2><ol><li>异步加载的方案： 动态插入 script 标签</li><li>通过 ajax 去获取 js 代码，然后通过 eval 执行</li><li>script 标签上添加 defer 或者 async 属性</li><li>创建并插入 iframe，让它异步执行 js</li></ol><h2 id="7、请解释一下-JavaScript-的同源策略。"><a href="#7、请解释一下-JavaScript-的同源策略。" class="headerlink" title="7、请解释一下 JavaScript 的同源策略。"></a>7、请解释一下 JavaScript 的同源策略。</h2><p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape<br>Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h2 id="8、GET和POST的区别，何时使用POST？"><a href="#8、GET和POST的区别，何时使用POST？" class="headerlink" title="8、GET和POST的区别，何时使用POST？"></a>8、GET和POST的区别，何时使用POST？</h2><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符</p><p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p><p>在以下情况中，请使用 POST 请求：</p><ol><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><h2 id="9、ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><a href="#9、ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题" class="headerlink" title="9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?"></a>9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h2><ol><li>通过异步模式，提升了用户体验</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li><li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li></ol><h2 id="10、-Ajax的最大的特点是什么。"><a href="#10、-Ajax的最大的特点是什么。" class="headerlink" title="10、 Ajax的最大的特点是什么。"></a>10、 Ajax的最大的特点是什么。</h2><p>Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；</p><h2 id="11、ajax的缺点"><a href="#11、ajax的缺点" class="headerlink" title="11、ajax的缺点"></a>11、ajax的缺点</h2><p>1、ajax不支持浏览器back按钮。<br>2、安全问题 AJAX暴露了与服务器交互的细节。<br>3、对搜索引擎的支持比较弱。<br>4、破坏了程序的异常机制。</p><h2 id="12、ajax请求的时候get-和post方式的区别"><a href="#12、ajax请求的时候get-和post方式的区别" class="headerlink" title="12、ajax请求的时候get 和post方式的区别"></a>12、ajax请求的时候get 和post方式的区别</h2><p>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。</p><p>post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。</p><h2 id="13、解释jsonp的原理，以及为什么不是真正的ajax"><a href="#13、解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="13、解释jsonp的原理，以及为什么不是真正的ajax"></a>13、解释jsonp的原理，以及为什么不是真正的ajax</h2><p>　　Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术</p><h2 id="14、什么是Ajax和JSON，它们的优缺点。"><a href="#14、什么是Ajax和JSON，它们的优缺点。" class="headerlink" title="14、什么是Ajax和JSON，它们的优缺点。"></a>14、什么是Ajax和JSON，它们的优缺点。</h2><p>Ajax是全称是asynchronous JavaScript<br>andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。</p><p>优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验</p><p>缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；</p><p>JSON是一种轻量级的数据交换格式，ECMA的一个子集</p><p>优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</p><h2 id="15、http常见的状态码有那些？分别代表是什么意思？"><a href="#15、http常见的状态码有那些？分别代表是什么意思？" class="headerlink" title="15、http常见的状态码有那些？分别代表是什么意思？"></a>15、http常见的状态码有那些？分别代表是什么意思？</h2><p>200 - 请求成功</p><p>301 - 资源（网页等）被永久转移到其它URL</p><p>404 - 请求的资源（网页等）不存在</p><p>500 - 内部服务器错误</p><h2 id="16、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#16、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><p>分为4个步骤：</p><ol><li><p>当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web<br>页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS<br>服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</p></li><li><p>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP<br>连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在<br>浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p></li><li><p>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET<br>请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP<br>响应状态表示一个正确的响应。</p></li><li><p>此时，Web 服务器提供资源服务，客户端开始下载资源。</p></li></ol><h2 id="17、ajax请求的时候get-和post方式的区别"><a href="#17、ajax请求的时候get-和post方式的区别" class="headerlink" title="17、ajax请求的时候get 和post方式的区别"></a>17、ajax请求的时候get 和post方式的区别</h2><p>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。</p><p>post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。</p><h2 id="18、ajax请求时，如何解释json数据"><a href="#18、ajax请求时，如何解释json数据" class="headerlink" title="18、ajax请求时，如何解释json数据"></a>18、ajax请求时，如何解释json数据</h2><p>使用eval() 或者JSON.parse()<br>鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。</p><h2 id="19、javascript的本地对象，内置对象和宿主对象"><a href="#19、javascript的本地对象，内置对象和宿主对象" class="headerlink" title="19、javascript的本地对象，内置对象和宿主对象"></a>19、javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为独立于宿主环境的ECMAScript提供的对象，包括Array Object<br>RegExp等可以new实例化的对象</p><p>内置对象为Gload，Math<br>等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)</p><p>宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window<br>等对象</p><h2 id="20、为什么利用多个域名来存储网站资源会更有效？"><a href="#20、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="20、为什么利用多个域名来存储网站资源会更有效？"></a>20、为什么利用多个域名来存储网站资源会更有效？</h2><p>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。</p><h2 id="21、请说出三种减低页面加载时间的方法"><a href="#21、请说出三种减低页面加载时间的方法" class="headerlink" title="21、请说出三种减低页面加载时间的方法"></a>21、请说出三种减低页面加载时间的方法</h2><p>1、压缩css、js文件<br>2、合并js、css文件，减少http请求<br>3、外部js、css文件放在最底下<br>4、减少dom操作，尽可能用变量替代不必要的dom操作</p><h2 id="22、HTTP状态码都有那些。"><a href="#22、HTTP状态码都有那些。" class="headerlink" title="22、HTTP状态码都有那些。"></a>22、HTTP状态码都有那些。</h2><p>200 OK //客户端请求成功</p><p>400 Bad Request //客户端请求有语法错误，不能被服务器所理解</p><p>403 Forbidden //服务器收到请求，但是拒绝提供服务</p><p>404 Not Found //请求资源不存在，输入了错误的URL</p><p>500 Internal Server Error //服务器发生不可预期的错误</p><p>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><hr><h1 id="JS高级部分"><a href="#JS高级部分" class="headerlink" title="JS高级部分"></a>JS高级部分</h1><h2 id="1-JQuery一个对象可以同时绑定多个事件，这是如何实现的？"><a href="#1-JQuery一个对象可以同时绑定多个事件，这是如何实现的？" class="headerlink" title="1.JQuery一个对象可以同时绑定多个事件，这是如何实现的？"></a>1.JQuery一个对象可以同时绑定多个事件，这是如何实现的？</h2><p>jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。</p><h2 id="2-知道什么是webkit么-知道怎么用浏览器的各种工具来调试和debug代码么"><a href="#2-知道什么是webkit么-知道怎么用浏览器的各种工具来调试和debug代码么" class="headerlink" title="2.知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?"></a>2.知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</h2><p>Webkit是浏览器引擎，包括html渲染和js解析功能，手机浏览器的主流内核，与之相对应的引擎有Gecko（Mozilla<br>Firefox 等使用）和Trident（也称MSHTML，IE 使用）。</p><p>对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js调试工具使用，熟练使用这些工具可以快速提高解决问题的效率</p><h2 id="3-如何测试前端代码-知道BDD-TDD-Unit-Test么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit"><a href="#3-如何测试前端代码-知道BDD-TDD-Unit-Test么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit" class="headerlink" title="3.如何测试前端代码? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?"></a>3.如何测试前端代码? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</h2><p>了解BDD行为驱动开发与TDD测试驱动开发已经单元测试相关概念，</p><h2 id="4、前端templating-Mustache-underscore-handlebars-是干嘛的-怎么用"><a href="#4、前端templating-Mustache-underscore-handlebars-是干嘛的-怎么用" class="headerlink" title="4、前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?"></a>4、前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</h2><p>Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，</p><p>Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在Javascript、PHP、Python、Perl 等多种编程语言中。</p><p>Underscore封装了常用的JavaScript对象操作方法，用于提高开发效率。</p><p>Handlebars 是 JavaScript一个语义模板库，通过对view和data的分离来快速构建Web模板。</p><h2 id="5、简述一下-Handlebars-的基本用法？"><a href="#5、简述一下-Handlebars-的基本用法？" class="headerlink" title="5、简述一下 Handlebars 的基本用法？"></a>5、简述一下 Handlebars 的基本用法？</h2><p>没有用过的话说出它是干什么的即可</p><p>官网：<a href="http://handlebarsjs.com/" target="_blank" rel="noopener">http://handlebarsjs.com/</a></p><p>参考：J:\代码,PPT,笔记,电子书\面试题\handlebarDemo</p><h2 id="6、简述一下-Handlerbars-的对模板的基本处理流程，-如何编译的？如何缓存的？"><a href="#6、简述一下-Handlerbars-的对模板的基本处理流程，-如何编译的？如何缓存的？" class="headerlink" title="6、简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？"></a>6、简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</h2><p>学习技术不仅要会用，还有熟悉它的实现机制，这样在开发中遇到问题时才能更好的解决</p><h2 id="7、用js实现千位分隔符"><a href="#7、用js实现千位分隔符" class="headerlink" title="7、用js实现千位分隔符?"></a>7、用js实现千位分隔符?</h2><p>原生js的熟练度，实践经验，实现思路</p><h2 id="8、检测浏览器版本版本有哪些方式？"><a href="#8、检测浏览器版本版本有哪些方式？" class="headerlink" title="8、检测浏览器版本版本有哪些方式？"></a>8、检测浏览器版本版本有哪些方式？</h2><p>IE与标准浏览器判断，IE不同版本的判断，navigaition.User-Agent var ie = /*@cc_on<br>!@*/false;</p><h2 id="9、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获"><a href="#9、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获" class="headerlink" title="9、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获"></a>9、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获</h2><p>对两种事件模型的理解</p><p><strong>绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件<br>-&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。</strong></p><h2 id="10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h2><ul><li><p>考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚</p></li><li><p>考察点2：是否知道如何判断一个变量是什么类型的</p></li><li><p>考察点3：递归算法的设计</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：</span><br><span class="line">Object.prototype.clone = function()&#123;</span><br><span class="line">   var o = this.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">   for(var e in this)&#123;</span><br><span class="line">      o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];</span><br><span class="line">   &#125;</span><br><span class="line">   return o;</span><br><span class="line">&#125;</span><br><span class="line">//方法二：</span><br><span class="line">     /**</span><br><span class="line">     * 克隆一个对象</span><br><span class="line">     * @param Obj</span><br><span class="line">     * @returns</span><br><span class="line">     */</span><br><span class="line">    function clone(Obj) &#123;   </span><br><span class="line">        var buf;   </span><br><span class="line">        if (Obj instanceof Array) &#123;   </span><br><span class="line">            buf = [];//创建一个空的数组 </span><br><span class="line">            var i = Obj.length;   </span><br><span class="line">            while (i--) &#123;   </span><br><span class="line">                buf[i] = clone(Obj[i]);   </span><br><span class="line">            &#125;   </span><br><span class="line">            return buf;    </span><br><span class="line">        &#125;else if (Obj instanceof Object)&#123;   </span><br><span class="line">            buf = &#123;&#125;;//创建一个空对象 </span><br><span class="line">            for (var k in Obj) &#123; //为这个对象添加新的属性 </span><br><span class="line">                buf[k] = clone(Obj[k]);   </span><br><span class="line">            &#125;   </span><br><span class="line">            return buf;   </span><br><span class="line">        &#125;else&#123; //普通变量直接赋值</span><br><span class="line">            return Obj;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="11、如何消除一个数组里面重复的元素？"><a href="#11、如何消除一个数组里面重复的元素？" class="headerlink" title="11、如何消除一个数组里面重复的元素？"></a>11、如何消除一个数组里面重复的元素？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];</span><br><span class="line">        function deRepeat()&#123;</span><br><span class="line">            var newArr=[];</span><br><span class="line">            var obj=&#123;&#125;;</span><br><span class="line">            var index=0;</span><br><span class="line">            var l=arr.length;</span><br><span class="line">            for(var i=0;i&lt;l;i++)&#123;</span><br><span class="line">                if(obj[arr[i]]==undefined)</span><br><span class="line">                  &#123;</span><br><span class="line">                    obj[arr[i]]=1;</span><br><span class="line">                    newArr[index++]=arr[i];</span><br><span class="line">                  &#125;</span><br><span class="line">                else if(obj[arr[i]]==1)</span><br><span class="line">                  continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return newArr;</span><br><span class="line">        &#125;</span><br><span class="line">        var newArr2=deRepeat(arr);</span><br><span class="line">        alert(newArr2); //输出1,2,3,4,5,6,9,25</span><br></pre></td></tr></table></figure><h2 id="12、小贤是一条可爱的小狗-Dog-，它的叫声很好听-wow-，每次看到主人的时候就会乖乖叫一声-yelp-。从这段描述可以得到以下对象："><a href="#12、小贤是一条可爱的小狗-Dog-，它的叫声很好听-wow-，每次看到主人的时候就会乖乖叫一声-yelp-。从这段描述可以得到以下对象：" class="headerlink" title="12、小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象："></a>12、小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Dog() &#123;</span><br><span class="line">      this.wow = function() &#123;</span><br><span class="line">               alert(’Wow’);</span><br><span class="line">      &#125;</span><br><span class="line">      this.yelp = function() &#123;</span><br><span class="line">              this.wow();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function MadDog() &#123;</span><br><span class="line">    this.yelp = function() &#123;</span><br><span class="line">          var self = this;          </span><br><span class="line">          setInterval(function() &#123;</span><br><span class="line">                self.wow();      </span><br><span class="line">          &#125;, 500);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">MadDog.prototype = new Dog();         </span><br><span class="line">//for test</span><br><span class="line">var dog = new Dog();</span><br><span class="line">dog.yelp();</span><br><span class="line">var madDog = new MadDog();</span><br><span class="line">madDog.yelp();</span><br></pre></td></tr></table></figure><h2 id="13、下面这个ul，如何点击每一列的时候alert其index-（闭包）"><a href="#13、下面这个ul，如何点击每一列的时候alert其index-（闭包）" class="headerlink" title="13、下面这个ul，如何点击每一列的时候alert其index?（闭包）"></a>13、下面这个ul，如何点击每一列的时候alert其index?（闭包）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=”test”&gt;</span><br><span class="line">&lt;li&gt;这是第一条&lt;/li&gt;</span><br><span class="line">&lt;li&gt;这是第二条&lt;/li&gt;</span><br><span class="line">&lt;li&gt;这是第三条&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// 方法一：</span><br><span class="line">var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">    lis[i].index=i;</span><br><span class="line">    lis[i].onclick=function()&#123;</span><br><span class="line">        alert(this.index);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">//方法二：</span><br><span class="line">var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for(var i=0;i&lt;3;i++)&#123;</span><br><span class="line">    lis[i].index=i;</span><br><span class="line">    lis[i].onclick=(function(a)&#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            alert(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、编写一个JavaScript函数，输入指定类型的选择器-仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器-可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。"><a href="#14、编写一个JavaScript函数，输入指定类型的选择器-仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器-可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。" class="headerlink" title="14、编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。"></a>14、编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*** @param selector &#123;String&#125; 传入的CSS选择器。* @return &#123;Array&#125;*/</span><br><span class="line">var query = function(selector) &#123;</span><br><span class="line">var reg = /^(#)?(\.)?(\w+)$/img;</span><br><span class="line">var regResult = reg.exec(selector);</span><br><span class="line">var result = [];</span><br><span class="line">//如果是id选择器</span><br><span class="line">if(regResult[1]) &#123;</span><br><span class="line">if(regResult[3]) &#123;</span><br><span class="line">if(typeof document.querySelector === &quot;function&quot;) &#123;</span><br><span class="line">result.push(document.querySelector(regResult[3]));</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      result.push(document.getElementById(regResult[3]));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //如果是class选择器</span><br><span class="line">   else if(regResult[2]) &#123;</span><br><span class="line">      if(regResult[3]) &#123;</span><br><span class="line">       if(typeof document.getElementsByClassName === &apos;function&apos;) &#123;</span><br><span class="line">         var doms = document.getElementsByClassName(regResult[3]);</span><br><span class="line">         if(doms) &#123;</span><br><span class="line">            result = converToArray(doms);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     //如果不支持getElementsByClassName函数</span><br><span class="line">     else &#123;</span><br><span class="line">        var allDoms = document.getElementsByTagName(&quot;*&quot;) ;</span><br><span class="line">       for(var i = 0, len = allDoms.length; i &lt; len; i++) &#123;</span><br><span class="line">         if(allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) &#123;</span><br><span class="line">           result.push(allDoms[i]);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">  //如果是标签选择器</span><br><span class="line">  else if(regResult[3]) &#123;</span><br><span class="line">    var doms = document.getElementsByTagName(regResult[3].toLowerCase());</span><br><span class="line">    if(doms) &#123;</span><br><span class="line">      result = converToArray(doms);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br><span class="line">  function converToArray(nodes)&#123;</span><br><span class="line">    var array = null;         </span><br><span class="line">    try&#123;        </span><br><span class="line">      array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器         </span><br><span class="line">     &#125;catch(ex)&#123;</span><br><span class="line">       array = new Array();         </span><br><span class="line">     for( var i = 0 ,len = nodes.length; i &lt; len ; i++ ) &#123; </span><br><span class="line">      array.push(nodes[i])         </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;      </span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、请评价以下代码并给出改进意见。"><a href="#15、请评价以下代码并给出改进意见。" class="headerlink" title="15、请评价以下代码并给出改进意见。"></a>15、请评价以下代码并给出改进意见。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(window.addEventListener)&#123;</span><br><span class="line">    var addListener = function(el,type,listener,useCapture)&#123;</span><br><span class="line">        el.addEventListener(type,listener,useCapture);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">else if(document.all)&#123;</span><br><span class="line">    addListener = function(el,type,listener)&#123;</span><br><span class="line">        el.attachEvent(&quot;on&quot;+type,function()&#123;</span><br><span class="line">          listener.apply(el);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>　不应该在if和else语句中声明addListener函数，应该先声明；</p></li><li><p>　不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测；</p></li><li><p>　由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下</p></li></ul><p>改进如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem, type, handler)&#123;</span><br><span class="line">　　if(elem.addEventListener)&#123;</span><br><span class="line">　　　　elem.addEventListener(type, handler, false);</span><br><span class="line">　　&#125;else if(elem.attachEvent)&#123;</span><br><span class="line">　　　　elem[&apos;temp&apos; + type + handler] = handler;</span><br><span class="line">　　　　elem[type + handler] = function()&#123;</span><br><span class="line">　　　　elem[&apos;temp&apos; + type + handler].apply(elem);</span><br><span class="line">　　&#125;;</span><br><span class="line">　　elem.attachEvent(&apos;on&apos; + type, elem[type + handler]);　</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">　　elem[&apos;on&apos; + type] = handler;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如："><a href="#16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：" class="headerlink" title="16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如："></a>16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSpace(“hello world”) // -&gt; ‘h e l l o  w o r l d’</span><br><span class="line">String.prototype.spacify = function()&#123;</span><br><span class="line">      return this.split(&apos;&apos;).join(&apos; &apos;);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>接着上述问题答案提问<br>1）直接在对象的原型上添加方法是否安全？尤其是在Object对象上。(这个我没能答出？希望知道的说一下。)　<br>2）函数声明与函数表达式的区别？</p><p>答案：在js中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</p><h2 id="17、定义一个log方法，让它可以代理console-log的方法。"><a href="#17、定义一个log方法，让它可以代理console-log的方法。" class="headerlink" title="17、定义一个log方法，让它可以代理console.log的方法。"></a>17、定义一个log方法，让它可以代理console.log的方法。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可行的方法一：</span><br><span class="line">function log(msg)　&#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">log(&quot;hello world!&quot;) // hello world!</span><br><span class="line">如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：</span><br><span class="line">function log()&#123;</span><br><span class="line">    console.log.apply(console, arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此，追问apply和call方法的异同。</p><p>对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由<br>thisObj 指定的新对象。</p><p>但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如<br>func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])</p><h2 id="18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"></a>18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</h2><p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。</p><p>假设接第八题题干，我们要给每个log方法添加一个”(app)”前缀，比如’hello world!’<br>-&gt;’(app)hello world!’。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function log()&#123;</span><br><span class="line">      var args = Array.prototype.slice.call(arguments);  //为了使用unshift数组方法，将argument转化为真正的数组</span><br><span class="line">      args.unshift(&apos;(app)&apos;);</span><br><span class="line">      console.log.apply(console, args);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="19、对作用域上下文和this的理解，看下列代码："><a href="#19、对作用域上下文和this的理解，看下列代码：" class="headerlink" title="19、对作用域上下文和this的理解，看下列代码："></a>19、对作用域上下文和this的理解，看下列代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var User = &#123;</span><br><span class="line">  count: 1,</span><br><span class="line">  getCount: function() &#123;</span><br><span class="line">    return this.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(User.getCount());  // what?</span><br><span class="line">var func = User.getCount;</span><br><span class="line">console.log(func());  // what?</span><br></pre></td></tr></table></figure><p>问两处console输出什么？为什么？</p><p>答案是1和undefined。</p><p>func是在winodw的上下文中被执行的，所以会访问不到count属性。</p><p>继续追问，那么如何确保Uesr总是能访问到func的上下文，即正确返回1。正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = Function.prototype.bind || function(context)&#123;</span><br><span class="line">   var self = this;</span><br><span class="line">   return function()&#123;</span><br><span class="line">      return self.apply(context, arguments);</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var func = User.getCount.bind(User);</span><br><span class="line">console.log(func());</span><br></pre></td></tr></table></figure><h2 id="20、原生JS的window-onload与Jquery的-document-ready-function-有什么不同？如何用原生JS实现Jq的ready方法？"><a href="#20、原生JS的window-onload与Jquery的-document-ready-function-有什么不同？如何用原生JS实现Jq的ready方法？" class="headerlink" title="20、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？"></a>20、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？</h2><p>window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</p><p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 传递函数给whenReady()</span><br><span class="line"> * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用</span><br><span class="line"> */</span><br><span class="line">var whenReady = (function() &#123;               //这个函数返回whenReady()函数</span><br><span class="line">    var funcs = [];             //当获得事件时，要运行的函数</span><br><span class="line">    var ready = false;          //当触发事件处理程序时,切换为true</span><br><span class="line">    //当文档就绪时,调用事件处理程序</span><br><span class="line">    function handler(e) &#123;</span><br><span class="line">        if(ready) return;       //确保事件处理程序只完整运行一次</span><br><span class="line">        //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好</span><br><span class="line">        if(e.type === &apos;onreadystatechange&apos; &amp;&amp; document.readyState !== &apos;complete&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //运行所有注册函数</span><br><span class="line">        //注意每次都要计算funcs.length</span><br><span class="line">        //以防这些函数的调用可能会导致注册更多的函数</span><br><span class="line">        for(var i=0; i&lt;funcs.length; i++) &#123;</span><br><span class="line">            funcs[i].call(document);</span><br><span class="line">        &#125;</span><br><span class="line">        //事件处理函数完整执行,切换ready状态, 并移除所有函数</span><br><span class="line">        ready = true;</span><br><span class="line">        funcs = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //为接收到的任何事件注册处理程序</span><br><span class="line">    if(document.addEventListener) &#123;</span><br><span class="line">        document.addEventListener(&apos;DOMContentLoaded&apos;, handler, false);</span><br><span class="line">        document.addEventListener(&apos;readystatechange&apos;, handler, false);            //IE9+</span><br><span class="line">        window.addEventListener(&apos;load&apos;, handler, false);</span><br><span class="line">    &#125;else if(document.attachEvent) &#123;</span><br><span class="line">        document.attachEvent(&apos;onreadystatechange&apos;, handler);</span><br><span class="line">        window.attachEvent(&apos;onload&apos;, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回whenReady()函数</span><br><span class="line">    return function whenReady(fn) &#123;</span><br><span class="line">        if(ready) &#123; fn.call(document); &#125;</span><br><span class="line">        else &#123; funcs.push(fn); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">如果上述代码十分难懂，下面这个简化版：</span><br><span class="line">function ready(fn)&#123;</span><br><span class="line">    if(document.addEventListener) &#123;//标准浏览器</span><br><span class="line">        document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">            //注销事件, 避免反复触发</span><br><span class="line">            document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false);</span><br><span class="line">            fn();//执行函数</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;else if(document.attachEvent) &#123;//IE</span><br><span class="line">        document.attachEvent(&apos;onreadystatechange&apos;, function() &#123;</span><br><span class="line">            if(document.readyState == &apos;complete&apos;) &#123;</span><br><span class="line">                document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee);</span><br><span class="line">                fn();//函数执行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）"><a href="#21、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）" class="headerlink" title="21、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）"></a>21、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h2><p>回答出概念即可，下面是几个要点</p><ol><li><p>给需要拖拽的节点绑定mousedown, mousemove, mouseup事件</p></li><li><p>mousedown事件触发后，开始拖拽</p></li><li><p>mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置</p></li><li><p>mouseup时，拖拽结束</p></li><li><p>需要注意浏览器边界的情况</p></li></ol><h2 id="22、请实现如下功能"><a href="#22、请实现如下功能" class="headerlink" title="22、请实现如下功能"></a>22、请实现如下功能</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/%E9%9D%A2%E8%AF%95%E9%A2%98/nav.png" alt="题目"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function setcookie(name,value,days)&#123;  //给cookie增加一个时间变量</span><br><span class="line">　　var exp = new Date(); </span><br><span class="line">　　exp.setTime(exp.getTime() + days*24*60*60*1000); //设置过期时间为days天</span><br><span class="line">　　document.cookie = name + &quot;=&quot;+ escape (value) + &quot;;expires=&quot; + exp.toGMTString(); </span><br><span class="line">&#125; </span><br><span class="line">function getCookie(name)&#123;</span><br><span class="line">　　var result = &quot;&quot;;</span><br><span class="line">　　var myCookie = &quot;&quot;+document.cookie+&quot;;&quot;; </span><br><span class="line">　　var searchName = &quot;+name+&quot;=&quot;;</span><br><span class="line">　　var startOfCookie = myCookie.indexOf(searchName);</span><br><span class="line">　　var endOfCookie;</span><br><span class="line">　　if(satrtOfCookie != -1)&#123;</span><br><span class="line">　　　　startOfcookie += searchName.length;</span><br><span class="line">　　　　endOfCookie = myCookie.indexOf(&quot;;&quot;,startOfCookie);</span><br><span class="line">　　　　result = (myCookie.substring(startOfCookie,endOfCookie));</span><br><span class="line">　　&#125;</span><br><span class="line">　　return result;</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">　　var oTips = document.getElementById(&apos;tips&apos;);//假设tips的id为tips</span><br><span class="line">　　var page = &#123;</span><br><span class="line">　　check: function()&#123;//检查tips的cookie是否存在并且允许显示</span><br><span class="line">　　　　var tips = getCookie(&apos;tips&apos;);</span><br><span class="line">　　　　if(!tips || tips == &apos;show&apos;) return true;//tips的cookie不存在</span><br><span class="line">　　　　if(tips == &quot;never_show_again&quot;) return false;</span><br><span class="line">　　&#125;,</span><br><span class="line">　　hideTip: function(bNever)&#123;</span><br><span class="line">　　　　if(bNever) setcookie(&apos;tips&apos;, &apos;never_show_again&apos;, 365);</span><br><span class="line">　　　　oTips.style.display = &quot;none&quot;;//隐藏</span><br><span class="line">　　&#125;,</span><br><span class="line">　　showTip: function()&#123;</span><br><span class="line">　　oTips.style.display = &quot;inline&quot;;//显示，假设tips为行级元素</span><br><span class="line">　　&#125;,</span><br><span class="line">　　init: function()&#123;</span><br><span class="line">　　　　var _this = this;</span><br><span class="line">　　　　if(this.check())&#123;</span><br><span class="line">　　　　_this.showTip();</span><br><span class="line">　　　　setcookie(&apos;tips&apos;, &apos;show&apos;, 1);</span><br><span class="line">　　&#125;</span><br><span class="line">　　oTips.onclick = function()&#123;</span><br><span class="line">　　　　_this.hideTip(true);</span><br><span class="line">　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line">  page.init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="23、说出以下函数的作用是？空白区域应该填写什么？"><a href="#23、说出以下函数的作用是？空白区域应该填写什么？" class="headerlink" title="23、说出以下函数的作用是？空白区域应该填写什么？"></a>23、说出以下函数的作用是？空白区域应该填写什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//define </span><br><span class="line">(function(window)&#123;</span><br><span class="line">    function fn(str)&#123;</span><br><span class="line">        this.str=str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fn.prototype.format = function()&#123;</span><br><span class="line">        var arg = ______;</span><br><span class="line">        return this.str.replace(_____,function(a,b)&#123;</span><br><span class="line">             return arg[b]||&quot;&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    window.fn = fn;</span><br><span class="line">&#125;)(window);</span><br><span class="line"> </span><br><span class="line">//use</span><br><span class="line">(function()&#123;</span><br><span class="line">    var t = new fn(&apos;&lt;p&gt;&lt;a href=&quot;&#123;0&#125;&quot;&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;&apos;);</span><br><span class="line">    console.log(t.format(&apos;http://www.alibaba.com&apos;,&apos;Alibaba&apos;,&apos;Welcome&apos;));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>答案：访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果：</p><p>第一个空是：arguments</p><p>第二个空是：/\{(\d+)\}/ig</p><h2 id="Javascript作用域链"><a href="#Javascript作用域链" class="headerlink" title="Javascript作用域链?"></a>Javascript作用域链?</h2><p>理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。</p><h2 id="谈谈this对象的理解。"><a href="#谈谈this对象的理解。" class="headerlink" title="谈谈this对象的理解。"></a>谈谈this对象的理解。</h2><p>理解不同形式的函数调用方式下的this指向，理解事件函数、定时函数中的this指向，函数的调用形式决定了this的指向。</p><h2 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h2><p>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2个步骤，一次解析成js语句，一次执行）</p><h2 id="关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h2><p>[1].在IE中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,不管是用户触发的，还是其他事件,都会更新window.event对象.所以在代码中，只要调用window.event就可以获取事件对象，<br>再event.srcElement就可以取得触发事件的元素进行进一步处理.</p><p>[2].在FireFox中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，FireFox把事件对象自动传给事件处理程序.</p><p>关于事件的兼容性处理要熟练掌握，事件对象具体哪些属性存在兼容性问题，IE与标准事件模型事件冒泡与事件捕获的支持要理解</p><h2 id="什么是闭包（closure），为什么要用它？"><a href="#什么是闭包（closure），为什么要用它？" class="headerlink" title="什么是闭包（closure），为什么要用它？"></a>什么是闭包（closure），为什么要用它？</h2><p>简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域</p><p>使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值</p><h2 id="29、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#29、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="29、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>29、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h2><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p><p>严格模式</p><p>链接：<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a></p><p><strong>全局变量显式声明</strong></p><p><strong>静态绑定</strong></p><p><strong>禁止使用with语句</strong></p><p><strong>eval中定义的变量都是局部变量</strong></p><p><strong>禁止this关键字指向全局对象</strong></p><p><strong>禁止在函数内部遍历调用栈</strong></p><p>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除</p><p>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。</p><p>严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。</p><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><p>严格模式下，删除一个不可删除的属性，会报错。</p><p>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p><p>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</p><p>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p><p><strong>不允许对arguments赋值</strong></p><p><strong>arguments不再追踪参数的变化</strong></p><p><strong>禁止使用arguments.callee</strong></p><p>严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数</p><p>严格模式新增了一些保留字：implements, interface, let, package, private,<br>protected, public, static, yield。</p><h2 id="30、如何判断一个对象是否属于某个类-严格来说在ES6之前，js没有类的概念-？"><a href="#30、如何判断一个对象是否属于某个类-严格来说在ES6之前，js没有类的概念-？" class="headerlink" title="30、如何判断一个对象是否属于某个类(严格来说在ES6之前，js没有类的概念)？"></a>30、如何判断一个对象是否属于某个类(严格来说在ES6之前，js没有类的概念)？</h2><p>instanceof constructor</p><h2 id="31、new操作符具体干了什么呢"><a href="#31、new操作符具体干了什么呢" class="headerlink" title="31、new操作符具体干了什么呢?"></a>31、new操作符具体干了什么呢?</h2><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p><p>2、属性和方法被加入到 this 引用的对象中。</p><p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p><h2 id="32、用原生JavaScript的实现过什么功能吗？"><a href="#32、用原生JavaScript的实现过什么功能吗？" class="headerlink" title="32、用原生JavaScript的实现过什么功能吗？"></a>32、用原生JavaScript的实现过什么功能吗？</h2><p>主要考察原生js的实践经验</p><h2 id="33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h2><p>HasOwnProperty</p><h2 id="34、对JSON的了解？"><a href="#34、对JSON的了解？" class="headerlink" title="34、对JSON的了解？"></a>34、对JSON的了解？</h2><p>轻量级数据交互格式，可以形成复杂的嵌套格式，解析非常方便</p><h2 id="35、js延迟加载的方式有哪些？"><a href="#35、js延迟加载的方式有哪些？" class="headerlink" title="35、js延迟加载的方式有哪些？"></a>35、js延迟加载的方式有哪些？</h2><p>方案一：&lt;script&gt;标签的async=”async”属性（详细参见：script标签的async属性）</p><p>方案二：&lt;script&gt;标签的defer=”defer”属性</p><p>方案三：动态创建&lt;script&gt;标签</p><p>方案四：AJAX<br>eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）</p><p>方案五：iframe方式</p><h2 id="36、模块化开发怎么做？"><a href="#36、模块化开发怎么做？" class="headerlink" title="36、模块化开发怎么做？"></a>36、模块化开发怎么做？</h2><p>理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用</p><h2 id="37、AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#37、AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="37、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>37、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h2><p>理解这两种规范的差异，主要通过requirejs与seajs的对比，理解模块的定义与引用方式</p><p>的差异以及这两种规范的设计原则</p><p>参考链接1：<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">https://www.zhihu.com/question/20351507/answer/14859415</a></p><p>参考链接2：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p><p>1、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0<br>开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as<br>possible.</p><p>2、AMD 推崇依赖前置，CMD 推崇依赖就近。</p><ol start="3"><li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD<br>里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局<br>require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD<br>里，每个 API 都简单纯粹。</li></ol><h2 id="38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h2><p>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存</p><h2 id="39、让你自己设计实现一个requireJS，你会怎么做？"><a href="#39、让你自己设计实现一个requireJS，你会怎么做？" class="headerlink" title="39、让你自己设计实现一个requireJS，你会怎么做？"></a>39、让你自己设计实现一个requireJS，你会怎么做？</h2><p>核心是实现js的加载模块，维护js的依赖关系，控制好文件加载的先后顺序</p><h2 id="40、谈一谈你对ECMAScript6的了解？"><a href="#40、谈一谈你对ECMAScript6的了解？" class="headerlink" title="40、谈一谈你对ECMAScript6的了解？"></a>40、谈一谈你对ECMAScript6的了解？</h2><p>ES6新的语法糖，类，模块化等新特性</p><p>关于ES6参考链接：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p><ol><li><p><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener">ECMAScript 6简介</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let和const命令</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">变量的解构赋值</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">字符串的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="noopener">正则的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="noopener">数值的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">数组的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">函数的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="noopener">对象的扩展</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">Symbol</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy和Reflect</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="noopener">二进制数组</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">Set和Map数据结构</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Iterator和for…of循环</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator函数</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise对象</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">异步操作和Async函数</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">Decorator</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module</a></p></li></ol><h2 id="41、ECMAScript6-怎么写class么，为什么会出现class这种东西"><a href="#41、ECMAScript6-怎么写class么，为什么会出现class这种东西" class="headerlink" title="41、ECMAScript6 怎么写class么，为什么会出现class这种东西?"></a>41、ECMAScript6 怎么写class么，为什么会出现class这种东西?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">     return &apos;(&apos;+this.x+&apos;, &apos;+this.y+&apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42、异步加载的方式有哪些？"><a href="#42、异步加载的方式有哪些？" class="headerlink" title="42、异步加载的方式有哪些？"></a>42、异步加载的方式有哪些？</h2><p>方案一：&lt;script&gt;标签的async=”async”属性（详细参见：script标签的async属性）</p><p>方案二：&lt;script&gt;标签的defer=”defer”属性</p><p>方案三：动态创建&lt;script&gt;标签</p><p>方案四：AJAX<br>eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）</p><p>方案五：iframe方式</p><h2 id="43、documen-write和-innerHTML的区别"><a href="#43、documen-write和-innerHTML的区别" class="headerlink" title="43、documen.write和 innerHTML的区别?"></a>43、documen.write和 innerHTML的区别?</h2><p>document.write是重写整个document, 写入内容是字符串的html</p><p>innerHTML是HTMLElement的属性，是一个元素的内部html内容</p><h2 id="44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</h2><p>（1）创建新节点</p><p>createDocumentFragment() //创建一个DOM片段</p><p>createElement_x() //创建一个具体的元素</p><p>createTextNode() //创建一个文本节点</p><p>（2）添加、移除、替换、插入</p><p>appendChild()</p><p>removeChild()</p><p>replaceChild()</p><p>insertBefore()</p><p>（3）查找</p><p>getElementsByTagName() //通过标签名称</p><p>getElementsByName() //通过元素的Name属性的值</p><p>getElementById() //通过元素Id，唯一性</p><h2 id="45、call-和-apply-的含义和区别？"><a href="#45、call-和-apply-的含义和区别？" class="headerlink" title="45、call() 和 apply() 的含义和区别？"></a>45、call() 和 apply() 的含义和区别？</h2><p>apply的参数是数组形式，call的参数是单个的值，除此之外在使用上没有差别，重点理解这两个函数调用的this改变</p><h2 id="46、数组和对象有哪些原生方法，列举一下？"><a href="#46、数组和对象有哪些原生方法，列举一下？" class="headerlink" title="46、数组和对象有哪些原生方法，列举一下？"></a>46、数组和对象有哪些原生方法，列举一下？</h2><p>Array.concat( ) 连接数组</p><p>Array.join( ) 将数组元素连接起来以构建一个字符串</p><p>Array.length 数组的大小</p><p>Array.pop( ) 删除并返回数组的最后一个元素</p><p>Array.push( ) 给数组添加元素</p><p>Array.reverse( ) 颠倒数组中元素的顺序</p><p>Array.shift( ) 将元素移出数组</p><p>Array.slice( ) 返回数组的一部分</p><p>Array.sort( ) 对数组元素进行排序</p><p>Array.splice( ) 插入、删除或替换数组的元素</p><p>Array.toLocaleString( ) 把数组转换成局部字符串</p><p>Array.toString( ) 将数组转换成一个字符串</p><p>Array.unshift( ) 在数组头部插入一个元素</p><p>Object对象的常用方法</p><p>Object.hasOwnProperty( ) 检查属性是否被继承</p><p>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</p><p>Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性</p><p>Object.toLocaleString( ) 返回对象的本地字符串表示</p><p>Object.toString( ) 定义一个对象的字符串表示</p><p>Object.valueOf( ) 指定对象的原始值</p><h2 id="47、JS-怎么实现一个类。怎么实例化这个类"><a href="#47、JS-怎么实现一个类。怎么实例化这个类" class="headerlink" title="47、JS 怎么实现一个类。怎么实例化这个类"></a>47、JS 怎么实现一个类。怎么实例化这个类</h2><p>严格来讲js中并没有类的概念，不过js中的函数可以作为构造函数来使用，通过new来实例化，其实函数本身也是一个对象。</p><h2 id="48、JavaScript中的作用域与变量声明提升？"><a href="#48、JavaScript中的作用域与变量声明提升？" class="headerlink" title="48、JavaScript中的作用域与变量声明提升？"></a>48、JavaScript中的作用域与变量声明提升？</h2><p>理解JavaScript的预解析机制，js的运行主要分两个阶段：js的预解析和运行，预解析阶段所有的变量声明和函数定义都会提前，但是变量的赋值不会提前</p><h2 id="49、如何编写高性能的Javascript？"><a href="#49、如何编写高性能的Javascript？" class="headerlink" title="49、如何编写高性能的Javascript？"></a>49、如何编写高性能的Javascript？</h2><p>使用 DocumentFragment 优化多次 append</p><p>通过模板元素 clone ，替代 createElement</p><p>使用一次 innerHTML 赋值代替构建 dom 元素</p><p>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</p><p>使用 Array 做为 StringBuffer ，代替字符串拼接的操作</p><p>将循环控制量保存到局部变量</p><p>顺序无关的遍历时，用 while 替代 for</p><p>将条件分支，按可能性顺序从高到低排列</p><p>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</p><p>使用三目运算符替代条件分支</p><p>需要不断执行的时候，优先考虑使用 setInterval</p><h2 id="50、那些操作会造成内存泄漏？"><a href="#50、那些操作会造成内存泄漏？" class="headerlink" title="50、那些操作会造成内存泄漏？"></a>50、那些操作会造成内存泄漏？</h2><p>闭包，死循环</p><h2 id="51、javascript对象的几种创建方式？"><a href="#51、javascript对象的几种创建方式？" class="headerlink" title="51、javascript对象的几种创建方式？"></a>51、javascript对象的几种创建方式？</h2><ol><li><p>工厂模式</p></li><li><p>构造函数模式</p></li><li><p>原型模式</p></li><li><p>混合构造函数和原型模式</p></li><li><p>动态原型模式</p></li><li><p>寄生构造函数模式</p></li><li><p>稳妥构造函数模式</p></li></ol><h2 id="52、javascript继承的-6-种方法？"><a href="#52、javascript继承的-6-种方法？" class="headerlink" title="52、javascript继承的 6 种方法？"></a>52、javascript继承的 6 种方法？</h2><ol><li><p>原型链继承</p></li><li><p>借用构造函数继承</p></li><li><p>组合继承(原型+借用构造)</p></li><li><p>原型式继承</p></li><li><p>寄生式继承</p></li><li><p>寄生组合式继承</p></li></ol><h2 id="53、eval是做什么的？"><a href="#53、eval是做什么的？" class="headerlink" title="53、eval是做什么的？"></a>53、eval是做什么的？</h2><ol><li><p>它的功能是把对应的字符串解析成JS代码并运行</p></li><li><p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p></li></ol><h2 id="54、JavaScript-原型，原型链-有什么特点？"><a href="#54、JavaScript-原型，原型链-有什么特点？" class="headerlink" title="54、JavaScript 原型，原型链 ? 有什么特点？"></a>54、JavaScript 原型，原型链 ? 有什么特点？</h2><ol><li><p>原型对象也是普通的对象，是对象一个自带隐式的 _<em>proto_\</em><br>属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null<br>的话，我们就称之为原型链</p></li><li><p>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链</p></li></ol><h2 id="55、事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#55、事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="55、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>55、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h2><p>1.我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被<br>JavaScript 侦测到的行为</p><p>2.事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</p><p>3.ev.stopPropagation();</p><p>注意旧ie的方法：ev.cancelBubble = true;</p><h2 id="56、简述一下Sass、Less，且说明区别？"><a href="#56、简述一下Sass、Less，且说明区别？" class="headerlink" title="56、简述一下Sass、Less，且说明区别？"></a>56、简述一下Sass、Less，且说明区别？</h2><p>他们是动态的样式语言，是CSS预处理器,CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。</p><p>变量符不一样，less是@，而Sass是$;</p><p>Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持;</p><p>Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器</p><h2 id="57、关于javascript中apply-和call-方法的区别？"><a href="#57、关于javascript中apply-和call-方法的区别？" class="headerlink" title="57、关于javascript中apply()和call()方法的区别？"></a>57、关于javascript中apply()和call()方法的区别？</h2><p>相同点:两个方法产生的作用是完全一样的</p><p>不同点:方法传递的参数不同</p><p>Object.call(this,obj1,obj2,obj3)</p><p>Object.apply(this,arguments)</p><p>apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。</p><p>call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。</p><h2 id="58、简述一下JS中的闭包？"><a href="#58、简述一下JS中的闭包？" class="headerlink" title="58、简述一下JS中的闭包？"></a>58、简述一下JS中的闭包？</h2><p>闭包用的多的两个作用：读取函数内部的变量值；让这些变量值始终保存着(在内存中)。</p><p>同时需要注意的是：闭包慎用，不滥用，不乱用，由于函数内部的变量都被保存在内存中，会导致内存消耗大。</p><h2 id="59、说说你对this的理解？"><a href="#59、说说你对this的理解？" class="headerlink" title="59、说说你对this的理解？"></a>59、说说你对this的理解？</h2><p>在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。</p><p>全局的this → 指向的是Window</p><p>函数中的this → 指向的是函数所在的对象 错误答案</p><p>对象中的this → 指向其本身</p><p>事件中this → 指向事件对象</p><h2 id="60、分别阐述split-slice-splice-join-？"><a href="#60、分别阐述split-slice-splice-join-？" class="headerlink" title="60、分别阐述split(),slice(),splice(),join()？"></a>60、分别阐述split(),slice(),splice(),join()？</h2><p>join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于Array</p><p>split()即把字符串分离开，以数组方式存储。归属于Stringstring</p><p>slice()<br>方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法<br>Array.splice()</p><p>splice()<br>方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。</p><h2 id="61、事件委托是什么？"><a href="#61、事件委托是什么？" class="headerlink" title="61、事件委托是什么？"></a>61、事件委托是什么？</h2><p>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p><h2 id="62、如何阻止事件冒泡和默认事件？"><a href="#62、如何阻止事件冒泡和默认事件？" class="headerlink" title="62、如何阻止事件冒泡和默认事件？"></a>62、如何阻止事件冒泡和默认事件？</h2><p>阻止浏览器的默认行为</p><p>window.event?window.event.returnValue=false:e.preventDefault();</p><p>停止事件冒泡</p><p>window.event?window.event.cancelBubble=true:e.stopPropagation();</p><p>原生JavaScript中，return false;只阻止默认行为，不阻止冒泡，jQuery中的return<br>false;既阻止默认行为，又阻止冒泡</p><h2 id="63、添加-删除-替换-插入到某个接点的方法？"><a href="#63、添加-删除-替换-插入到某个接点的方法？" class="headerlink" title="63、添加 删除 替换 插入到某个接点的方法？"></a>63、添加 删除 替换 插入到某个接点的方法？</h2><p>obj.appendChidl()</p><p>obj.removeChild()</p><p>obj.replaceChild()</p><p>obj.innersetBefore()</p><h2 id="64、你用过require-js吗？它有什么特性？"><a href="#64、你用过require-js吗？它有什么特性？" class="headerlink" title="64、你用过require.js吗？它有什么特性？"></a>64、你用过require.js吗？它有什么特性？</h2><p>（1）实现js文件的异步加载，避免网页失去响应；</p><p>（2）管理模块之间的依赖性，便于代码的编写和维护。</p><h2 id="65、谈一下JS中的递归函数，并且用递归简单实现阶乘？"><a href="#65、谈一下JS中的递归函数，并且用递归简单实现阶乘？" class="headerlink" title="65、谈一下JS中的递归函数，并且用递归简单实现阶乘？"></a>65、谈一下JS中的递归函数，并且用递归简单实现阶乘？</h2><p>递归即是程序在执行过程中不断调用自身的编程技巧，当然也必须要有一个明确的结束条件，不然就会陷入死循环。</p><h2 id="66、请用正则表达式写一个简单的邮箱验证。"><a href="#66、请用正则表达式写一个简单的邮箱验证。" class="headerlink" title="66、请用正则表达式写一个简单的邮箱验证。"></a>66、请用正则表达式写一个简单的邮箱验证。</h2><p>/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;</p><h2 id="67、简述一下你对web性能优化的方案？"><a href="#67、简述一下你对web性能优化的方案？" class="headerlink" title="67、简述一下你对web性能优化的方案？"></a>67、简述一下你对web性能优化的方案？</h2><p>1、尽量减少 HTTP 请求<br>2、使用浏览器缓存<br>3、使用压缩组件<br>4、图片、JS的预载入<br>5、将脚本放在底部<br>6、将样式文件放在页面顶部<br>7、使用外部的JS和CSS<br>8、精简代码</p><h2 id="68、在JS中有哪些会被隐式转换为false"><a href="#68、在JS中有哪些会被隐式转换为false" class="headerlink" title="68、在JS中有哪些会被隐式转换为false"></a>68、在JS中有哪些会被隐式转换为false</h2><p>Undefined、null、布尔值false、NaN、零、空字符串</p><h2 id="69、定时器setInterval有一个有名函数fn1，setInterval（fn1-500）与setInterval（fn1-500）有什么区别？"><a href="#69、定时器setInterval有一个有名函数fn1，setInterval（fn1-500）与setInterval（fn1-500）有什么区别？" class="headerlink" title="69、定时器setInterval有一个有名函数fn1，setInterval（fn1,500）与setInterval（fn1(),500）有什么区别？"></a>69、定时器setInterval有一个有名函数fn1，setInterval（fn1,500）与setInterval（fn1(),500）有什么区别？</h2><p>第一个是重复执行每500毫秒执行一次，后面一个只执行一次。</p><h2 id="70、外部JS文件出现中文字符，会出现什么问题，怎么解决？"><a href="#70、外部JS文件出现中文字符，会出现什么问题，怎么解决？" class="headerlink" title="70、外部JS文件出现中文字符，会出现什么问题，怎么解决？"></a>70、外部JS文件出现中文字符，会出现什么问题，怎么解决？</h2><p>会出现乱码，加charset=”GB2312”;</p><p>另一种解决方式：网页文件和外部JS文件都是UTF8编码</p><h2 id="71、谈谈浏览器的内核，并且说一下什么是内核？"><a href="#71、谈谈浏览器的内核，并且说一下什么是内核？" class="headerlink" title="71、谈谈浏览器的内核，并且说一下什么是内核？"></a>71、谈谈浏览器的内核，并且说一下什么是内核？</h2><p>Trident ([‘traɪd(ə)nt])–IE<br>Gecko ([‘gekəʊ])–Firefox,<br>Presto([‘prestəʊ])–opera<br>webkit—谷歌和Safari</p><p>浏览器内核又可以分成两部分：渲染引擎和 JS<br>引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS<br>等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析<br>Javascript 语言，执行 javascript 语言来实现网页的动态效果。</p><h2 id="72、JavaScript原型，原型链-有什么特点？"><a href="#72、JavaScript原型，原型链-有什么特点？" class="headerlink" title="72、JavaScript原型，原型链 ? 有什么特点？"></a>72、JavaScript原型，原型链 ? 有什么特点？</h2><p>* 原型对象也是普通的对象，是对象一个自带隐式的 _<em>proto_\</em><br>属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。</p><p>* 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</p><p>* JavaScript的数据对象有那些属性值？</p><p>　　writable：这个属性的值是否可以改。</p><p>　　configurable：这个属性的配置是否可以删除，修改。</p><p>　　enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。</p><p>　　value：属性值。</p><p>* 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，<br>如果没有的话，就会查找他的Prototype对象是否有这个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function clone(proto) &#123;</span><br><span class="line"></span><br><span class="line">　　function Dummy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">　　Dummy.prototype = proto;</span><br><span class="line"></span><br><span class="line">　　Dummy.prototype.constructor = Dummy;</span><br><span class="line"></span><br><span class="line">　　return new Dummy(); //等价于Object.create(Person);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function object(old) &#123;</span><br><span class="line"></span><br><span class="line">function F() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype = old;</span><br><span class="line"></span><br><span class="line">return new F();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newObj = object(oldObject);</span><br></pre></td></tr></table></figure><h2 id="73、写一个通用的事件侦听器函数"><a href="#73、写一个通用的事件侦听器函数" class="headerlink" title="73、写一个通用的事件侦听器函数"></a>73、写一个通用的事件侦听器函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// event(事件)工具集，来源：https://github.com/markyun</span><br><span class="line">markyun.Event = &#123;</span><br><span class="line">    // 页面加载完成后</span><br><span class="line">    readyEvent : function(fn) &#123;</span><br><span class="line">        if (fn==null) &#123;</span><br><span class="line">            fn=document;</span><br><span class="line">        &#125;</span><br><span class="line">        var oldonload = window.onload;</span><br><span class="line">        if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class="line">            window.onload = fn;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                oldonload();</span><br><span class="line">                fn();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">    // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class="line">    addEvent : function(element, type, handler) &#123;</span><br><span class="line">        if (element.addEventListener) &#123;</span><br><span class="line">            //事件类型、需要执行的函数、是否捕捉</span><br><span class="line">            element.addEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(&apos;on&apos; + type, function() &#123;</span><br><span class="line">                handler.call(element);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            element[&apos;on&apos; + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 移除事件</span><br><span class="line">    removeEvent : function(element, type, handler) &#123;</span><br><span class="line">        if (element.removeEnentListener) &#123;</span><br><span class="line">            element.removeEnentListener(type, handler, false);</span><br><span class="line">        &#125; else if (element.datachEvent) &#123;</span><br><span class="line">            element.detachEvent(&apos;on&apos; + type, handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            element[&apos;on&apos; + type] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class="line">    stopPropagation : function(ev) &#123;</span><br><span class="line">        if (ev.stopPropagation) &#123;</span><br><span class="line">            ev.stopPropagation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ev.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 取消事件的默认行为</span><br><span class="line">    preventDefault : function(event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取事件目标</span><br><span class="line">    getTarget : function(event) &#123;</span><br><span class="line">        return event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class="line">    getEvent : function(e) &#123;</span><br><span class="line">        var ev = e || window.event;</span><br><span class="line">        if (!ev) &#123;</span><br><span class="line">            var c = this.getEvent.caller;</span><br><span class="line">            while (c) &#123;</span><br><span class="line">                ev = c.arguments[0];</span><br><span class="line">                if (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                c = c.caller;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="74、事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#74、事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="74、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>74、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h2><p>1.我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被<br>JavaScript 侦测到的行为。</p><p>2.事件处理机制：IE是事件冒泡、火狐支持 捕获和冒泡两种；</p><p>3.ev.stopPropagation();</p><h2 id="75、什么是闭包（closure），为什么要用？"><a href="#75、什么是闭包（closure），为什么要用？" class="headerlink" title="75、什么是闭包（closure），为什么要用？"></a>75、什么是闭包（closure），为什么要用？</h2><p>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在.使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，因为say667()的内部函数的执行需要依赖say667()中的变量。这是对闭包作用的非常直白的描述.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function say667() &#123;</span><br><span class="line"></span><br><span class="line">// Local variable that ends up within closure</span><br><span class="line"></span><br><span class="line">var num = 666;</span><br><span class="line"></span><br><span class="line">var sayAlert = function() &#123; alert(num); &#125;</span><br><span class="line"></span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line">return sayAlert;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sayAlert = say667();</span><br><span class="line"></span><br><span class="line">sayAlert()//执行结果应该弹出的667</span><br></pre></td></tr></table></figure><h2 id="76、如何判断一个对象是否属于某个类？"><a href="#76、如何判断一个对象是否属于某个类？" class="headerlink" title="76、如何判断一个对象是否属于某个类？"></a>76、如何判断一个对象是否属于某个类？</h2><p>使用instanceof （待完善）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(a instanceof Person)&#123;</span><br><span class="line"></span><br><span class="line">alert(&apos;yes&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77、new操作符具体干了什么呢"><a href="#77、new操作符具体干了什么呢" class="headerlink" title="77、new操作符具体干了什么呢?"></a>77、new操作符具体干了什么呢?</h2><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p><p>2、属性和方法被加入到 this 引用的对象中。</p><p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.__proto_\_ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h2 id="78、JSON-的了解"><a href="#78、JSON-的了解" class="headerlink" title="78、JSON 的了解"></a>78、JSON 的了解</h2><p>JSON(JavaScript Object Notation)<br>是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,<br>易于读写, 占用带宽小</p><p>{‘age’:’12’, ‘name’:’back’}</p><h2 id="79、js延迟加载的方式有哪些"><a href="#79、js延迟加载的方式有哪些" class="headerlink" title="79、js延迟加载的方式有哪些"></a>79、js延迟加载的方式有哪些</h2><p>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p><h2 id="80、模块化怎么做？"><a href="#80、模块化怎么做？" class="headerlink" title="80、模块化怎么做？"></a>80、模块化怎么做？</h2><p>立即执行函数,不暴露私有成员</p><p>使用字面量实现命名空间(YUI)：</p><p>Itcast.common.dom={};<br>Itcast.common.css={};<br>Itcast.common.event={};</p><p>2、使用闭包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (function()&#123;</span><br><span class="line">　　　　var \_count = 0;</span><br><span class="line">　　　　var m1 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　var m2 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　m1 : m1,</span><br><span class="line">　　　　　　m2 : m2</span><br><span class="line">　　　　&#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="81、异步加载的方式"><a href="#81、异步加载的方式" class="headerlink" title="81、异步加载的方式"></a>81、异步加载的方式</h2><p>(1) defer，只支持IE</p><p>(2) async：</p><p>(3) 创建script，插入到DOM中，加载完毕后callBack</p><p>documen.write和 innerHTML的区别</p><p>document.write只能重绘整个页面</p><p>innerHTML可以重绘页面的一部分</p><h2 id="82、告诉我答案是多少？"><a href="#82、告诉我答案是多少？" class="headerlink" title="82、告诉我答案是多少？"></a>82、告诉我答案是多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function(x)&#123;</span><br><span class="line">delete x;</span><br><span class="line">alert(x);</span><br><span class="line">&#125;)(1+5);</span><br></pre></td></tr></table></figure><p>函数参数无法delete删除，delete只能删除通过for in访问的属性。</p><p>当然，删除失败也不会报错，所以代码运行会弹出“1”。</p><h2 id="83、JS中的call-和apply-方法的区别？"><a href="#83、JS中的call-和apply-方法的区别？" class="headerlink" title="83、JS中的call()和apply()方法的区别？"></a>83、JS中的call()和apply()方法的区别？</h2><p>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1)<br>，所以运行结果为：alert(4);</p><p>注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line">function sub(a,b)&#123;</span><br><span class="line">alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line">add.call(sub,3,1);</span><br></pre></td></tr></table></figure><h2 id="84、Jquery与jQuery-UI-有啥区别？"><a href="#84、Jquery与jQuery-UI-有啥区别？" class="headerlink" title="84、Jquery与jQuery UI 有啥区别？"></a>84、Jquery与jQuery UI 有啥区别？</h2><p>*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</p><p>*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。</p><p>提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</p><h2 id="85、jquery-中如何将数组转化为json字符串，然后再转化回来？"><a href="#85、jquery-中如何将数组转化为json字符串，然后再转化回来？" class="headerlink" title="85、jquery 中如何将数组转化为json字符串，然后再转化回来？"></a>85、jquery 中如何将数组转化为json字符串，然后再转化回来？</h2><p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.fn.stringifyArray = function(array) &#123;</span><br><span class="line">return JSON.stringify(array)</span><br><span class="line">&#125;</span><br><span class="line">$.fn.parseArray = function(array) &#123;</span><br><span class="line">return JSON.parse(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用：</p><p>$(“”).stringifyArray(array)</p><h2 id="86、JavaScript中的作用域与变量声明提升？"><a href="#86、JavaScript中的作用域与变量声明提升？" class="headerlink" title="86、JavaScript中的作用域与变量声明提升？"></a>86、JavaScript中的作用域与变量声明提升？</h2><p>其他部分</p><p>（HTTP、正则、优化、重构、响应式、移动端、团队协作、SEO、UED、职业生涯）</p><p>*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</p><p>*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。</p><p>比如：var str=$(“a”).attr(“href”);</p><p>*for (var i = size; i &lt; arr.length; i++) {}</p><p>for 循环每一次循环都查找了数组 (arr) 的.length<br>属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</p><p>for (var i = size, length = arr.length; i &lt; length; i++) {}</p><h2 id="87、前端开发的优化问题（看雅虎14条性能优化原则）。"><a href="#87、前端开发的优化问题（看雅虎14条性能优化原则）。" class="headerlink" title="87、前端开发的优化问题（看雅虎14条性能优化原则）。"></a>87、前端开发的优化问题（看雅虎14条性能优化原则）。</h2><p>参考资料：J:\代码,PPT,笔记,电子书\面试题\雅虎14条优化规则.docx</p><p>（1） 减少http请求次数：CSS Sprites,<br>JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p><p>（2） 前端模板<br>JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p><p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p><p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p><p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p><p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p><p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</p><p>（8）<br>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</p><h2 id="88、http状态码有那些？分别代表是什么意思？"><a href="#88、http状态码有那些？分别代表是什么意思？" class="headerlink" title="88、http状态码有那些？分别代表是什么意思？"></a>88、http状态码有那些？分别代表是什么意思？</h2><p>100-199 用于指定客户端应相应的某些动作。</p><p>200-299 用于表示请求成功。</p><p>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</p><p>400-499 用于指出客户端的错误。</p><p>400 语义有误，当前请求无法被服务器理解。</p><p>401 当前请求需要用户验证</p><p>403 服务器已经理解请求，但是拒绝执行它。</p><p>500-599 用于支持服务器错误。</p><p>503 – 服务不可用</p><h2 id="89、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#89、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="89、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>89、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><p>要熟悉前后端的通信流程，最好把动态网站的背后细节也介绍一遍</p><hr><h1 id="框架部分"><a href="#框架部分" class="headerlink" title="框架部分"></a>框架部分</h1><h2 id="1、JQuery的源码看过吗？能不能简单概况一下它的实现原理？"><a href="#1、JQuery的源码看过吗？能不能简单概况一下它的实现原理？" class="headerlink" title="1、JQuery的源码看过吗？能不能简单概况一下它的实现原理？"></a>1、JQuery的源码看过吗？能不能简单概况一下它的实现原理？</h2><p>考察学习知识的态度，是否仅仅是停留在使用层面，要知其然知其所以然</p><h2 id="2、jQuery-fn的init方法返回的this指的是什么对象？为什么要返回this？"><a href="#2、jQuery-fn的init方法返回的this指的是什么对象？为什么要返回this？" class="headerlink" title="2、jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？"></a>2、jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</h2><p>this执行init构造函数自身，其实就是jQuery实例对象，返回this是为了实现jQuery的链式操作</p><h2 id="3-jquery中如何将数组转化为json字符串，然后再转化回来？"><a href="#3-jquery中如何将数组转化为json字符串，然后再转化回来？" class="headerlink" title="3.jquery中如何将数组转化为json字符串，然后再转化回来？"></a>3.jquery中如何将数组转化为json字符串，然后再转化回来？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.parseJSON(&apos;&#123;&quot;name&quot;:&quot;John&quot;&#125;&apos;);</span><br><span class="line">JSON.stringify</span><br></pre></td></tr></table></figure><h2 id="4-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#4-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="4.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>4.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h2><p>递归赋值</p><h2 id="5-jquery-extend-与-jquery-fn-extend的区别？"><a href="#5-jquery-extend-与-jquery-fn-extend的区别？" class="headerlink" title="5.jquery.extend 与 jquery.fn.extend的区别？"></a>5.<code>jquery.extend</code> 与 <code>jquery.fn.extend</code>的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jquery.extend用来扩展jQuery对象本身；jquery.fn.extend用来扩展jQuery实例</span><br></pre></td></tr></table></figure><h2 id="6、谈一下Jquery中的bind-live-delegate-on-的区别？"><a href="#6、谈一下Jquery中的bind-live-delegate-on-的区别？" class="headerlink" title="6、谈一下Jquery中的bind(),live(),delegate(),on()的区别？"></a>6、谈一下<code>Jquery中的bind(),live(),delegate(),on()</code>的区别？</h2><p>jquery1.7以后就推荐使用on的方式来进行事件绑定了</p><h2 id="7、JQuery一个对象可以同时绑定多个事件，这是如何实现的？"><a href="#7、JQuery一个对象可以同时绑定多个事件，这是如何实现的？" class="headerlink" title="7、JQuery一个对象可以同时绑定多个事件，这是如何实现的？"></a>7、JQuery一个对象可以同时绑定多个事件，这是如何实现的？</h2><p>可以同时绑定多个事件，低层实现原理是使用addEventListner与attachEvent兼容处理做事件注册</p><h2 id="8-Jquery与jQuery-UI有啥区别？"><a href="#8-Jquery与jQuery-UI有啥区别？" class="headerlink" title="8.Jquery与jQuery UI有啥区别？"></a>8.Jquery与jQuery UI有啥区别？</h2><p>jQuery是操作dom的框架，jQueryUI是基于jQuery做的一个UI组件库</p><h2 id="9-jQuery和Zepto的区别？各自的使用场景？"><a href="#9-jQuery和Zepto的区别？各自的使用场景？" class="headerlink" title="9.jQuery和Zepto的区别？各自的使用场景？"></a>9.jQuery和Zepto的区别？各自的使用场景？</h2><p>jQuery主要用于pc端，当然有对应的jQuerymobile用于移动端，zepto比jQuery更加小巧，主要用于移动端</p><p>jquery mobile相对于zepto功能强大，但是体积也很庞大，zepto非常的轻量</p><h2 id="10、针对-jQuery-的优化方法？"><a href="#10、针对-jQuery-的优化方法？" class="headerlink" title="10、针对 jQuery 的优化方法？"></a>10、针对 jQuery 的优化方法？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a、优先使用ID选择器</span><br><span class="line"></span><br><span class="line">b、jquery获取到的DOM元素如果需要多次使用，建议使用一个变量将其保存起来，因为操作DOM的过程是非常耗费性能的</span><br><span class="line"></span><br><span class="line">c、在class前使用tag(标签名)</span><br><span class="line"></span><br><span class="line">d、给选择器一个上下文</span><br><span class="line"></span><br><span class="line">e、慎用 .live()方法（应该说尽量不要使用）</span><br><span class="line"></span><br><span class="line">f、使用data()方法存储临时变量</span><br></pre></td></tr></table></figure><h2 id="11、Zepto的点透问题如何解决？"><a href="#11、Zepto的点透问题如何解决？" class="headerlink" title="11、Zepto的点透问题如何解决？"></a>11、Zepto的点透问题如何解决？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">点透主要是由于两个div重合，例如：一个div调用show()，一个div调用hide()；这个时候当点击上面的div的时候就会影响到下面的那个div；</span><br><span class="line"></span><br><span class="line">解决办法主要有2种：</span><br><span class="line"></span><br><span class="line">1.github上有一个叫做fastclick的库，它也能规避移动设备上click事件的延迟响应，https://github.com/ftlabs/fastclick</span><br><span class="line"></span><br><span class="line">将它用script标签引入页面（该库支持AMD，于是你也可以按照AMD规范，用诸如require.js的模块加载器引入），并且在dom</span><br><span class="line">ready时初始化在body上，</span><br><span class="line"></span><br><span class="line">2.根据分析，如果不引入其它类库，也不想自己按照上述fastclcik的思路再开发一套东西，需要1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对click事件的捕获，在ios的safari，click的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被event.preventDefault()阻止的行为）。</span><br></pre></td></tr></table></figure><h2 id="12、知道各种JS框架-Angular-Backbone-Ember-React-Meteor-Knockout…-么-能讲出他们各自的优点和缺点么"><a href="#12、知道各种JS框架-Angular-Backbone-Ember-React-Meteor-Knockout…-么-能讲出他们各自的优点和缺点么" class="headerlink" title="12、知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?"></a>12、知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</h2><p>知识面的宽度，流行框架要多多熟悉</p><p>angular、backbone、knockout都是完整的MV框架</p><p>angular是双向数据绑定的，backbone、knockout是单向数据绑定的</p><p>React只是单纯地View层</p><h2 id="13、Underscore-对哪些-JS-原生对象进行了扩展以及提供了哪些好用的函数方法？"><a href="#13、Underscore-对哪些-JS-原生对象进行了扩展以及提供了哪些好用的函数方法？" class="headerlink" title="13、Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？"></a>13、Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</h2><p>Underscore的熟悉程度</p><h2 id="14、使用过angular吗？angular中的过滤器是干什么用的"><a href="#14、使用过angular吗？angular中的过滤器是干什么用的" class="headerlink" title="14、使用过angular吗？angular中的过滤器是干什么用的"></a>14、使用过angular吗？angular中的过滤器是干什么用的</h2><p>在表达式中转换数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;姓名为 &#123;&#123; lastName | uppercase &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>currency，是什么过滤器——格式化数字为货币格式，单位是$符。</p><hr><h1 id="NodeJs部分"><a href="#NodeJs部分" class="headerlink" title="NodeJs部分"></a>NodeJs部分</h1><h2 id="1、对Node的优点和缺点提出了自己的看法："><a href="#1、对Node的优点和缺点提出了自己的看法：" class="headerlink" title="1、对Node的优点和缺点提出了自己的看法："></a>1、对Node的优点和缺点提出了自己的看法：</h2><p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</p><p>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</p><p>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，</p><p>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</p><p>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p><h2 id="2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h2><p>至少给出自己的思路（url-hash,可以使用已有的一些框架history.js等）</p><h2 id="3、Node-js的适用场景？"><a href="#3、Node-js的适用场景？" class="headerlink" title="3、Node.js的适用场景？"></a>3、Node.js的适用场景？</h2><p>1)、实时应用：如在线聊天，实时通知推送等等（如socket.io）</p><p>2)、分布式应用：通过高效的并行I/O使用已有的数据</p><p>3)、工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程序</p><p>4)、游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo框架）</p><p>5)、利用稳定接口提升Web渲染能力</p><p>6)、前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式MEAN架构）</p><h2 id="4、-如果会用node-知道route-middleware-cluster-nodemon-pm2-server-side-rendering么"><a href="#4、-如果会用node-知道route-middleware-cluster-nodemon-pm2-server-side-rendering么" class="headerlink" title="4、(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?"></a>4、(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</h2><p>Nodejs相关概念的理解程度</p><h2 id="5、解释一下-Backbone-的-MVC-实现方式？"><a href="#5、解释一下-Backbone-的-MVC-实现方式？" class="headerlink" title="5、解释一下 Backbone 的 MVC 实现方式？"></a>5、解释一下 Backbone 的 MVC 实现方式？</h2><p>流行的MVC架构模式</p><h2 id="6、什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点"><a href="#6、什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点" class="headerlink" title="6、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?"></a>6、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</h2><p>熟悉前后端通信相关知识</p><p>前端路由就是在不进行后端请求的情况下对页面进行跳转</p><h2 id="7、对Node的优点和缺点提出了自己的看法？"><a href="#7、对Node的优点和缺点提出了自己的看法？" class="headerlink" title="7、对Node的优点和缺点提出了自己的看法？"></a>7、对Node的优点和缺点提出了自己的看法？</h2><p>优点：</p><p>1.因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</p><p>2.与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>缺点：</p><p>1.Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。</p><p>2.缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</p><hr><h1 id="前端概况性问题"><a href="#前端概况性问题" class="headerlink" title="前端概况性问题"></a>前端概况性问题</h1><h2 id="1、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"><a href="#1、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？" class="headerlink" title="1、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"></a>1、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h2><p>使用率较高的框架有jQuery、YUI、Prototype、Dojo、Ext.js、Mootools等。尤其是jQuery，超过91%。</p><p>轻量级框架有Modernizr、underscore.js、backbone.js、Raphael.js等。（理解这些框架的功能、性能、设计原理）</p><p>前端开发工具：Sublime Text 、Eclipse、Notepad、Firebug、HttpWatch、Yslow。</p><p>开发过的插件：城市选择插件，汽车型号选择插件、幻灯片插件。弹出层。（写过开源程序，加载器，js引擎更好）</p><h2 id="2-对BFC规范的理解？"><a href="#2-对BFC规范的理解？" class="headerlink" title="2.对BFC规范的理解？ "></a>2.对BFC规范的理解？ </h2><p>Formatting<br>Context：指页面中的一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。</p><h2 id="3、99-的网站都需要被重构是那本书上写的？"><a href="#3、99-的网站都需要被重构是那本书上写的？" class="headerlink" title="3、99%的网站都需要被重构是那本书上写的？"></a>3、99%的网站都需要被重构是那本书上写的？</h2><p>网站重构：应用web标准进行设计（第2版）</p><h2 id="4、WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#4、WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="4、WEB应用从服务器主动推送Data到客户端有那些方式？"></a>4、WEB应用从服务器主动推送Data到客户端有那些方式？</h2><p>html5 websoket</p><p>WebSocket通过Flash</p><p>XHR长时间连接</p><p>XHR Multipart Streaming</p><p>不可见的Iframe</p><p>&lt;script&gt;标签的长时间连接(可跨域)</p><h2 id="5、加班的看法"><a href="#5、加班的看法" class="headerlink" title="5、加班的看法"></a>5、加班的看法</h2><p>加班就像借钱，原则应当是——救急不救穷</p><h2 id="6、平时如何管理你的项目，如何设计突发大规模并发架构？"><a href="#6、平时如何管理你的项目，如何设计突发大规模并发架构？" class="headerlink" title="6、平时如何管理你的项目，如何设计突发大规模并发架构？"></a>6、平时如何管理你的项目，如何设计突发大规模并发架构？</h2><p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等</p><p>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p><p>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p><p>页面进行标注（例如 页面 模块 开始和结束）；</p><p>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）</p><p>JS 分文件夹存放 命民以该JS 功能为准英文翻译；</p><p>图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</p><h2 id="7、那些操作会造成内存泄漏？"><a href="#7、那些操作会造成内存泄漏？" class="headerlink" title="7、那些操作会造成内存泄漏？"></a>7、那些操作会造成内存泄漏？</h2><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为<br>0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p><p>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><h2 id="8、你说你热爱前端，那么应该WEB行业的发展很关注吧？-说说最近最流行的一些东西吧？"><a href="#8、你说你热爱前端，那么应该WEB行业的发展很关注吧？-说说最近最流行的一些东西吧？" class="headerlink" title="8、你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧？"></a>8、你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧？</h2><p>Node.js、Mongodb、npm、MVVM、MEAN、react、angularjs、browserify、webpack</p><h2 id="9、你有了解我们公司吗？说说你的认识？"><a href="#9、你有了解我们公司吗？说说你的认识？" class="headerlink" title="9、你有了解我们公司吗？说说你的认识？"></a>9、你有了解我们公司吗？说说你的认识？</h2><p>因为我想去阿里，所以我针对阿里的说</p><p>最羡慕就是在双十一购物节，350.19亿元，每分钟支付79万笔。海量数据，居然无一漏单、无一故障。太厉害了。</p><p>携程、去哪儿：一个主要从事在线旅游O2O，当然也可以订酒店，买车票，买机票</p><h2 id="10、移动端（比如：Android-IOS）怎么做好用户体验"><a href="#10、移动端（比如：Android-IOS）怎么做好用户体验" class="headerlink" title="10、移动端（比如：Android IOS）怎么做好用户体验?"></a>10、移动端（比如：Android IOS）怎么做好用户体验?</h2><p>融入自己的设计理念，注重用户体验，选择合适的技术</p><ol><li>多平台用户交互设计</li></ol><p>1）不要模拟其他平台的UI元素和字体</p><p>2）不要混淆平台的专属图标</p><p>3）不要将网页端的经验复用到app上</p><p>4） 你的app里不应该出现死路（Dead-end）</p><ol start="2"><li>用户流（User Flow）</li></ol><p>5）不要把用户带到浏览器去</p><p>6）不要在用户刚刚下载app后就评分</p><h2 id="11-你所知道的页面性能优化方法有那些？"><a href="#11-你所知道的页面性能优化方法有那些？" class="headerlink" title="11.你所知道的页面性能优化方法有那些？"></a>11.你所知道的页面性能优化方法有那些？</h2><p>压缩、合并，减少请求，代码层析优化。。。</p><h2 id="12-除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"><a href="#12-除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？" class="headerlink" title="12.除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"></a>12.除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h2><p>知识面宽度，最好熟悉一些后台语言，比如php，展现出自己的技术两点</p><h2 id="13、AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#13、AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="13、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>13、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h2><h2 id="14、谈谈你认为怎样做能使项目做的更好？"><a href="#14、谈谈你认为怎样做能使项目做的更好？" class="headerlink" title="14、谈谈你认为怎样做能使项目做的更好？"></a>14、谈谈你认为怎样做能使项目做的更好？</h2><p>考虑问题的深入，不仅仅停留在完成任务上，要精益求精</p><h2 id="15、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#15、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="15、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>15、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h2><p>表现出对前端的认同与兴趣，关注相关技术前沿</p><h2 id="16、php中下面哪个函数可以打开一个文件，以对文件进行读和写操作？"><a href="#16、php中下面哪个函数可以打开一个文件，以对文件进行读和写操作？" class="headerlink" title="16、php中下面哪个函数可以打开一个文件，以对文件进行读和写操作？"></a>16、php中下面哪个函数可以打开一个文件，以对文件进行读和写操作？</h2><p>A.fget()<br>B.file_open()<br><strong>C.fopen()</strong><br>D.open_file()</p><h2 id="17、php中rmdir可以直接删除文件夹吗？该目录必须是空的，而且要有相应的权限–来自api"><a href="#17、php中rmdir可以直接删除文件夹吗？该目录必须是空的，而且要有相应的权限–来自api" class="headerlink" title="17、php中rmdir可以直接删除文件夹吗？该目录必须是空的，而且要有相应的权限–来自api"></a>17、php中rmdir可以直接删除文件夹吗？该目录必须是空的，而且要有相应的权限–来自api</h2><p>A.任何文件夹都可以删除<br>B.空文件夹可以删除<br>C.有权限的任何文件夹都可以删除<br>D.有权限的空文件夹可以删除</p><h2 id="18、phpinset和empty的区别，举例说明"><a href="#18、phpinset和empty的区别，举例说明" class="headerlink" title="18、phpinset和empty的区别，举例说明"></a>18、phpinset和empty的区别，举例说明</h2><p>1、empty函数</p><p>用途：检测变量是否为空</p><p>判断：如果 var 是非空或非零的值，则 empty() 返回<br>FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var;<br>以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回<br>TRUE。注意：empty()<br>只检测变量，检测任何非变量的东西都将导致解析错误。换句话说，后边的语句将不会起作用;</p><p>2、isset函数</p><p>用途：检测变量是否设置</p><p>判断：检测变量是否设置，并且不是 NULL。如果已经使用 unset()<br>释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL<br>的变量，将返回 FALSE。同时要注意的是一个NULL 字节（”\0”）并不等同于 PHP 的 NULL<br>常数。</p><h2 id="19、php中-SERVER变量中如何得到当前执行脚本路径"><a href="#19、php中-SERVER变量中如何得到当前执行脚本路径" class="headerlink" title="19、php中$_SERVER变量中如何得到当前执行脚本路径"></a>19、php中<code>$_SERVER</code>变量中如何得到当前执行脚本路径</h2><h2 id="20、写一个php函数，要求两个日期字符串的天数差，如2012-02-05-2012-03-06的日期差数"><a href="#20、写一个php函数，要求两个日期字符串的天数差，如2012-02-05-2012-03-06的日期差数" class="headerlink" title="20、写一个php函数，要求两个日期字符串的天数差，如2012-02-05~2012-03-06的日期差数"></a>20、写一个php函数，要求两个日期字符串的天数差，如2012-02-05~2012-03-06的日期差数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">str1  =  &quot;2002-01-20&quot;    </span><br><span class="line">str2  =  &quot;2002-10-11&quot;  </span><br><span class="line"></span><br><span class="line">function  btnCount_Click()&#123;    </span><br><span class="line">    s1  =  &quot;2002-1-10&quot;    </span><br><span class="line">    s2  =  &quot;2002-10-1&quot;    </span><br><span class="line">    alert(DateDiff(s1,s2))    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">   //计算天数差的函数，通用    </span><br><span class="line">   function  DateDiff(sDate1,  sDate2)&#123;    //sDate1和sDate2是2002-12-18格式    </span><br><span class="line">       var  aDate,  oDate1,  oDate2,  iDays    </span><br><span class="line">       aDate  =  sDate1.split(&quot;-&quot;)    </span><br><span class="line">       oDate1  =  new  Date(aDate[1]  +  &apos;-&apos;  +  aDate[2]  +  &apos;-&apos;  + </span><br><span class="line">aDate[0])    //转换为12-18-2002格式    </span><br><span class="line">       aDate  =  sDate2.split(&quot;-&quot;)    </span><br><span class="line">       oDate2  =  new  Date(aDate[1]  +  &apos;-&apos;  +  aDate[2]  +  &apos;-&apos;  + </span><br><span class="line">aDate[0])    </span><br><span class="line">       iDays  =  parseInt(Math.abs(oDate1  -  oDate2)  /  1000  /  60  /  60 </span><br><span class="line">/24)    //把相差的毫秒数转换为天数    </span><br><span class="line">       return  iDays    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、一个衣柜中放了许多杂乱的衬衫，如果让你去整理一下，使得更容易找到你想要的衣服；你会怎么做？请写出你的做法和思路？"><a href="#21、一个衣柜中放了许多杂乱的衬衫，如果让你去整理一下，使得更容易找到你想要的衣服；你会怎么做？请写出你的做法和思路？" class="headerlink" title="21、一个衣柜中放了许多杂乱的衬衫，如果让你去整理一下，使得更容易找到你想要的衣服；你会怎么做？请写出你的做法和思路？"></a>21、一个衣柜中放了许多杂乱的衬衫，如果让你去整理一下，使得更容易找到你想要的衣服；你会怎么做？请写出你的做法和思路？</h2><h2 id="22、如何优化网页加载速度？"><a href="#22、如何优化网页加载速度？" class="headerlink" title="22、如何优化网页加载速度？"></a>22、如何优化网页加载速度？</h2><p>1.减少css，js文件数量及大小(减少重复性代码，代码重复利用)，压缩CSS和Js代码</p><p>2.图片的大小</p><p>3.把css样式表放置顶部，把js放置页面底部</p><p>4.减少http请求数</p><p>5.使用外部 Js 和 CSS</p><h2 id="23、工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量完成工作"><a href="#23、工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量完成工作" class="headerlink" title="23、工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量完成工作?"></a>23、工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量完成工作?</h2><p>熟悉相关设计规范，自己总结的一些经验</p><h2 id="24、介绍项目经验、合作开发、独立开发。"><a href="#24、介绍项目经验、合作开发、独立开发。" class="headerlink" title="24、介绍项目经验、合作开发、独立开发。"></a>24、介绍项目经验、合作开发、独立开发。</h2><p>团队协作，个人能力。实践经验</p><h2 id="25、开发过程中遇到困难，如何解决。"><a href="#25、开发过程中遇到困难，如何解决。" class="headerlink" title="25、开发过程中遇到困难，如何解决。"></a>25、开发过程中遇到困难，如何解决。</h2><p>考察解决问题的能力</p><h2 id="26、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#26、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="26、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>26、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h2><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p><p>1、实现界面交互</p><p>2、提升用户体验</p><p>3、有了Node.js，前端可以实现服务端的一些事情</p><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p><p>参与项目，快速高质量完成实现效果图，精确到1px；</p><p>与团队成员，UI设计，产品经理的沟通；</p><p>做好的页面结构，页面重构和用户体验；</p><p>处理hack，兼容、写出优美的代码格式；</p><p>针对服务器的优化、拥抱最新前端技术。</p><p>其它相关的加分项：</p><p>1.都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?</p><p>2.都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?</p><p>3.瀑布流布局或者流式布局是否有了解</p><p>4.HTML5都有哪些新的API?</p><p>5.都用过什么代码调试工具?</p><p>6.是否有接触过或者了解过重构。</p><p>7.你遇到过比较难的技术问题是？你是如何解决的？</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅虎前端优化14条</title>
      <link href="/2019/06/28/0.tips/6.%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%9614%E6%9D%A1/"/>
      <url>/2019/06/28/0.tips/6.%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%9614%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Make-Fewer-HTTP-Requests-（尽可能减少http请求数）"><a href="#1、Make-Fewer-HTTP-Requests-（尽可能减少http请求数）" class="headerlink" title="1、Make Fewer HTTP Requests （尽可能减少http请求数）"></a>1、Make Fewer HTTP Requests （尽可能减少http请求数）</h2><p>http请求是要开销的，减少请求数可以提高网页加载速度。常用的方法，合并css，js以及 Image maps和css sprites等。（css sprites是指只用将页面上的背景图合并成一张，然后通过background-position来取背景。）</p><h2 id="2、Use-a-Content-Delivery-Network-（使用CDN-内容分发网络"><a href="#2、Use-a-Content-Delivery-Network-（使用CDN-内容分发网络" class="headerlink" title="2、Use a Content Delivery Network （使用CDN 内容分发网络)"></a>2、Use a Content Delivery Network （使用CDN 内容分发网络)</h2><p>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的 cache服务器内，通过DNS负载均衡(可选根据时间或访问速度来决定访问哪台服务器资源)的技术，判断用户来源就近访问cache服务器取得所需的内容。这样可以有效减少数据在网络上传输的时间，提高速度。</p><h2 id="3、Add-an-Expires-Header（添加Expires-catch-control头）"><a href="#3、Add-an-Expires-Header（添加Expires-catch-control头）" class="headerlink" title="3、Add an Expires Header（添加Expires/catch-control头）"></a>3、Add an Expires Header（添加Expires/catch-control头）</h2><p>现在越来越多的图片，脚本，css，flash被嵌入到页面中，当我们访问他们的时候势必会做许多次的http请求。其实我们可以通过设置 Expires header来缓存这些文件。Expire其实就是通过header报文来指定特定类型的文件在览器中的缓存时间。大多数的图片，flash在发布后都是不需要经常修改的，做了缓存以后这样浏览器以后就不需要再从服务器下载这些文件而是而直接从缓存中读取，这样再次访问页面的速度会大大加快。<br>不过期间也有过问题，特别是对于脚本过期时间的设置还是应该仔细考虑下，不然相应的脚本功能更新后客户端可能要过很长一段时间才能“感知”到这样的变化。所以，哪些应该缓存，哪些不该缓存还是应该仔细斟酌一番。</p><h2 id="4、Gzip-Components（启用gzip压缩）"><a href="#4、Gzip-Components（启用gzip压缩）" class="headerlink" title="4、Gzip Components（启用gzip压缩）"></a>4、Gzip Components（启用gzip压缩）</h2><p>Gzip的思想就是把文件（  html ,php, js, css, xml, txt…）先在服务器端进行压缩，然后再传输。这样可以显著减少文件传输的大小。传输完毕后浏览器会重新对压缩过的内容进行解压缩，并执行。</p><h2 id="5、Put-Stylesheets-at-the-Top-将css放在页面最上面"><a href="#5、Put-Stylesheets-at-the-Top-将css放在页面最上面" class="headerlink" title="5、Put Stylesheets at the Top(将css放在页面最上面)"></a>5、Put Stylesheets at the Top(将css放在页面最上面)</h2><h2 id="6、Put-Scripts-at-the-Bottom（将script放在页面最下面）"><a href="#6、Put-Scripts-at-the-Bottom（将script放在页面最下面）" class="headerlink" title="6、Put Scripts at the Bottom（将script放在页面最下面）"></a>6、Put Scripts at the Bottom（将script放在页面最下面）</h2><p>将脚本放在页面最下面的目的有那么两点： 1、因为防止script脚本的执行阻塞页面的下载。在页面loading的过程中，当浏览器读到js执行语句的时候一定会把它全部解释完毕后在会接下来读下面的内容。 所以放在页面最后，可以有效减少页面可视元素的加载时间。        2、 脚本引起的第二个问题是它阻塞并行下载数量。</p><h2 id="7、Avoid-CSS-Expressions（避免在css中使用表达式）"><a href="#7、Avoid-CSS-Expressions（避免在css中使用表达式）" class="headerlink" title="7、Avoid CSS Expressions（避免在css中使用表达式）"></a>7、Avoid CSS Expressions（避免在css中使用表达式）</h2><p>css表达是的执行次数是远远多于我们想象的，往往会严重地影响性能。而且，它只能在IE中执行。所以因尽量地避免它，其实大部分可以用js实现。</p><h2 id="8、Make-JavaScript-and-CSS-External（把javascript和css都放到外部文件中）"><a href="#8、Make-JavaScript-and-CSS-External（把javascript和css都放到外部文件中）" class="headerlink" title="8、Make JavaScript and CSS External（把javascript和css都放到外部文件中）"></a>8、Make JavaScript and CSS External（把javascript和css都放到外部文件中）</h2><p>不仅从性能优化上会这么做，用代码易于维护的角度看也应该这么做。把css和js写在页面内容可以减少2次请求，但也增大了页面的大小。如果已经对css和js做了缓存，那也就没有2次多余的http请求了。</p><h2 id="9、Reduce-DNS-Lookups（减少DNS查询）"><a href="#9、Reduce-DNS-Lookups（减少DNS查询）" class="headerlink" title="9、Reduce DNS Lookups（减少DNS查询）"></a>9、Reduce DNS Lookups（减少DNS查询）</h2><p>在Internet上域名与IP地址之间是一一对应的，域名（kuqin.com）很好记，但计算机不认识，计算机之间的“相认”还要转成ip地址。在网络上每台计算机都对应有一个独立的ip地址。在域名和ip地址之间的转换工作称为域名解析，也称DNS查询。一次DNS的解析过程会消耗20-120毫秒的时间,在dns查询结束之前，浏览器不会下载该域名下的任何东西。所以减少dns查询的时间可以加快页面的加载速度。yahoo的建议一个页面所包含的域名数尽量控制在2-4个。</p><h2 id="10、Minify-JavaScript（压缩-JavaScript）"><a href="#10、Minify-JavaScript（压缩-JavaScript）" class="headerlink" title="10、Minify JavaScript（压缩 JavaScript）"></a>10、Minify JavaScript（压缩 JavaScript）</h2><p>压缩js和css的左右很显然，减少页面字节数。容量小页面加载速度自然也就快。而且压缩除了减少体积以外还可以起到一定的保护左右。这点我们做得不错。常用的压缩工具有JsMin、YUI compressor等。另外像 <a href="http://dean.edwards.name/packer/" target="_blank" rel="noopener">http://dean.edwards.name/packer/</a> 还给我们提供了一个非常方便的在线压缩工具。压缩带来的一个弊端就是代码的可读性没了，但是在调试的时候，工具可以将其复原，也就是调用本地的。</p><h2 id="11、Avoid-Redirects（避免重定向）"><a href="#11、Avoid-Redirects（避免重定向）" class="headerlink" title="11、Avoid Redirects（避免重定向）"></a>11、Avoid Redirects（避免重定向）</h2><p>发生重定向的原因很多，比如跳转后面缺少 /等，每增加一次重定向就会增加一次web请求，所以因该尽量减少。</p><h2 id="12、Remove-Duplicate-Scripts-（移除重复的脚本）"><a href="#12、Remove-Duplicate-Scripts-（移除重复的脚本）" class="headerlink" title="12、Remove Duplicate Scripts （移除重复的脚本）"></a>12、Remove Duplicate Scripts （移除重复的脚本）</h2><h2 id="13、Configure-ETags（配置实体标签（ETags））"><a href="#13、Configure-ETags（配置实体标签（ETags））" class="headerlink" title="13、Configure ETags（配置实体标签（ETags））"></a>13、Configure ETags（配置实体标签（ETags））</h2><p>使用ETags减少Web应用带宽和负载</p><h2 id="14、Make-Ajax-Cacheable（使-AJAX-缓存）"><a href="#14、Make-Ajax-Cacheable（使-AJAX-缓存）" class="headerlink" title="14、Make Ajax Cacheable（使 AJAX 缓存）"></a>14、Make Ajax Cacheable（使 AJAX 缓存）</h2><p>做ajax请求的时候往往还要增加一个时间戳去避免他缓存。It’s important to remember that “asynchronous” does not imply “instantaneous”.（记住“异步”不是“瞬间”这一点很重要）。记住，即使AJAX是动态产生的而且只对一个用户起作用，他们依然可以被缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由</title>
      <link href="/2019/05/22/11.vue/6.vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/05/22/11.vue/6.vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、路由的概念和原理"><a href="#一、路由的概念和原理" class="headerlink" title="一、路由的概念和原理"></a>一、路由的概念和原理</h1><p>路由就是对应关系</p><h2 id="1-路由分类"><a href="#1-路由分类" class="headerlink" title="1.路由分类"></a>1.路由分类</h2><ul><li>后端路由：根据不同的URL请求，返回不同的内容；<br>本质：URL与服务器资源之间的对应关系</li><li>前端路由：根据不同用户事件，显示不同的页面<br>本质：用户事件与事件处理函数之间的对应关系</li></ul><p>后端路由渲染页面的方式称为后端渲染（存在性能问题，整页刷新）<br>Ajax前端渲染（局部刷新提高性能，但是不支持浏览器的前进后退操作） </p><p>SPA（Single Page Application）单页面应用程序：整个网站只有一个页面，内容的变化通过Ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作<br>SPA实现原理之一：基于URL地址的hash（hash的变化会导致浏览器记录访问历史的变化、但是<strong>hash的变化不会触发新的URL请求</strong>） 在实现SPA过程中，最核心的技术点就是前端路由。vue,react,angular都实现了SPA。</p><h2 id="2-简易前端路由-实现原理"><a href="#2-简易前端路由-实现原理" class="headerlink" title="2.简易前端路由/实现原理"></a>2.简易前端路由/实现原理</h2><p>基于URL的hash变化控制组件切换<br><code>location.hash</code>: 地址栏上#开头的值，锚点也属于hash<br><code>window.onhashchange</code> hash变化时触发的事件</p><p><code>&lt;component :is=&#39;zhuye&#39;&gt;&lt;/component&gt;</code>是组件的占位符<br>例如is里的值是zhuye时，相当于使用了组件<zhuye></zhuye></p><h1 id="二、Vue-Router"><a href="#二、Vue-Router" class="headerlink" title="二、Vue Router"></a>二、Vue Router</h1><p>vue官方的路由管理器，和vue.js深度集成</p><h2 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h2><p>支持HTML5 历史模式或 hash 模式<br>支持嵌套路由<br>支持路由参数<br>支持编程式路由<br>支持命名路由 </p><h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h2><h3 id="1）引入文件："><a href="#1）引入文件：" class="headerlink" title="1）引入文件："></a>1）引入文件：</h3><p>先引入vue，再引入vueRouter。会生成一个VueRouter构造</p><h3 id="2）添加路由链接："><a href="#2）添加路由链接：" class="headerlink" title="2）添加路由链接："></a>2）添加路由链接：</h3><p><code>&lt;router-link to=&quot;/user&quot;&gt;XXX&lt;/router-link&gt;</code><br>会解析为<code>&lt;a href=&quot;#/user&quot;&gt;XXX&lt;/a&gt;</code></p><h3 id="3）路由填充位（路由占位符）"><a href="#3）路由填充位（路由占位符）" class="headerlink" title="3）路由填充位（路由占位符）"></a>3）路由填充位（路由占位符）</h3><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><h3 id="4）路由组件"><a href="#4）路由组件" class="headerlink" title="4）路由组件"></a>4）路由组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123; </span><br><span class="line">template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）配置路由规则创建路由实例"><a href="#5）配置路由规则创建路由实例" class="headerlink" title="5）配置路由规则创建路由实例"></a>5）配置路由规则创建路由实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123; </span><br><span class="line">routes: [ </span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/user'</span>,<span class="attr">component</span>: User&#125;, </span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>: Register&#125; </span><br><span class="line">] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>routes是路由规则数组<br>每个路由规则都是一个配置对象，其中至少包含 path 和 component 两个属性：<br><code>//path 表示当前路由规则匹配的 hash 地址</code><br><code>//component 表示当前路由规则对应要展示的组件</code></p><h3 id="6）挂载路由"><a href="#6）挂载路由" class="headerlink" title="6）挂载路由"></a>6）挂载路由</h3><p>在new Vue实例时挂载router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">"#app"</span>,</span><br><span class="line">router:router <span class="comment">//可以简写为router</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-路由重定向"><a href="#3-路由重定向" class="headerlink" title="3.路由重定向"></a>3.路由重定向</h2><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 B ，从而展示特定的组件页面<br>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>,<span class="attr">redirect</span>: <span class="string">'/login'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/user'</span>,<span class="attr">component</span>: User &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="4-嵌套路由"><a href="#4-嵌套路由" class="headerlink" title="4.嵌套路由"></a>4.嵌套路由</h2><p>父级路由组件里面再添加 router-link，router-view<br>父级路由的路由规则里添加children属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:<span class="string">'/user'</span>,</span><br><span class="line">component:User,</span><br><span class="line">children:[</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/user/tab1'</span>,<span class="attr">component</span>:Tab1&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h2 id="5-动态路由匹配"><a href="#5-动态路由匹配" class="headerlink" title="5.动态路由匹配"></a>5.动态路由匹配</h2><p>例如有多个路由链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/1'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/2'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/user/3'</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>路由规则可以这样匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>:<span class="string">"/user/:id"</span>,<span class="attr">component</span>: User&#125;</span><br></pre></td></tr></table></figure><p>路由组件里可以这样输出id： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$routes.params.id&#125;&#125;</span><br></pre></td></tr></table></figure><p>使用$routes传递参数，会有耦合性问题，传递参数还有以下方法：</p><ul><li><p>props是bool值：(只能获取id)<br>路由规则：<code>{ path:&quot;/user/:id&quot;,component: User,props:true}</code><br>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'id'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;id&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>props是对象： (无法获取id)<br>路由规则：<code>{ path:&quot;/user/:id&quot;,component: User,props:{uname:&quot;lx&quot;,age:20}}</code><br>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'uname'</span>,<span class="string">'age'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;uname&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>props是函数：(既可以获取id，也可以传递其他参数)<br>路由规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">path:<span class="string">"/user/:id"</span>,</span><br><span class="line">component: User,</span><br><span class="line">props:<span class="function"><span class="params">route</span>=&gt;</span>(&#123;<span class="attr">id</span>:route.params.id,<span class="attr">uname</span>:<span class="string">"lx"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;) <span class="comment">//ES6函数传参写法，route是形参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = &#123; </span><br><span class="line">props:[<span class="string">'id'</span>,<span class="string">'uname'</span>,<span class="string">'age'</span>],</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;id&#125;&#125;&#123;&#123;uname&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-命名路由"><a href="#6-命名路由" class="headerlink" title="6.命名路由"></a>6.命名路由</h2><p>可以给路由规则起别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">path:<span class="string">'/user/:id'</span>,</span><br><span class="line">name: <span class="string">'user'</span>,</span><br><span class="line">component: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写路由链接时就不用写路径了,改成动态绑定的，使用params传递参数：<br><code>&lt;router-link :to=&quot;{name:&#39;user&#39;,params:{id:123}}&quot;&gt;User&lt;/router-link&gt;</code></p><h2 id="7-编程式导航"><a href="#7-编程式导航" class="headerlink" title="7.编程式导航"></a>7.编程式导航</h2><p>页面导航的两种方式：<br>声明式导航：点击链接跳转<br>编程式导航：使用jsAPI跳转，如location.href</p><p>Vue里的编程式导航：<br>比如在点击事件里写以下代码：<br><code>this.$router.push(&#39;hash地址&#39;)</code><br><code>this.$router.go(n)   n=1前进一个页面 n=-1后退一个页面</code></p><p>push参数传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串（路径名称）</span></span><br><span class="line">router.push(<span class="string">'/home'</span>)</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/home'</span> &#125;)</span><br><span class="line"><span class="comment">//传递参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>:<span class="string">'/user'</span>,<span class="attr">params</span>:&#123;<span class="attr">userId</span>:<span class="number">123</span>&#125; &#125;)</span><br><span class="line">router.push(&#123; <span class="attr">name</span>:<span class="string">'user'</span>,<span class="attr">params</span>:&#123;<span class="attr">userId</span>:<span class="number">123</span>&#125; &#125;)</span><br><span class="line"><span class="comment">//带查询参数变成 /register?uname=lisi</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">query</span>:&#123; <span class="attr">uname</span>: <span class="string">'lisi'</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口调用三种用法fetch;axios;async/await</title>
      <link href="/2019/05/21/11.vue/5.%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/21/11.vue/5.%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1、fetch用法"><a href="#1、fetch用法" class="headerlink" title="1、fetch用法"></a>1、fetch用法</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h2><p>fetch是原生JS基于promise实现的数据获取方式，功能更强大、灵活</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>).then(funciton(data)&#123;</span><br><span class="line"><span class="keyword">return</span> data.text(); <span class="comment">//data.text是一个promise实例</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">//这里才是实际的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-fetch传递参数"><a href="#3-fetch传递参数" class="headerlink" title="3.fetch传递参数"></a>3.fetch传递参数</h2><p>method默认是get</p><h3 id="1）GET-DELETE请求："><a href="#1）GET-DELETE请求：" class="headerlink" title="1）GET/DELETE请求："></a>1）GET/DELETE请求：</h3><ul><li><p>传统URL:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url?id=1'</span>,&#123;</span><br><span class="line">method:<span class="string">'get/delete'</span></span><br><span class="line">&#125;).then...          注意后台接收使用/url  req.query.id</span><br></pre></td></tr></table></figure></li><li><p>Restful URL:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url/1'</span>,&#123;</span><br><span class="line">method:<span class="string">'get/delete'</span></span><br><span class="line">&#125;).then...          注意后台接收使用/url/:id  req.params.id</span><br></pre></td></tr></table></figure></li></ul><h3 id="2）POST请求："><a href="#2）POST请求：" class="headerlink" title="2）POST请求："></a>2）POST请求：</h3><p>两种参数传递格式，对应两种方式</p><ul><li><p>方式1 urlencoded：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>,&#123;</span><br><span class="line">method:<span class="string">'post'</span>,</span><br><span class="line">body:<span class="string">'name=lx&amp;age=18'</span>,</span><br><span class="line">headers: &#123;</span><br><span class="line"> <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;).then...          注意后台接收使用bodyParser  req.body.uname</span><br></pre></td></tr></table></figure></li><li><p>方式2 json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;url&apos;,&#123;</span><br><span class="line">method:&apos;post&apos;,</span><br><span class="line">body:JSON.stringify(&#123;</span><br><span class="line">uname:&apos;lx&apos;,</span><br><span class="line">age:18</span><br><span class="line">&#125;),</span><br><span class="line">headers: &#123;</span><br><span class="line"> &apos;Content-Type&apos;:&apos;application/json&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then...          注意后台接收使用bodyParser  req.body.uname</span><br></pre></td></tr></table></figure></li></ul><h3 id="3）PUT请求"><a href="#3）PUT请求" class="headerlink" title="3）PUT请求"></a>3）PUT请求</h3><p>和POST类似，url后面加上要修改的id即可。也支持两种形式的参数</p><h2 id="4-fetch响应结果"><a href="#4-fetch响应结果" class="headerlink" title="4.fetch响应结果"></a>4.fetch响应结果</h2><p>fetch的第一个then里的返回结果不止有data.text()，还有data.json()更常用<br>注意后台返回结果时，使用<code>res.json({uname:&quot;lx&quot;,age:18})</code>，不再是res.send</p><hr><h1 id="二、axios用法"><a href="#二、axios用法" class="headerlink" title="二、axios用法"></a>二、axios用法</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>也是封装了promise实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> axios = &#123;</span><br><span class="line"><span class="keyword">get</span>: function(myurl)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:myurl,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">resolve(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h2><p>引入axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) <span class="comment">//这里的data是固定的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><h3 id="1）GET-DELETE传递参数："><a href="#1）GET-DELETE传递参数：" class="headerlink" title="1）GET/DELETE传递参数："></a>1）GET/DELETE传递参数：</h3><ul><li>根据Url有两种形式，后台也需要相应修改</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url?id=123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)<span class="comment">//后台接收用req.query</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url/123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)<span class="comment">//后台解析用:id，接收用req.params</span></span><br></pre></td></tr></table></figure><ul><li>也可以使用params属性传递get参数，后台使用req.query.id接收，本质也是使用\？拼接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'url'</span>,&#123;</span><br><span class="line">params: &#123; <span class="attr">id</span>:<span class="number">123</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2）POST和PUT传递参数："><a href="#2）POST和PUT传递参数：" class="headerlink" title="2）POST和PUT传递参数："></a>2）POST和PUT传递参数：</h3><ul><li>方式1：可以直接写参数对象，不需要加params字段。axios会自动以json格式传递参数<strong>最常用</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'url'</span>,&#123;</span><br><span class="line">name:<span class="string">'lx'</span>,</span><br><span class="line">age:<span class="number">18</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>方式2：使用<code>URLSearchParams()</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'name'</span>,<span class="string">'lx'</span>);</span><br><span class="line">params.append(<span class="string">'age'</span>,<span class="number">18</span>);</span><br><span class="line">axios.post(<span class="string">'url'</span>,params).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>PUT的处理只是URL里面传递了id等参数，其他和POST类似<br>tips：axios有可能会发送一次预请求，类型为OPTIONS</p></blockquote><h2 id="4-响应结果和全局配置"><a href="#4-响应结果和全局配置" class="headerlink" title="4.响应结果和全局配置"></a>4.响应结果和全局配置</h2><ul><li><p>响应结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret.data 实际的数据 </span><br><span class="line">后台如果使用res.json返回，前台可以直接使用，不用再处理</span><br><span class="line">ret.status 响应状态码</span><br></pre></td></tr></table></figure></li><li><p>全局配置：<br>1.配置公共的请求地址 会和调用接口时的url自动拼接<br><code>axios.defaults.baseURL = &#39;https://api.example.com&#39;;</code><br>2.配置 超时时间<br><code>axios.defaults.timeout = 2500;</code><br>3.自定义请求头（跨域的话需要后台相应的配置）<br><code>axios.defaults.headers[&#39;请求头名字&#39;] = &#39;值&#39;;</code> 请求头名字不是随便起的，由后台确定<br>4.配置公共的 post 的 Content-Type<br><code>axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></p></li></ul><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h2><p>在axios发送请求或者得到响应之前一定会执行的代码</p><h3 id="1）请求拦截器"><a href="#1）请求拦截器" class="headerlink" title="1）请求拦截器"></a>1）请求拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//一般在这里设置请求头</span></span><br><span class="line">config.headers.mytoken = <span class="string">'nihao'</span>;</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-响应拦截器"><a href="#2-响应拦截器" class="headerlink" title="2)响应拦截器"></a>2)响应拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//这个res是Promise对象，不是实际的数据res.data</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、async-await用法"><a href="#三、async-await用法" class="headerlink" title="三、async/await用法"></a>三、async/await用法</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><p>ES7引入的新语法，代码风格更简洁(不必写then)，更加方便的进行异步操作<br>async用于函数上，函数返回的是一个promise实例，配合响应拦截器可以让它直接返回数据<br>await用于async函数中</p><p><strong>用同步的思想解决异步问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> ret1 = <span class="keyword">await</span> axios.get(<span class="string">'/axios'</span>)</span><br><span class="line"><span class="keyword">var</span> ret2 = <span class="keyword">await</span> axios.get(<span class="string">'/axios-json'</span>) <span class="comment">//执行顺序是先ret1再ret2,类似同步</span></span><br><span class="line"><span class="built_in">console</span>.log(ret1, ret2); <span class="comment">//这里打印的仍然是Promise对象，但是配合下面的拦截器就是打印数据</span></span><br><span class="line">&#125;</span><br><span class="line">queryData()</span><br></pre></td></tr></table></figure><p>可以配合响应拦截器直接拿数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> data = response.data;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise语法</title>
      <link href="/2019/05/20/11.vue/4.promise%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/20/11.vue/4.promise%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前后端交互模式"><a href="#一、前后端交互模式" class="headerlink" title="一、前后端交互模式"></a>一、前后端交互模式</h1><h2 id="1-接口调用方式"><a href="#1-接口调用方式" class="headerlink" title="1.接口调用方式"></a>1.接口调用方式</h2><p>原生ajax，基于jq的ajax，原生js新方法fetch，第三方封装的axios</p><h2 id="2-URL地址格式"><a href="#2-URL地址格式" class="headerlink" title="2.URL地址格式"></a>2.URL地址格式</h2><ul><li>传统形式：<br>  <code>schema://host:port/path?query#fragment</code></li><li>Restful形式：<br>根据HTTP提交方式区分 get/post/put/delete<br><code>使用</code>/参数<code>传递参数：http://www.shanwliu.fun/books/123</code></li></ul><h1 id="二、promise"><a href="#二、promise" class="headerlink" title="二、promise"></a>二、promise</h1><h2 id="1-为什么要使用promise"><a href="#1-为什么要使用promise" class="headerlink" title="1.为什么要使用promise"></a>1.为什么要使用promise</h2><p>ajax发送请求是异步的，不能确定请求发送的顺序，如果需要按照顺序发送，可以使用多层嵌套ajax解决，但是会形成<code>回调地狱</code><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line"><span class="comment">//promise里面可以写任何代码，一般写ajax</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type:<span class="string">""</span>,</span><br><span class="line">url:<span class="string">""</span>,</span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">resolve(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//resolve() 是成功的回调，reject() 是失败的回调</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//第一个是resolve,第二个是reject</span></span><br><span class="line"><span class="comment">//必须使用then才能拿到结果</span></span><br></pre></td></tr></table></figure><h2 id="3-promise其他方法："><a href="#3-promise其他方法：" class="headerlink" title="3.promise其他方法："></a>3.promise其他方法：</h2><p>实例的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.catch(function()&#123; console.log(&quot;promise发生异常&quot;) &#125;)</span><br><span class="line">p.finally(function()&#123; console.log(&quot;不管结果如何都会执行&quot;)&#125;)</span><br></pre></td></tr></table></figure><p>Promise的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1,p2,p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;) <span class="comment">//集合多个promise对象的返回结果</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;) <span class="comment">//只要拿到一个promise对象的结果就返回</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件化开发</title>
      <link href="/2019/05/19/11.vue/3.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2019/05/19/11.vue/3.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一、组件化开发思想"><a href="#一、组件化开发思想" class="headerlink" title="一、组件化开发思想"></a>一、组件化开发思想</h1><h2 id="1-现实中的组件化思想"><a href="#1-现实中的组件化思想" class="headerlink" title="1.现实中的组件化思想"></a>1.现实中的组件化思想</h2><p>标准、分治、重用、组合</p><h2 id="2-编程中的组件化思想"><a href="#2-编程中的组件化思想" class="headerlink" title="2.编程中的组件化思想"></a>2.编程中的组件化思想</h2><p>组件就是将一段UI样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种整体化的思想就是组件化</p><h2 id="3-组件化规范web-components"><a href="#3-组件化规范web-components" class="headerlink" title="3.组件化规范web components"></a>3.组件化规范web components</h2><p>目的：尽可能多的重用代码<br>通过创建封装好功能的定制元素解决组件化不容易实现的问题<br>vue部分实现了上述规范<br>根组件：new Vue可以看做一个最大的组件 app</p><h1 id="二、组件注册"><a href="#二、组件注册" class="headerlink" title="二、组件注册"></a>二、组件注册</h1><h2 id="1-全局注册"><a href="#1-全局注册" class="headerlink" title="1.全局注册"></a>1.全局注册</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(组件名称, &#123;</span><br><span class="line">data: 组件数据</span><br><span class="line">template: 组件模板内容</span><br><span class="line">methods: &#123;&#125;，</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>1.组件命名方式使用 小写字母+短横线 或者 驼峰式<br>如果使用驼峰式，只能在模板内容里使用驼峰式<br>但是在vue容器里使用，只能用短横线形式 最好只用短横线</li><li>2.组件数据是一个函数 要return一个对象，对象里写数据</li><li>3.组件模板内容是一个字符串，根元素只能有一个<br>支持插值表达式<br>支持ES6模板字符串``增加可读性</li></ul><p>用法： 写在vue容器里，当做普通标签使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">组件名称</span>&gt;</span><span class="tag">&lt;/<span class="name">组件名称</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以重复使用，并且每个组件的数据是独立的</p><h2 id="2-局部组件注册"><a href="#2-局部组件注册" class="headerlink" title="2.局部组件注册"></a>2.局部组件注册</h2><p>写在vue的实例里，只能在注册它的父组件里使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line"><span class="string">'组件名称'</span> ： 组件内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件内容可以在外部用对象的形式定义</p><h1 id="三、组件间数据传递"><a href="#三、组件间数据传递" class="headerlink" title="三、组件间数据传递"></a>三、组件间数据传递</h1><h2 id="1-父子和兄弟组件"><a href="#1-父子和兄弟组件" class="headerlink" title="1.父子和兄弟组件"></a>1.父子和兄弟组件</h2><p>父组件： <code>#app</code><br>子组件： 自己定义的组件<br>兄弟组件：子组件之间互称为兄弟组件<br>可以传递任何类型的值</p><h2 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h2><p>子组件用props接收父组件传递过来的数据，props是一个数组；<br>父组件在标签里用 <code>属性=&#39;属性值&#39;</code> 的形式传递，可以使用v-bind动态绑定<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian1.jpg" alt></p><p>结果：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian2.jpg" alt></p><h2 id="3-子组件向父组件传值："><a href="#3-子组件向父组件传值：" class="headerlink" title="3.子组件向父组件传值："></a>3.子组件向父组件传值：</h2><p>props传递数据是单向数据流，不能实现从子到父传值，使用自定义事件实现<br>父组件在使用子组件时，给标签绑定自定义事件<br>        <code>@自定义事件=&#39;父组件自己的函数&#39;</code><br>子组件 在自己的普通事件里<br>        <code>this.$emit(&#39;父自定义事件名称&#39;,参数)</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuezujian3.jpg" alt></p><h2 id="4-兄弟组件之间传值"><a href="#4-兄弟组件之间传值" class="headerlink" title="4.兄弟组件之间传值"></a>4.兄弟组件之间传值</h2><p>通过事件中心交互<br><code>var hub = new Vue()</code><br>监听事件：<code>$on(&#39;事件名称&#39;，触发函数)</code><br>销毁事件：<code>$off(&#39;事件名称&#39;)</code><br>触发事件：<code>$emit(&#39;事件名称&#39;，可选参数)</code></p><h2 id="5-组件插槽"><a href="#5-组件插槽" class="headerlink" title="5.组件插槽"></a>5.组件插槽</h2><p>在使用组件时，之前标签内没有写值，如果要写内容并传递，需要使用组件插槽<br>1）基本使用<br>slot标签<code>&lt;slot&gt;&lt;/slot&gt;</code>写在子组件的模板中 ；<br>使用组件时在标签之间填写内容</p><p>2）具名插槽<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuechacao1.jpg" alt><br>解析出来是<code>&lt;header&gt;</code>标签和<code>&lt;footer&gt;</code>标签<br>3）作用域插槽<br>父组件对子组件的内容进行加工和处理<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuechacao2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue常用特性</title>
      <link href="/2019/05/18/11.vue/2.vue%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2019/05/18/11.vue/2.vue%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>表单操作、自定义指令、计算属性、侦听器、过滤器、生命周期</p></blockquote><h1 id="一、表单操作"><a href="#一、表单操作" class="headerlink" title="一、表单操作"></a>一、表单操作</h1><h2 id="1-单选框radio"><a href="#1-单选框radio" class="headerlink" title="1.单选框radio"></a>1.单选框radio</h2><p>先给表单元素设置不同的value<br>v-model设置为同一个,如gender<br><code>data: { gender: 1 }</code></p><h2 id="2-复选框checkbox"><a href="#2-复选框checkbox" class="headerlink" title="2.复选框checkbox"></a>2.复选框checkbox</h2><p>先给表单元素设置不同的value<br>v-model设置为同一个,如hobby<br><code>data: { hobby: [1,2,3] }</code></p><h2 id="3-下拉列表select"><a href="#3-下拉列表select" class="headerlink" title="3.下拉列表select"></a>3.下拉列表select</h2><p>分为单选和多选<br>单选： 给select设置<code>v-model</code> ，给 option设置value<br>多选： select元素设置multiple 数据写成数组</p><h2 id="4-表单域修饰符"><a href="#4-表单域修饰符" class="headerlink" title="4.表单域修饰符"></a>4.表单域修饰符</h2><p>使用方法 <code>v-model.修饰符 = &quot;&quot;</code><br>修饰符可以为以下：<br>number 将表单输入转换为数字<br>trim 将表单输入去掉开始和结尾的空格<br>lazy 将input事件切换为change事件(失去焦点才会触发)</p><h1 id="二、自定义指令directive"><a href="#二、自定义指令directive" class="headerlink" title="二、自定义指令directive"></a>二、自定义指令directive</h1><h2 id="1-为什么需要自定义指令"><a href="#1-为什么需要自定义指令" class="headerlink" title="1.为什么需要自定义指令"></a>1.为什么需要自定义指令</h2><p>内置的13个指令不满足需求时，需要自定义指令<br>v-cloak v-if v-show v-else-if v-else v-for v-once v-html v-text v-pre v-model v-bind v-on</p><h2 id="2-语法规则"><a href="#2-语法规则" class="headerlink" title="2.语法规则"></a>2.语法规则</h2><ul><li>不带参数的自定义指令<br>例如自定义一个获取焦点的指令v-focus：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">el.focus(); <span class="comment">//el表示指令绑定的元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>inserted是钩子函数，关于钩子函数：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/custom-directive.html</a><br>常用的钩子函数： inserted,bind只触发一次；update 可以触发多次<br>钩子函数的参数： el,binding,vnode,oldVnode</p><ul><li><p>带参数的自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">"msg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>,&#123;</span><br><span class="line">bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line"><span class="comment">//binding是一个对象 存放了指令相关的信息 如binding.value就是指令等号后面的值msg</span></span><br><span class="line">el.style.backgroundColor = binding.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">data:&#123; <span class="attr">msg</span>:<span class="string">'red'</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>局部指令<br>是vue实例的一个属性，只在当前实例内可以使用<br>用法也是给元素添加v-focus;<br>可以定义多个指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives： &#123;</span><br><span class="line">focus: &#123;</span><br><span class="line">inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、计算属性computed"><a href="#三、计算属性computed" class="headerlink" title="三、计算属性computed"></a>三、计算属性computed</h1><h2 id="1-为何需要计算属性"><a href="#1-为何需要计算属性" class="headerlink" title="1.为何需要计算属性"></a>1.为何需要计算属性</h2><p>插值表达式的计算逻辑可能比较复杂，计算属性可以使模板更加简洁</p><h2 id="2-计算属性的语法"><a href="#2-计算属性的语法" class="headerlink" title="2.计算属性的语法"></a>2.计算属性的语法</h2><p>computed是vue实例的一个属性，调用方法时不加<code>()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   Hello</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;reverseStr&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  olleH</span><br><span class="line"></span><br><span class="line">data:&#123; msg:"Hello" &#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">reverseStr: function()&#123;</span><br><span class="line">return this.msg.split('').reverse().join('');</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-计算属性和方法的区别"><a href="#3-计算属性和方法的区别" class="headerlink" title="3.计算属性和方法的区别"></a>3.计算属性和方法的区别</h2><p>methods方法不存在缓存；只要调用一次就会执行一次<br>插值表达式调用方法的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;Add()&#125;&#125;</span><br></pre></td></tr></table></figure><p>computed计算属性是基于和数据依赖进行缓存的，输出多次也只计算一次<br>调用内部的方法时不需要加<code>()</code><br>如果计算逻辑比较复杂，可以节省时间<br>一般在算总价，总数时使用</p><h1 id="四、侦听器watch"><a href="#四、侦听器watch" class="headerlink" title="四、侦听器watch"></a>四、侦听器watch</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><p>数据变化时执行异步或开销较大的操作；极少情况下使用<br>侦听属性值的变化</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">要侦听的data属性名: function(val)&#123;</span><br><span class="line">//val是变化后的属性值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、过滤器filter"><a href="#五、过滤器filter" class="headerlink" title="五、过滤器filter"></a>五、过滤器filter</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>格式化数据。比如格式化字符串，格式化日期时间等</p><h2 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'过滤器名称'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//value是要处理的数据</span></span><br><span class="line"><span class="keyword">return</span>  xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; msg | 过滤器名称 &#125;&#125;&lt;/div&gt;    （|： 管道符）</span><br><span class="line">可以级联过滤</span><br><span class="line">&lt;div&gt;&#123;&#123; msg | 过滤器1 | 过滤器2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">可以在绑定属性时添加过滤器</span><br><span class="line">&lt;div v-bind:pp=&quot; msg | 过滤器 &quot;&gt;&lt;/div&gt;</span><br><span class="line">局部过滤器：</span><br><span class="line">和局部指令相似，写在Vue的实例里</span><br><span class="line">过滤器可以传递参数</span><br><span class="line">&lt;div&gt;&#123;&#123; msg | format(1,2,3) &#125;&#125;&lt;/div&gt;  </span><br><span class="line">msg就是value </span><br><span class="line">1,2,3 就是function(value,a,b,c)里的a,b,c</span><br></pre></td></tr></table></figure><h1 id="六、实例的生命周期"><a href="#六、实例的生命周期" class="headerlink" title="六、实例的生命周期"></a>六、实例的生命周期</h1><h2 id="1-实例的不同阶段"><a href="#1-实例的不同阶段" class="headerlink" title="1.实例的不同阶段"></a>1.实例的不同阶段</h2><ul><li>挂载阶段<br>①beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用。<br>②created 在实例创建完成后被立即调用。 一般提前获取数据，在这发ajax<br>③beforeMount 在挂载开始之前被调用。<br>④mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。挂载数据时在这发ajax</li><li>更新阶段<br>⑤beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。<br>⑥updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。</li><li>销毁阶段<br>⑦beforeDestroy 实例销毁之前调用。<br>⑧destroyed 实例销毁后调用。</li></ul><p>方法写在vm的属性里。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">el:<span class="string">"#app"</span>,</span><br><span class="line">data:&#123;...&#125;,</span><br><span class="line">methods:&#123; ... &#125;,</span><br><span class="line">created()&#123;</span><br><span class="line"><span class="comment">//发送ajax请求获取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、vue里的数组API"><a href="#七、vue里的数组API" class="headerlink" title="七、vue里的数组API"></a>七、vue里的数组API</h1><h2 id="1-变异方法-会修改原有数组"><a href="#1-变异方法-会修改原有数组" class="headerlink" title="1.变异方法 会修改原有数组"></a>1.变异方法 会修改原有数组</h2><p><code>push,pop,shift,unshift,splice,sort,reverse</code></p><h2 id="2-替换数组-生成新数组"><a href="#2-替换数组-生成新数组" class="headerlink" title="2.替换数组 生成新数组"></a>2.替换数组 生成新数组</h2><p><code>filter,concat,slice</code></p><h2 id="数组响应式变化"><a href="#数组响应式变化" class="headerlink" title="数组响应式变化"></a>数组响应式变化</h2><p>用索引修改数组，不是响应式的，可以用下面的方式修改<br><code>Vue.set(vm.list,index,&#39;value&#39;)</code><br><code>vm.$set(vm.list,index,&#39;value&#39;)</code><br>第一个参数是要修改的数组，第二个是要修改元素的索引，第三个是想要修改成的值</p><p>对象也有类似的情况。直接给对象添加属性，也不是响应式的；也可以用上面方法处理</p><h1 id="八、图书管理案例："><a href="#八、图书管理案例：" class="headerlink" title="八、图书管理案例："></a>八、图书管理案例：</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/vuebook.jpg" alt><br>过滤器 时间<br>自定义指令 边框颜色<br>侦听器 判断书名重复<br>生命周期 模拟拿数据<br>计算属性 算总数</p><blockquote><p>附：vue实例的生命周期图<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue实例的生命周期"> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue语法基础</title>
      <link href="/2019/05/16/11.vue/1.vue%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/16/11.vue/1.vue%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>渐进式js框架 <a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/index.html</a><br>渐进式： 声明式渲染-&gt;组件系统-&gt;客户端路由-&gt;集中式状态管理vuex-&gt;项目构建</p></blockquote><h1 id="一、vue概述"><a href="#一、vue概述" class="headerlink" title="一、vue概述"></a>一、vue概述</h1><p>易用：熟悉HTML,CSS,JS就可以快速上手<br>灵活：在一个库和一套框架之间自如伸缩<br>高效：20kb运行大小，超快虚拟DOM<br>数据驱动，一切以数据为中心，较少DOM操作</p><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;1 + 2&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">el: <span class="string">"#app"</span>,</span></span><br><span class="line">data: &#123; </span><br><span class="line"><span class="javascript">msg: <span class="string">"Hello world"</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>插值语法可以进行简单计算，还可以写三元表达式，但不能写if,for</li><li>el是element的缩写，值为DOM元素或者CSS选择器</li><li>data:模型数据，是一个对象</li></ul><h1 id="三、Vue模板语法"><a href="#三、Vue模板语法" class="headerlink" title="三、Vue模板语法"></a>三、Vue模板语法</h1><h2 id="1-模板语法概述"><a href="#1-模板语法概述" class="headerlink" title="1.模板语法概述"></a>1.模板语法概述</h2><h3 id="1）前端渲染："><a href="#1）前端渲染：" class="headerlink" title="1）前端渲染："></a>1）前端渲染：</h3><p><code>模板 + 数据 =&gt; 静态HTML</code></p><h3 id="2）前端渲染方式："><a href="#2）前端渲染方式：" class="headerlink" title="2）前端渲染方式："></a>2）前端渲染方式：</h3><p>原生js拼接字符串：较麻烦，不同程序员代码差异性大<br>模板引擎：提供了规范语法，但没有提供事件处理机制<br>Vue模板语法解决了以上问题<br>vue默认具有数据响应式，数据变化会导致页面内容同步变化<br>数据绑定： 将数据填充到标签中</p><h3 id="3）语法组成概览"><a href="#3）语法组成概览" class="headerlink" title="3）语法组成概览"></a>3）语法组成概览</h3><p>插值表达式<br>指令<br>事件绑定<br>属性绑定<br>样式绑定<br>分支循环结构</p><h2 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h2><p>实质： 以v-开始的自定义属性<br><code>&lt;div v-cloak&gt; Hello World! &lt;/div&gt;</code></p><h3 id="1-v-cloak"><a href="#1-v-cloak" class="headerlink" title="1) v-cloak"></a>1) v-cloak</h3><p>此属性保持在元素上，直到关联实例结束编译<br>给插值表达式所在的标签添加此指令(属性)，然后CSS配合<code>[v-cloak]{display:none}</code><br>可以解决插值表达式闪动的问题</p><h3 id="2-数据填充指令"><a href="#2-数据填充指令" class="headerlink" title="2) 数据填充指令"></a>2) 数据填充指令</h3><p><code>v-text=&quot;msg&quot;</code> 填充纯文本 需要赋值 没有闪动问题<br><code>v-html=&quot;msg&quot;</code> 填充HTML 存在安全问题XSS攻击 第三方数据不可使用<br><code>v-pre</code> 填充原始信息 不进行编译</p><h3 id="3-v-once"><a href="#3-v-once" class="headerlink" title="3) v-once"></a>3) v-once</h3><p>v-once只会编译一次，内容确定之后不会响应式变化</p><h2 id="3-双向数据绑定"><a href="#3-双向数据绑定" class="headerlink" title="3.双向数据绑定"></a>3.双向数据绑定</h2><p>使用的指令：v-model<br>双向数据绑定： 数据和页面内容互相影响，同步变化。主要体现在表单输入域中<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/v1.jpg" alt></p><p><code>页面修改数据--&gt; js里面的msg也会变化;js里的msg修改了--&gt;页面数据也会变化</code></p><p>MVVM思想： M:model  V: view  VM: vue提供的view-model</p><h2 id="4-事件绑定"><a href="#4-事件绑定" class="headerlink" title="4. 事件绑定"></a>4. 事件绑定</h2><p>使用的指令：v-on: 简写 @</p><h3 id="1）vue事件绑定方式"><a href="#1）vue事件绑定方式" class="headerlink" title="1）vue事件绑定方式"></a>1）vue事件绑定方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">'事件处理逻辑'</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">简写：<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'事件处理逻辑'</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是事件处理逻辑写在标签内不合适。可以通过函数的形式写在vm的methods里</p><h3 id="2）事件调用方式"><a href="#2）事件调用方式" class="headerlink" title="2）事件调用方式"></a>2）事件调用方式</h3><p>绑定函数名字：<code>&lt;button @click=&#39;add&#39;&gt;点击&lt;/button&gt;</code><br>调用函数：<code>&lt;button @click=&#39;add()&#39;&gt;点击&lt;/button&gt;</code></p><h3 id="3）传递参数"><a href="#3）传递参数" class="headerlink" title="3）传递参数"></a>3）传递参数</h3><p>1.如果是绑定函数名字，默认会传递一个<code>$event</code>作为第一个参数（隐式）<br>2.如果是调用函数，可以手动传递参数<code>$event</code>，只能放在最后（显式）<br>    <code>&lt;button @click=&#39;add(p1,p2,$event)&#39;&gt;点击&lt;/button&gt;</code></p><p><code>此处this指向vm，可以直接拿到data里的数据</code><br><code>methods里的函数不能写箭头函数，有this指向问题</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/vue/v2.jpg" alt></p><h3 id="4）事件修饰符"><a href="#4）事件修饰符" class="headerlink" title="4）事件修饰符"></a>4）事件修饰符</h3><p>阻止事件冒泡： <code>v-on:click.stop=&#39;handle&#39;</code><br>阻止默认行为： <code>v-on:click.prevent=&#39;handle&#39;</code><br>只有本身触发事件才会执行函数： <code>v-on:click.self=&#39;handle&#39;</code><br>可以链式书写，注意有顺序问题<br><code>先prevent后self  v-on:click.prevent.self 会阻止所有的点击事件</code><br><code>先self后prevent  v-on:click.self.prevent 会阻止对元素自身的点击事件</code></p><h3 id="5）按键修饰符"><a href="#5）按键修饰符" class="headerlink" title="5）按键修饰符"></a>5）按键修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tab键： .tab</span><br><span class="line">ESC键： .esc</span><br><span class="line">空格键：.space</span><br><span class="line">方向键：.up .down .left .right</span><br><span class="line">回车键：&lt;input v-on:keyup.enter=&apos;submit&apos;&gt;</span><br><span class="line">delete键：&lt;input v-on:keyup.delete=&apos;handle&apos;&gt;</span><br><span class="line">也可以直接加按键的keycode值</span><br></pre></td></tr></table></figure><h3 id="6）自定义按键修饰符"><a href="#6）自定义按键修饰符" class="headerlink" title="6）自定义按键修饰符"></a>6）自定义按键修饰符</h3><p><code>Vue.config.keyCodes.aaa = 65 //实际上就是给按键起名字</code></p><h2 id="5-属性绑定"><a href="#5-属性绑定" class="headerlink" title="5.属性绑定"></a>5.属性绑定</h2><p>使用的指令 <code>v-bind:</code> 简写 <code>:</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">'url'</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">'url'</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-model双向数据绑定实现原理分析</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span> <span class="attr">v-on:input</span>=<span class="string">"msg=$event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-样式绑定"><a href="#6-样式绑定" class="headerlink" title="6.样式绑定"></a>6.样式绑定</h2><p>使用的指令 <code>v-bind:</code> 简写 <code>:</code></p><h3 id="1）class样式处理："><a href="#1）class样式处理：" class="headerlink" title="1）class样式处理："></a>1）class样式处理：</h3><p>不需要进行样式动态变化时，不用写成这种形式</p><ul><li><p>对象形式：最常用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.active &#123; border: 1px solid #000 &#125;   //css</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //html</span><br><span class="line">data: &#123; isActive : true &#125;   //vue js</span><br></pre></td></tr></table></figure></li><li><p>数组形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.active &#123; border: 1px solid #000 &#125; //css</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //html</span><br><span class="line">data: &#123; activeClass : 'active' &#125;   //vue js</span><br></pre></td></tr></table></figure></li></ul><p>不会覆盖正常写法的类名<br>两种形式可以结合使用，把{}放到[]里<br>简化写法 可以把多个类名定义一个数组存储 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classArr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //html</span><br><span class="line">data: &#123; classArr = ['active','error'] &#125;</span><br></pre></td></tr></table></figure><h3 id="2）style样式处理-行内样式-不常用"><a href="#2）style样式处理-行内样式-不常用" class="headerlink" title="2）style样式处理 (行内样式 不常用)"></a>2）style样式处理 (行内样式 不常用)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">'&#123;border: borderStyle&#125;'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; borderStyle:'1px solid #000' &#125;</span><br></pre></td></tr></table></figure><p>当有多个样式时，可以简化写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">'objStyles'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; objStyles:&#123; border:1px solid #000, width:100px &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以放多个对象<code>&lt;div v-bind:style=&#39;[objStyles,objStyles1]&#39;&gt;&lt;/div&gt;</code></p><h2 id="7-分支循环结构"><a href="#7-分支循环结构" class="headerlink" title="7.分支循环结构"></a>7.分支循环结构</h2><h3 id="1）分支结构"><a href="#1）分支结构" class="headerlink" title="1）分支结构"></a>1）分支结构</h3><p>v-if v-else v-else-if    控制元素是否渲染 不一定在DOM里</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"score&gt;90"</span>&gt;</span> 优秀 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data:&#123; score: 99 &#125;</span><br></pre></td></tr></table></figure><p>v-show 控制元素是否显示 和display作用相同 已经渲染到DOM</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">'flag'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  //此div会隐藏</span><br><span class="line">data:&#123; flag:false &#125;</span><br></pre></td></tr></table></figure><p>v-if和v-show都是看等号后面是true还是false，区别是if会对DOM元素进行增加删除，show只是改变display的值<br>v-show的效率高，不涉及DOM元素的增删操作</p><h3 id="2）循环结构-v-for"><a href="#2）循环结构-v-for" class="headerlink" title="2）循环结构 v-for"></a>2）循环结构 v-for</h3><ul><li>遍历数组 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">'index'</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in arr"</span>&gt;</span>&#123;&#123;item +'---'+ index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">data: &#123;arr：["a","b","c"]&#125;</span><br></pre></td></tr></table></figure></li></ul><p>key:唯一标识 一般是id 方便vue区分元素 提高性能 必须加上</p><ul><li>遍历对象 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">'i'</span> <span class="attr">v-for</span>=<span class="string">"(v,k,i) in obj"</span>&gt;</span>&#123;&#123;v+'---'+k+'---'+i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">data: &#123;obj：&#123;name:"liu",age:18&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>v:值 liu,18<br>k:键 name,age<br>i:索引 0,1</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的安装和使用</title>
      <link href="/2019/05/15/10.git/Git/"/>
      <url>/2019/05/15/10.git/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基础"><a href="#1-Git基础" class="headerlink" title="1. Git基础"></a>1. Git基础</h2><h3 id="1-1-版本管理"><a href="#1-1-版本管理" class="headerlink" title="1.1 版本管理"></a>1.1 版本管理</h3><h4 id="1-1-1-什么是版本管理"><a href="#1-1-1-什么是版本管理" class="headerlink" title="1.1.1 什么是版本管理"></a>1.1.1 什么是版本管理</h4><p>版本管理是一种记录文件变化的方式，以便将来查阅特定版本的文件内容。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/01.png" alt></p><h4 id="1-1-2-人为维护文档版本的问题"><a href="#1-1-2-人为维护文档版本的问题" class="headerlink" title="1.1.2 人为维护文档版本的问题"></a>1.1.2 人为维护文档版本的问题</h4><ol><li><p>文档数量多且命名不清晰导致文档版本混乱</p></li><li><p>每次编辑文档需要复制，不方便</p></li><li><p>多人同时编辑同一个文档，容易产生覆盖</p></li></ol><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/04.png" alt></p><h3 id="1-2-Git-是什么"><a href="#1-2-Git-是什么" class="headerlink" title="1.2 Git 是什么"></a>1.2 Git 是什么</h3><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/19.png" alt></p><h3 id="1-3-Git-安装"><a href="#1-3-Git-安装" class="headerlink" title="1.3 Git 安装"></a>1.3 Git 安装</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a> </p><p>在安装的过程中，所有选项使用默认值即可。</p><h3 id="1-4-Git-基本工作流程"><a href="#1-4-Git-基本工作流程" class="headerlink" title="1.4 Git 基本工作流程"></a>1.4 Git 基本工作流程</h3><table><thead><tr><th>git仓库</th><th>暂存区</th><th>工作目录</th></tr></thead><tbody><tr><td>用于存放提交记录</td><td>临时存放被修改文件</td><td>被Git管理的项目目录</td></tr></tbody></table><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/05.png" alt></p><h3 id="1-5-Git-的使用"><a href="#1-5-Git-的使用" class="headerlink" title="1.5 Git 的使用"></a>1.5 Git 的使用</h3><h4 id="1-5-1-Git-使用前配置"><a href="#1-5-1-Git-使用前配置" class="headerlink" title="1.5.1 Git 使用前配置"></a>1.5.1 Git 使用前配置</h4><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：<code>git config --global user.name 提交人姓名</code></li><li>配置提交人姓名：<code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息：<code>git config --list</code>   </li></ol><p><strong>注意</strong></p><ol><li><p>如果要对配置信息进行修改，重复上述命令即可。</p></li><li><p>配置只需要执行一次。</p></li></ol><h4 id="1-5-2-提交步骤（重要）"><a href="#1-5-2-提交步骤（重要）" class="headerlink" title="1.5.2 提交步骤（重要）"></a>1.5.2 提交步骤（重要）</h4><ol><li><code>git init</code> 初始化git仓库 （只需要一次就行）</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件</li><li><code>git commit -m 提交信息(注释)</code>  向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><h4 id="1-5-2-每次提交必须要做的事"><a href="#1-5-2-每次提交必须要做的事" class="headerlink" title="1.5.2 每次提交必须要做的事"></a>1.5.2 每次提交必须要做的事</h4><ol><li>git add .       添加要提交的文件</li><li>git commit -m ‘登录功能完成’  提交到仓库</li><li>git remote add origin <a href="https://gitee.com/xx/xx.git" target="_blank" rel="noopener">https://gitee.com/xx/xx.git</a>  给仓库取个名字叫 origin</li><li>git push -u origin master   提交到远程仓库</li></ol><h4 id="1-5-3-撤销-了解"><a href="#1-5-3-撤销-了解" class="headerlink" title="1.5.3 撤销(了解)"></a>1.5.3 撤销(了解)</h4><ul><li><p>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code></p></li><li><p>将文件从暂存区中删除： <code>git rm --cached 文件</code></p></li><li><p>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<br><code>git rest --hard commitID(一段乱码)</code> </p></li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/07.png" alt></p><h2 id="2-Git进阶"><a href="#2-Git进阶" class="headerlink" title="2. Git进阶"></a>2. Git进阶</h2><h3 id="2-1-分支"><a href="#2-1-分支" class="headerlink" title="2.1 分支"></a>2.1 分支</h3><p>为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。</p><p>使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/08.png" alt></p><h4 id="2-1-1-分支细分"><a href="#2-1-1-分支细分" class="headerlink" title="2.1.1 分支细分"></a>2.1.1 分支细分</h4><ol><li>主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/06.png" alt></p><ol start="2"><li>、开发分支（develop）：作为开发的分支，基于 master 分支创建。</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/09.png" alt></p><ol start="3"><li>功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</li></ol><p>   <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/10.png" alt></p><p><strong>功能分支 -&gt; 开发分支 -&gt; 主分支</strong></p><h4 id="2-1-2-分支命令"><a href="#2-1-2-分支命令" class="headerlink" title="2.1.2 分支命令"></a>2.1.2 分支命令</h4><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git checkout -b 分支名称</code> 直接创建并且切换分支</li><li><code>git merge 来源分支</code> 合并分支 在master下执行 合并其他分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><h3 id="2-2-暂时保存更改"><a href="#2-2-暂时保存更改" class="headerlink" title="2.2 暂时保存更改"></a>2.2 暂时保存更改</h3><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。</p><p>使用场景：分支临时切换</p><ul><li>存储临时改动：<code>git stash</code></li><li>恢复改动：<code>git stash pop</code></li></ul><h2 id="3-Github（gitee中国）"><a href="#3-Github（gitee中国）" class="headerlink" title="3. Github（gitee中国）"></a>3. Github（gitee中国）</h2><p>在版本控制系统中，大约90%的操作都是在本地仓库中进行的：暂存，提交，查看状态或者历史记录等等。除此之外，如果仅仅只有你一个人在这个项目里工作，你永远没有机会需要设置一个远程仓库。</p><p>只有当你需要和你的开发团队共享数据时，设置一个远程仓库才有意义。你可以把它想象成一个 “文件管理服务器”，利用这个服务器可以与开发团队的其他成员进行数据交换。</p><h3 id="3-1-注册"><a href="#3-1-注册" class="headerlink" title="3.1 注册"></a>3.1 注册</h3><ol><li><p>访问<a href="https://github.com/" target="_blank" rel="noopener">github</a>首页，点击 Sign up 连接。（注册）</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/11.png" alt></p></li><li><p>填写用户名、邮箱地址、GitHub登陆密码</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/12.png" alt></p></li><li><p>选择计划</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/13.png" alt></p></li><li><p>填写 GitHub 问题</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/14.png" alt></p></li><li><p>验证邮箱</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/15.png" alt></p></li><li><p>GitHub 个人中心</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/16.png" alt></p></li></ol><h3 id="3-2-多人协作开发流程"><a href="#3-2-多人协作开发流程" class="headerlink" title="3.2 多人协作开发流程"></a>3.2 多人协作开发流程</h3><ul><li>A在自己的计算机中创建本地仓库</li><li>A在github中创建远程仓库</li><li>A将本地仓库推送到远程仓库</li><li>B克隆远程仓库到本地进行开发</li><li>B将本地仓库中开发的内容推送到远程仓库</li><li>A将远程仓库中的最新内容拉去到本地</li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/20.png" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/21.png" alt></p><h3 id="3-3-创建仓库"><a href="#3-3-创建仓库" class="headerlink" title="3.3 创建仓库"></a>3.3 创建仓库</h3><ol><li><p>填写仓库基本信息</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/17.png" alt></p></li><li><p>将本地仓库推送到远程仓库</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/18.png" alt></p><ol><li><p>git push 远程仓库地址 分支名称</p></li><li><p>git push 远程仓库地址别名 分支名称</p></li><li><p>git push -u 远程仓库地址别名 分支名称</p><p> -u 记住推送地址及分支，下次推送只需要输入git push即可</p></li><li><p>git remote add 远程仓库地址别名 远程仓库地址</p></li></ol></li></ol><h3 id="3-4-拉取操作"><a href="#3-4-拉取操作" class="headerlink" title="3.4 拉取操作"></a>3.4 拉取操作</h3><h4 id="3-4-1-克隆仓库"><a href="#3-4-1-克隆仓库" class="headerlink" title="3.4.1 克隆仓库"></a>3.4.1 克隆仓库</h4><p>克隆远端数据仓库到本地：<code>git clone 仓库地址</code></p><h4 id="3-4-2-拉取远程仓库中最新的版本"><a href="#3-4-2-拉取远程仓库中最新的版本" class="headerlink" title="3.4.2 拉取远程仓库中最新的版本"></a>3.4.2 拉取远程仓库中最新的版本</h4><p>拉取远程仓库中最新的版本：<code>git pull 远程仓库地址 分支名称</code></p><h3 id="3-5-解决冲突"><a href="#3-5-解决冲突" class="headerlink" title="3.5 解决冲突"></a>3.5 解决冲突</h3><p>在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。</p><h3 id="3-6-跨团队协作"><a href="#3-6-跨团队协作" class="headerlink" title="3.6 跨团队协作"></a>3.6 跨团队协作</h3><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h3 id="3-7-ssh免登陆"><a href="#3-7-ssh免登陆" class="headerlink" title="3.7 ssh免登陆"></a>3.7 ssh免登陆</h3><p>码云配置ssh文档：<a href="https://gitee.com/help/articles/4181" target="_blank" rel="noopener">https://gitee.com/help/articles/4181</a><br>配置ssh公钥私钥<br>   https协议仓库地址：<a href="https://github.com/itcast-frontEnd/git-demo.git" target="_blank" rel="noopener">https://github.com/itcast-frontEnd/git-demo.git</a></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/22.png" alt></p><p>生成秘钥：<code>ssh-keygen</code></p><p>秘钥存储目录：C:\Users\用户\.ssh</p><p>公钥名称：id_rsa.pub</p><p>私钥名称：id_rsa</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/23.png" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/git/24.png" alt></p><h3 id="3-8-GIT忽略清单"><a href="#3-8-GIT忽略清单" class="headerlink" title="3.8 GIT忽略清单"></a>3.8 GIT忽略清单</h3><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>文件名称：<strong>.gitignore</strong></p><p>将工作目录中的文件全部添加到暂存区：<code>git add .</code></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6常用语法</title>
      <link href="/2019/05/13/9.nodeJs/2.ES6%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/13/9.nodeJs/2.ES6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-let和const声明变量"><a href="#1-let和const声明变量" class="headerlink" title="1.let和const声明变量"></a>1.let和const声明变量</h2><p>使用var定义的变量存在 预解析 变量提升 的问题；<br>使用var定义的变量没有块级{}作用域，容易造成变量污染</p><p>用let定义的变量 不会产生变量提升 只能先定义再使用；会产生块级作用域，在{}之外不能访问<br>用const声明的常量 除了具有let的特点外 必须要给初始值 且不能被重新赋值 </p><h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><ul><li><p>从对象中把属性解放出来，当做变量来使用。语法：    <code>let {属性名1, 属性名2} = 对象名</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">name = <span class="string">"liuxiao"</span>,</span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:username,age&#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(username)  <span class="comment">//name可以重命名为username</span></span><br></pre></td></tr></table></figure></li><li><p>数组的解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h2><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形参) =&gt; &#123;函数体&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数实际上是一个匿名函数，没有函数名，没有function关键字<br>箭头函数内部的this永远指向外部的this<br>也可以给箭头函数起名字： let Add = (形参) =&gt; {函数体};</p><p>箭头函数的变体： </p><ul><li>1.如果左侧形参只有一个，左侧的 () 可以省略</li><li>2.如果右侧函数体代码只有一行，右侧的 {} 可以省略，默认会返回执行结果，不能再添加return</li><li>3.如果满足上面两个条件，可以同时省略 () 和 {}</li></ul><h2 id="4-定义对象中的属性和方法的快捷方式"><a href="#4-定义对象中的属性和方法的快捷方式" class="headerlink" title="4.定义对象中的属性和方法的快捷方式"></a>4.定义对象中的属性和方法的快捷方式</h2><p>语法： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"zs"</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;name,age,show,say()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>对象的属性名 和 变量名相同时，不用再写一次变量名，相当于”name”:name 省略成name ; 方法同理<br>对象内定义方法时 <code>say(){}</code> 相当于<code>say: function(){}</code></p><h2 id="5-对象Object的方法"><a href="#5-对象Object的方法" class="headerlink" title="5.对象Object的方法"></a>5.对象Object的方法</h2><ul><li><p>assign合并对象，返回新对象。如果属性名有重复，括号内 后面的会覆盖前面的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj1,obj2...)</span><br></pre></td></tr></table></figure></li><li><p>获取新数组，keys是对象属性的数组，values是对象属性值的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6.数组的方法"></a>6.数组的方法</h2><p><code>let arr = [1,2,3,4];</code></p><ul><li><p>forEach遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>map遍历数组，且返回值是数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//newArr=[2,4,6,8]</span></span><br></pre></td></tr></table></figure></li><li><p>filter遍历数组，且返回值是满足return后面条件的元素组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//newArr=[3,4]</span></span><br></pre></td></tr></table></figure></li><li><p>some遍历数组，且返回值是bool，遇到return true就停止循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = arr.some(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item==<span class="number">2</span></span><br><span class="line">&#125;)<span class="comment">//bool=true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-扩展运算符"><a href="#7-扩展运算符" class="headerlink" title="7. 扩展运算符"></a>7. 扩展运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr,...arr2] <span class="comment">//[1,2,3,'a','b','c']</span></span><br></pre></td></tr></table></figure><p>对象同样适用</p><h2 id="8-ES6模板字符串"><a href="#8-ES6模板字符串" class="headerlink" title="8.ES6模板字符串"></a>8.ES6模板字符串</h2><p>之前使用JavaScript拼接字符串时，需要使用大量的引号和 + 来拼接才能得到我们需要的模版。<br>ES6中提供了模版字符串，用<code>`</code>（反引号）标识，用${变量}将变量括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`I am $&#123;name&#125;.`</span><br></pre></td></tr></table></figure><p>由于反引号是模版字符串的标识，如果需要在字符串中使用反引号，就要对其进行转义，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`No matter\` what you do,</span><br><span class="line">I trust you.`</span><br></pre></td></tr></table></figure><p>注意：模板字符串中的换行和空格都会原样输出</p><ul><li><p>在${}中的大括号里可以放入任意的JavaScript表达式，还可以进行运算，以及引用对象属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x=88;</span><br><span class="line">var y=100;</span><br><span class="line">console.log(`x=$&#123;++x&#125;,y=$&#123;x+y&#125;`);</span><br></pre></td></tr></table></figure></li><li><p>更强大的是：模版字符串还可以调用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function string()&#123;</span><br><span class="line">return &quot;i likes es6!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(`你想说什么? </span><br><span class="line">嗯，$&#123;string()&#125;`);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExpressCRUD博客项目</title>
      <link href="/2019/05/12/9.nodeJs/8.ExpressCRUD%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/05/12/9.nodeJs/8.ExpressCRUD%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MVC开发思想"><a href="#1-MVC开发思想" class="headerlink" title="1.MVC开发思想"></a>1.MVC开发思想</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/mvc.jpg" alt="MVC架构"></p><h2 id="2-nodejs引入公共模块语法"><a href="#2-nodejs引入公共模块语法" class="headerlink" title="2.nodejs引入公共模块语法"></a>2.nodejs引入公共模块语法</h2><p><code>&lt;%- include(&#39;./layout/header.ejs&#39;)%&gt;</code><br>引入后是html片段</p><h2 id="3-格式化日期模块moment"><a href="#3-格式化日期模块moment" class="headerlink" title="3.格式化日期模块moment"></a>3.格式化日期模块moment</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i moment -S</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="keyword">const</span> time = moment.format(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>);</span><br></pre></td></tr></table></figure><h2 id="4-session模块"><a href="#4-session模块" class="headerlink" title="4.session模块"></a>4.session模块</h2><p>可用于判断登录状态和存储用户信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i express-session -S</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">secret: <span class="string">"加密字段"</span>,</span><br><span class="line">resave: <span class="literal">false</span>,</span><br><span class="line">saveUninitialized: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="5-markdown富文本编辑器Mditor"><a href="#5-markdown富文本编辑器Mditor" class="headerlink" title="5.markdown富文本编辑器Mditor"></a>5.markdown富文本编辑器Mditor</h2><ul><li><p>1.安装npm包：<br><code>npm i mditor -S</code></p></li><li><p>2.引入css和js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/node_modules/mditor/dist/css/mditor.min.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"/node_modules/mditor/dist/js/mditor.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>3.html里添加textarea标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"editor"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>4.初始化编辑器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mditor = Mditor.fromTextarea(<span class="built_in">document</span>.getElementById(<span class="string">"editor"</span>));</span><br><span class="line"><span class="comment">//获取或设置编辑器的默认值，非必须步骤</span></span><br><span class="line">mditor.on(<span class="string">'ready'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(mditor.value);</span><br><span class="line">mditor.value = <span class="string">' ** hello ** '</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-使用隐藏域存放用户Id"><a href="#6-使用隐藏域存放用户Id" class="headerlink" title="6.使用隐藏域存放用户Id"></a>6.使用隐藏域存放用户Id</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在进入文章添加页面的一瞬间，就立即把 文章的 作者Id，保存到 一个隐藏域中，防止 session 失效的问题 --&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;authorId&quot; value=&quot;&lt;%= user.id %&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>存放要发送的属性可以使用以下方法： 存在隐藏域一起发ajax，session，自定义属性，localStorage</p><h2 id="7-把markdown转换为html"><a href="#7-把markdown转换为html" class="headerlink" title="7.把markdown转换为html"></a>7.把markdown转换为html</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i marked -S</span><br><span class="line">cosnt marked = <span class="built_in">require</span>(<span class="string">"marked"</span>)</span><br><span class="line"><span class="keyword">const</span> html = marked(<span class="string">"文本内容"</span>)</span><br></pre></td></tr></table></figure><h2 id="8-ejs模板引擎里输出语句"><a href="#8-ejs模板引擎里输出语句" class="headerlink" title="8.ejs模板引擎里输出语句"></a>8.ejs模板引擎里输出语句</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 识别文本 %&gt;</span><br><span class="line">&lt;%- 识别HTML标签 %&gt;</span><br></pre></td></tr></table></figure><h2 id="9-模板引擎输出的特性"><a href="#9-模板引擎输出的特性" class="headerlink" title="9.模板引擎输出的特性"></a>9.模板引擎输出的特性</h2><p>模板引擎渲染页面时，只要看到输出语句就会输出，无论输出语句的位置在哪，就算在点击事件里，不点击时也会输出</p><h2 id="10-开启执行多条sql语句的功能"><a href="#10-开启执行多条sql语句的功能" class="headerlink" title="10.开启执行多条sql语句的功能"></a>10.开启执行多条sql语句的功能</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="keyword">const</span> conn = mysql.createConnection(&#123;</span><br><span class="line">host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">user: <span class="string">"root"</span>,</span><br><span class="line">password: <span class="string">"root"</span>,</span><br><span class="line">database: <span class="string">"mysql_001"</span>,</span><br><span class="line">multipleStatements: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="11-分页公式"><a href="#11-分页公式" class="headerlink" title="11.分页公式"></a>11.分页公式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$offset = ($currentPage<span class="number">-1</span>)*$pageSize</span><br><span class="line">select * <span class="keyword">from</span> posts limit $offset,$pageSize</span><br></pre></td></tr></table></figure><h2 id="12-加密算法"><a href="#12-加密算法" class="headerlink" title="12.加密算法"></a>12.加密算法</h2><p>md5/sha1/bcryptjs<br>使用bcryptjs</p><ul><li><ol><li>运行 <code>npm i node-pre-gyp -g</code> </li></ol></li><li><ol start="2"><li>在项目根目录中，打开终端，运行 <code>cnpm install bcrypt -S</code></li></ol></li><li><ol start="3"><li>导入 <code>bcrypt</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入加密的模块</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="4"><li>定义幂次：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 幂次</span></span><br><span class="line"><span class="keyword">const</span> saltRounds = <span class="number">10</span>    <span class="comment">// 2^10</span></span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="5"><li>调用 <code>bcrypt.hash()</code> 加密：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密的方法</span></span><br><span class="line">bcrypt.hash(<span class="string">'123'</span>, saltRounds, (err, pwdCryped) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(pwdCryped)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="6"><li>调用<code>bcrypt.compare()</code>对比密码是否正确：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 对比 密码的方法</span></span><br><span class="line">bcrypt.compare(<span class="string">'123'</span>,<span class="string">'$2b$10$i1ufUKnC9fXTsF9oqqvLMeDnpNfYIvhyqKRG03adiebNFPkjW3HPW'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="comment">// 内部对比的过程：</span></span><br><span class="line">     <span class="comment">// 1. 先获取 输入的明文</span></span><br><span class="line">     <span class="comment">// 2. 获取输入的密文</span></span><br><span class="line">     <span class="comment">// 2.1 从密文中，解析出来  bcrypt 算法的 版本号</span></span><br><span class="line">     <span class="comment">// 2.2 从密文中，解析出来 幂次</span></span><br><span class="line">     <span class="comment">// 2.3 从密文中，解析出来前 22 位 这个随机盐</span></span><br><span class="line">     <span class="comment">// 3. compare 方法内部，调用 类似于 hash 方法 把 明文，幂次，随机盐 都传递进去     最终得到正向加密后的密文</span></span><br><span class="line">     <span class="comment">// 4. 根据最新得到的密文，和 compare 提供的密文进行对比，如果相等，则 返回 true ，否则返回 false;</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于node的Express框架</title>
      <link href="/2019/05/04/9.nodeJs/7.Express%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/05/04/9.nodeJs/7.Express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>使用基于nodejs的web开发框架搭建web应用，常用的nodejs框架有Express,koa,egg</p><h1 id="一、express的安装和使用"><a href="#一、express的安装和使用" class="headerlink" title="一、express的安装和使用"></a>一、express的安装和使用</h1><h2 id="1-安装方法"><a href="#1-安装方法" class="headerlink" title="1.安装方法"></a>1.安装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y //初始化npm</span><br><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure><h2 id="2-创建基本Express-web服务器"><a href="#2-创建基本Express-web服务器" class="headerlink" title="2.创建基本Express web服务器"></a>2.创建基本Express web服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//处理get请求</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// res.send('你好，世界'); //express封装的，可以输出中文</span></span><br><span class="line">    res.sendFile(path.join(__dirname, <span class="string">'./views/home.html'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(<span class="string">'./views'</span>));</span><br><span class="line"><span class="comment">//处理post请求</span></span><br><span class="line"><span class="comment">// app.post('/login', (req, res) =&gt; &#123;&#125;)</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sever running at http://localhost:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>地址栏和get里的路径一一对应即可，不一定要加后缀名</p><h2 id="3-express快捷方法"><a href="#3-express快捷方法" class="headerlink" title="3.express快捷方法"></a>3.express快捷方法</h2><h3 id="1-res-send"><a href="#1-res-send" class="headerlink" title="1. res.send()"></a>1. res.send()</h3><ol><li>支持 发送 字符串 Content-Type: text/html;</li><li>支持 发送 对象 或 数组 Content-Type: application/json</li><li>支持 发送 Buffer 此时会当作文件下载</li></ol><h3 id="2-res-sendFile"><a href="#2-res-sendFile" class="headerlink" title="2. res.sendFile()"></a>2. res.sendFile()</h3><p>   用法1：<code>res.sendFile(path.join(__dirname, &#39;./view/index.html&#39;)</code><br>   用法2：<code>res.sendFile(&#39;./view/movie.html&#39;, { root: __dirname })</code><br>   可以用于向浏览器发送静态页面</p><h3 id="3-res-redirect"><a href="#3-res-redirect" class="headerlink" title="3.res.redirect()"></a>3.res.redirect()</h3><p>重定向页面</p><h1 id="二、使用express-static托管静态文件"><a href="#二、使用express-static托管静态文件" class="headerlink" title="二、使用express.static托管静态文件"></a>二、使用express.static托管静态文件</h1><h2 id="1-为什么要托管静态文件："><a href="#1-为什么要托管静态文件：" class="headerlink" title="1.为什么要托管静态文件："></a>1.为什么要托管静态文件：</h2><p>当有很多静态页面时，使用res.sendFile返回页面比较麻烦</p><h2 id="2-托管方法"><a href="#2-托管方法" class="headerlink" title="2.托管方法"></a>2.托管方法</h2><p>app.use() 方法，是专门用来注册中间件；<br>express.static 是express的内置中间件；</p><p>语法1：不加虚拟目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&apos;./views&apos;))</span><br></pre></td></tr></table></figure><p>语法2：加虚拟目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(&apos;/虚拟目录&apos;,express.static(&apos;./views&apos;))</span><br></pre></td></tr></table></figure><p>这样访问的时候要在目录之前加上虚拟目录的名字</p><h1 id="三、express使用ejs模板引擎渲染页面"><a href="#三、express使用ejs模板引擎渲染页面" class="headerlink" title="三、express使用ejs模板引擎渲染页面"></a>三、express使用ejs模板引擎渲染页面</h1><h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h2><ol><li>安装 ejs 模板引擎 npm i ejs -S</li><li>配置模板引擎类型 app.set(‘view engine’, ‘ejs’)</li><li>配置模板文件的存放路径 app.set(‘views’, ‘./ejs_pages’)</li><li>在请求处理函数里，使用 res.render() 来渲染模板页面<br> res.render(‘index.ejs’, { 要渲染的数据对象 })<br> 注意，模板页面的 后缀名，可以省略不写<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>); <span class="comment">//设置模板引擎类型</span></span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./ejs_pages'</span>); <span class="comment">//设置模板文件目录</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(<span class="string">'index.ejs'</span>, &#123;</span><br><span class="line">        name: <span class="string">'liuxiao'</span>,</span><br><span class="line">        age: <span class="number">19</span>,</span><br><span class="line">        hobby: [<span class="string">'吃饭'</span>, <span class="string">'睡觉'</span>, <span class="string">'打豆豆'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/abc'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(<span class="string">'abc.ejs'</span>, &#123;</span><br><span class="line">        food: <span class="string">'^(*￣(oo)￣)^'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server is running at http://localhost:3000/`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>ejs页面里可以直接使用传递过来的数据，语法和art-template的原生语法相同</p><h1 id="四、使用express路由分发请求"><a href="#四、使用express路由分发请求" class="headerlink" title="四、使用express路由分发请求"></a>四、使用express路由分发请求</h1><p>请求地址到处理函数之间的对应关系就称为后端路由</p><h2 id="1-使用路由模块分发请求"><a href="#1-使用路由模块分发请求" class="headerlink" title="1.使用路由模块分发请求"></a>1.使用路由模块分发请求</h2><p>新建一个router.js路由模块，负责创建路由对象并导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 封装单独的 router.js 路由模块文件</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/movie'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/about'</span>, (req, res)=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>需要使用路由的文件引入router.js模块并且 app.use(router)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入自己的路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'./router.js'</span>)</span><br><span class="line"><span class="comment">// 使用 app.use() 来注册路由</span></span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure><h1 id="五、express中间件的概念"><a href="#五、express中间件的概念" class="headerlink" title="五、express中间件的概念"></a>五、express中间件的概念</h1><p>之前说到app.use是注册中间件用的，什么是中间件呢？</p><h2 id="1-什么是中间件"><a href="#1-什么是中间件" class="headerlink" title="1.什么是中间件"></a>1.什么是中间件</h2><p>中间件就是一个处理函数，形参包含三个参数： req,res,next<br>req:请求对象，res:响应对象，next:调用下一个中间件</p><ul><li>只要地址栏发送了请求就会执行中间件</li><li>想要继续执行中间件，必须在函数内调用next()方法</li><li>req,res在nodejs不同的中间件里都是同一个对象</li></ul><h2 id="2-express中间件的分类"><a href="#2-express中间件的分类" class="headerlink" title="2.express中间件的分类"></a>2.express中间件的分类</h2><p>1) 应用级别的中间件：挂载到 app 上的中间件<br>    <code>app.get(&#39;url地址&#39;, （req, res, next）=&gt; {})</code><br>2) 路由级别的中间件：挂载到 router 对象上的中间件<br>    <code>router.get(&#39;url地址&#39;, (req, res, next)=&gt;{})</code><br>3) 错误级别的中间件：回调函数中，有四个参数<br>    <code>app.use((err, req, res, next)=&gt;{})</code><br>4) 唯一内置的中间件： <code>express.static()</code>托管静态文件使用<br>5) 第三方中间件：非express框架提供的，需要程序员手动安装才能使用的中间件； –最常用<br>    <code>body-parser</code> 解析post 表单数据</p><blockquote><p>中间件的概念，了解即可，因为实际开发中，我们都直接使用第三方现成的</p></blockquote><h1 id="六、express操作mysql数据库"><a href="#六、express操作mysql数据库" class="headerlink" title="六、express操作mysql数据库"></a>六、express操作mysql数据库</h1><p>使用express对mysql数据进行增删改查</p><h2 id="1-安装数据库模块"><a href="#1-安装数据库模块" class="headerlink" title="1.安装数据库模块"></a>1.安装数据库模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mysql --save</span><br></pre></td></tr></table></figure><h2 id="2-导入mysql模块"><a href="#2-导入mysql模块" class="headerlink" title="2.导入mysql模块"></a>2.导入mysql模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;)</span><br></pre></td></tr></table></figure><h2 id="3-创建连接对象"><a href="#3-创建连接对象" class="headerlink" title="3.创建连接对象"></a>3.创建连接对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const conn  = mysql.createConnection(&#123;</span><br><span class="line">host:&apos;主机名&apos;</span><br><span class="line">user:&apos;用户名&apos;</span><br><span class="line">password:&apos;密码&apos;</span><br><span class="line">database:&apos;数据库名&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-执行Sql语句"><a href="#4-执行Sql语句" class="headerlink" title="4.执行Sql语句"></a>4.执行Sql语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.query(&apos;sql语句&apos;,(err,result)&#123;</span><br><span class="line">console.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>新增语句<br>使用？占位符 + 数据对象实现：只在node的mysql语句支持（但是以前的sql语句也可以使用）<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express1.jpg" alt></p></li><li><p>修改语句<br>如果有多个？占位符；数据对象有多个，要使用数组形式传递<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express2.jpg" alt></p></li></ul><h1 id="七、Express获取参数"><a href="#七、Express获取参数" class="headerlink" title="七、Express获取参数"></a>七、Express获取参数</h1><p>获取地址栏参数：例如 <code>http://127.0.0.1:3000?name=liu&amp;age=18/</code></p><h2 id="1-使用req-query获取参数"><a href="#1-使用req-query获取参数" class="headerlink" title="1.使用req.query获取参数"></a>1.使用req.query获取参数</h2><p>req.query获取查询参数（查询参数：直接在地址栏后面拼接的参数）<br>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express3.jpg" alt><br>获取到查询参数：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express4.jpg" alt></p><h2 id="2-使用req-params获取参数"><a href="#2-使用req-params获取参数" class="headerlink" title="2.使用req.params获取参数"></a>2.使用req.params获取参数</h2><p>req.params获取路径参数<br>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express5.jpg" alt></p><p>获取到参数： 加：表示此处是一个参数<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express6.jpg" alt></p><h2 id="3-从post表单获取提交的数据"><a href="#3-从post表单获取提交的数据" class="headerlink" title="3.从post表单获取提交的数据"></a>3.从post表单获取提交的数据</h2><p>postman发送请求：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express7.jpg" alt></p><p>1）需要借助body-parser中间件，先安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i body-parser -S</span><br></pre></td></tr></table></figure><p>2）在处理post请求之前注册中间件：<br>3）在请求处理函数里使用req.body获取post提交的数据：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/express8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用node构建web服务器</title>
      <link href="/2019/05/04/9.nodeJs/6.%E4%BD%BF%E7%94%A8node%E6%9E%84%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/05/04/9.nodeJs/6.%E4%BD%BF%E7%94%A8node%E6%9E%84%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建基本的web服务器"><a href="#一、创建基本的web服务器" class="headerlink" title="一、创建基本的web服务器"></a>一、创建基本的web服务器</h1><h2 id="1-引用http模块"><a href="#1-引用http模块" class="headerlink" title="1.引用http模块"></a>1.引用http模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure><h2 id="2-创建服务器"><a href="#2-创建服务器" class="headerlink" title="2.创建服务器"></a>2.创建服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br></pre></td></tr></table></figure><h2 id="3-绑定监听事件"><a href="#3-绑定监听事件" class="headerlink" title="3.绑定监听事件"></a>3.绑定监听事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">//设置编码格式</span></span><br><span class="line">res.writeHeader(<span class="number">200</span>, &#123;</span><br><span class="line"><span class="string">'content-type'</span>: <span class="string">"text/html;charset=utf-8"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//服务器返回结果，结束本次响应</span></span><br><span class="line">res.end(<span class="string">'你好，世界'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>req存储了用户请求时发送的相关参数；<br>  req.url : 客户端访问的url，获取的是端口号之后的，包括/</li><li>res是服务器返回使用的对象；<br>  res.writeHeader里面可以设置浏览器解析结果的格式。mime类型<br>  content type可以为以下值<ul><li>text/html 浏览器把结果当做html解析</li><li>text/css 浏览器把结果当做css解析</li><li>text/plain 浏览器把结果当做普通文本解析<br>res.end()里面要进行相应的修改</li></ul></li></ul><h2 id="4-开启服务器"><a href="#4-开启服务器" class="headerlink" title="4.开启服务器"></a>4.开启服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"server running at http://localhost:3000/"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="二、根据请求URL返回不同页面"><a href="#二、根据请求URL返回不同页面" class="headerlink" title="二、根据请求URL返回不同页面"></a>二、根据请求URL返回不同页面</h1><p>nodejs返回页面必须手动写代码，读取并返回</p><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>req.url可以得到客户端访问的url<br>根据url返回不同的页面<br>可以借助fs.readFile读文件返回页面内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.url === <span class="string">'/'</span> || req.url === <span class="string">'/index.html'</span>) &#123;</span><br><span class="line">fs.readFile(path.join(__dirname, <span class="string">'views/index.html'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以不写utf-8，因为res.end可以接收二进制<br>当接收二进制时，就不需要设置writeHeader了<br>res.end接收两种数据类型： string和二进制类型</p><h2 id="2-服务器处理CSS和js文件"><a href="#2-服务器处理CSS和js文件" class="headerlink" title="2.服务器处理CSS和js文件"></a>2.服务器处理CSS和js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/css/1.css'</span>) &#123;</span><br><span class="line">fs.readFile(path.join(__dirname, <span class="string">'/css/1.css'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/js/1.js'</span>) &#123;</span><br><span class="line">        fs.readFile(path.join(__dirname, <span class="string">'/js/1.js'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span> + err.message)</span><br><span class="line">            res.end(buf);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-简化改造"><a href="#3-简化改造" class="headerlink" title="3.简化改造"></a>3.简化改造</h2><p>path.join直接和req.url拼接，不再去单独判断。但是这样做客户端访问时必须在相应目录下有文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改造之后访问的地址必须在相应目录下有文件</span></span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/'</span>) req.url = <span class="string">'/views/index.html'</span></span><br><span class="line">    fs.readFile(path.join(__dirname, req.url), <span class="function"><span class="keyword">function</span> (<span class="params">err, buf</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'404'</span> + err.message)</span><br><span class="line">        res.end(buf);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm</title>
      <link href="/2019/05/03/9.nodeJs/5.NPM/"/>
      <url>/2019/05/03/9.nodeJs/5.NPM/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm-的两层含义"><a href="#1-npm-的两层含义" class="headerlink" title="1.npm 的两层含义"></a>1.npm 的两层含义</h2><ol><li>NPM 是一个 第三方模块的托管网站，指的就是<code>https://www.npmjs.com/</code></li><li>NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具</li></ol><h2 id="2-安装和卸载全局包"><a href="#2-安装和卸载全局包" class="headerlink" title="2.安装和卸载全局包"></a>2.安装和卸载全局包</h2><ol><li>什么是全局的包：安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问</li><li>如何安装全局包：运行 <code>npm install 包名 -g</code> 即可；其中 <code>-g</code> 参数，表示 把包安装到全局目录中的意思</li><li>全局包的安装目录：<code>C:\Users\用户目录\AppData\Roaming\npm</code></li><li>什么样的包适合安装到全局：工具性质的包，适合安装到全局</li><li>如何卸载全局包：运行<code>npm uninstall 包名 -g</code>即可<br>例如 i5ting_toc：把markdown转成Html文件的工具</li></ol><h2 id="3-安装和卸载本地包"><a href="#3-安装和卸载本地包" class="headerlink" title="3. 安装和卸载本地包"></a>3. 安装和卸载本地包</h2><ol><li>什么是本地包：跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下；</li><li>注意：如果拿到一个空项目，必须在当前项目根目录中，先运行 <code>npm init</code>或者<code>npm init -y</code> 命令，初始化一个<code>package.json</code>的配置文件，否则包无法安装到本地项目中；</li><li>如何安装本地包：运行<code>npm i 包名 --save</code> 即可安装本地包；<ul><li>如果大家用的是npm 5.x的版本，可以不指定<code>--save</code>命令，如果用的是 npm 3.x 的版本，则需要手动指定 <code>--save</code>；</li></ul></li><li><code>package-lock.json</code>文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验；</li><li>如何卸载本地包：使用 <code>npm uninstall/remove 包名 -S/-D</code>即可卸载指定的本地包；</li></ol><h2 id="4-其它常用命令"><a href="#4-其它常用命令" class="headerlink" title="4. 其它常用命令"></a>4. 其它常用命令</h2><ol><li><code>--save</code> 的缩写是 <code>-S</code> 在dependencies下记录 代码开发和上线都要用</li><li><code>--save-dev</code>的缩写是 <code>-D</code> 在devDependencies下记录 开发阶段用</li><li><code>install</code> 的缩写是 <code>i</code> </li><li>注意：当使用 <code>npm i</code>快速装包的时候，npm会检查<code>package.json</code>文件中，所有的依赖项，然后都为我们安装到项目中</li><li><code>--production</code> 表示只安装 <code>dependencies</code> 节点下记录的包，不安装<code>devDependencies</code>节点下的包；当项目要上线了，才会使用<code>--production</code>命令</li></ol><h2 id="5-解决-npm-下载慢问题"><a href="#5-解决-npm-下载慢问题" class="headerlink" title="5. 解决 npm 下载慢问题"></a>5. 解决 npm 下载慢问题</h2><ol><li>默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以全局安装一个的工具，叫做 <code>cnpm</code></li><li>如何安装<code>cnpm</code>：运行 <code>npm i cnpm -g</code> 即可；</li><li>如何使用<code>cnpm</code>：在装包的时候，只需要把 <code>npm</code> 替换成 <code>cnpm</code> 即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node模块和包介绍</title>
      <link href="/2019/05/03/9.nodeJs/4.node%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/03/9.nodeJs/4.node%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、模块成员的分类"><a href="#一、模块成员的分类" class="headerlink" title="一、模块成员的分类"></a>一、模块成员的分类</h1><h2 id="1-核心模块"><a href="#1-核心模块" class="headerlink" title="1.核心模块"></a>1.核心模块</h2><ol><li><strong>什么是核心模块：</strong><ul><li>随着Node.js的安装包，一同安装到本地的模块，叫做核心模块；</li><li>例如：<code>fs</code>，<code>path</code>等模块，都是由Node.js官方提供的核心模块；</li><li>只要安装了Node这个应用程序，那么就已经安装了所有的 核心模块；</li></ul></li><li><strong>如何使用核心模块</strong>：<ul><li><code>require(&#39;核心模块标识符&#39;)</code></li></ul></li></ol><h2 id="2-第三方模块"><a href="#2-第三方模块" class="headerlink" title="2.第三方模块"></a>2.第三方模块</h2><ol><li><strong>什么是第三方模块：</strong><ul><li>一些非官方提供的模块，叫做第三方模块；</li><li>注意，第三方模块，并不在我们的计算机上；</li><li>如果需要使用某些第三方模块，必须去<code>NPM</code> 的网站上搜索并下载才能使用；</li></ul></li><li><strong>如何使用第三方模块：</strong><ul><li>先从 npm 官网上下载指定的第三方模块</li><li>使用 <code>require(&#39;第三方模块的名称标识符&#39;)</code>来导入这个模块</li><li>根据 第三方模块的 官方文档使用</li></ul></li></ol><h2 id="3-用户自定义模块"><a href="#3-用户自定义模块" class="headerlink" title="3.用户自定义模块"></a>3.用户自定义模块</h2><ol><li><strong>什么是用户模块：</strong><ul><li>程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块；</li></ul></li><li><strong>如何使用用户模块：</strong><ul><li><code>require(&#39;路径标识符&#39;)</code></li></ul></li></ol><h1 id="二、包的定义和使用"><a href="#二、包的定义和使用" class="headerlink" title="二、包的定义和使用"></a>二、包的定义和使用</h1><h2 id="1-什么是包"><a href="#1-什么是包" class="headerlink" title="1.什么是包"></a>1.什么是包</h2><ol><li>英文名叫做 <code>Packages</code>，包是在模块基础上更深一步的抽象；</li><li>包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库；</li><li>包可以看作是 <strong>模块</strong>、<strong>代码</strong> 和 <strong>其它资源</strong> 组合起来形成的 独立作用域；</li></ol><h2 id="2-规范的包结构"><a href="#2-规范的包结构" class="headerlink" title="2.规范的包结构"></a>2.规范的包结构</h2><p>前三个必须遵守</p><ol><li><strong>包都要以一个单独的目录而存在</strong>；</li><li><strong><code>package.json</code> 必须在包的顶层目录下</strong>；</li><li><code>package.json</code> 文件必须符合 JSON 格式，并且必须包含如下三个属性：<ul><li><strong>name</strong>:  包的名字</li><li><strong>version</strong>: 包的版本号</li><li><strong>main</strong>: 表示包的入口文件</li></ul></li><li>二进制文件应该在<strong>bin目录</strong>下;</li><li>javaScript代码应该在<strong>lib目录</strong>下;</li><li>文档应该在<strong>doc目录</strong>下;</li><li>单元测试应该在<strong>test目录</strong>下;</li><li>Node.js对包要求并没有那么严格，只要顶层目录下有<code>package.json</code>，并<strong>符合基本规范</strong>即可;</li></ol><h2 id="3-package-json文件常见内容（了解）"><a href="#3-package-json文件常见内容（了解）" class="headerlink" title="3.package.json文件常见内容（了解）"></a>3.package.json文件常见内容（了解）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name：包的名称，必须是唯一</span><br><span class="line">description：包的简要说明</span><br><span class="line">version：符合语义化版本识别规范的版本字符串</span><br><span class="line">keywords：关键字数据，通常用于搜索</span><br><span class="line">maintainers：维护者数组，每个元素要包含name、email、web可选字段</span><br><span class="line">contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素</span><br><span class="line">bugs：提交bug的地址，可以是网址或者电子邮件地址</span><br><span class="line">licenses：许可证数组，每个元素要包含type和url字段</span><br><span class="line">repositories：仓库托管地址数组，每个元素要包含type、url和path字段</span><br><span class="line">dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</span><br><span class="line">devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项</span><br></pre></td></tr></table></figure><h1 id="三、模块的加载机制"><a href="#三、模块的加载机制" class="headerlink" title="三、模块的加载机制"></a>三、模块的加载机制</h1><h2 id="1-优先从缓存中加载"><a href="#1-优先从缓存中加载" class="headerlink" title="1.优先从缓存中加载"></a>1.优先从缓存中加载</h2><ul><li>当一个模块初次被 <code>require</code> 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块</li><li>好处：提高模块的加载速度；不需要每次都重新执行并加载模块</li></ul><h2 id="2-核心模块的加载机制"><a href="#2-核心模块的加载机制" class="headerlink" title="2.核心模块的加载机制"></a>2.核心模块的加载机制</h2><ul><li>先查找缓存；如果缓存中没有，再去加载核心模块；</li></ul><h2 id="3-用户模块的加载机制"><a href="#3-用户模块的加载机制" class="headerlink" title="3. 用户模块的加载机制"></a>3. 用户模块的加载机制</h2><ul><li>先查找缓存；</li><li>如果缓存中没有则尝试加载用户模块；</li><li>如果在加载用户模块时候省略了后缀名，则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先，严格按照指定的名称去查找</span><br><span class="line">其次，尝试加载后缀名是 .js 的文件</span><br><span class="line">如果没有.js的文件，则尝试加载 .json 结尾的文件</span><br><span class="line">如果没有 .json 的文件，则尝试加载 .node 结尾的文件</span><br><span class="line">查找规则：index  -&gt;  index.js   -&gt;   index.json   -&gt;  index.node</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-第三方模块的加载机制【了解】"><a href="#4-第三方模块的加载机制【了解】" class="headerlink" title="4.第三方模块的加载机制【了解】"></a>4.第三方模块的加载机制【了解】</h2><ol><li>先在项目根目录中查找<code>node_modules</code>文件夹</li><li>在<code>node_modules</code>文件夹下，查找模块相关的文件夹</li><li>在对应的文件夹下，查找<code>package.json</code>的文件</li><li>查找<code>package.json</code>文件中的<code>main</code>属性（指定了模块的入口文件）</li><li>如果找到了<code>main</code>属性，同时，<code>main</code>属性指定的文件路径存在，那么尝试加载指定的文件模块</li><li>假如没有<code>main</code>属性，或者<code>main</code>属性对应的文件不存在，或者没有<code>package.json</code>,那么会依次尝试加载<code>index.js</code>，<code>index.json</code>,<code>index.node</code>;</li><li>如果没有<code>index</code>相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有<code>node_modules</code>文件夹，则向上一层目录中查找<code>node_modules</code>，查找规则同上！</li><li>最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：<code>cannot find module</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化思想介绍</title>
      <link href="/2019/05/03/9.nodeJs/3.%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/03/9.nodeJs/3.%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E6%83%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1.什么是模块化"></a>1.什么是模块化</h1><p>是一种开发思想，一种约定和规范，按照相同的约定写代码，减少沟通成本，方便模块之间的调用</p><h1 id="2-CommonJS规范"><a href="#2-CommonJS规范" class="headerlink" title="2.CommonJS规范"></a>2.CommonJS规范</h1><p>CommonJS规范是一套js的模块化规范，规定了模块的特性和各模块之间如何依赖<br>nodejs遵循CommonJS规范<br>特点：同步加载模块，不适合在浏览器中使用（影响页面加载）<br>之前使用的模块化规范（已过时）<br>        AMD规范：require.js异步  依赖前置，提前执行<br>        CMD规范：sea.js异步  就近加载，用到的时候才去加载<br>三个成员：<br>        require 引入其他模块<br>        exports 导出当前模块<br>        module 导出当前模块</p><h1 id="3-模块作用域和全局作用域"><a href="#3-模块作用域和全局作用域" class="headerlink" title="3.模块作用域和全局作用域"></a>3.模块作用域和全局作用域</h1><ul><li>模块作用域：每个js文件都有一个独立的作用域，外部require引入文件时，不能直接访问内部的私有成员</li><li>global全局作用域： global可以看做浏览器中的window，但有区别；默认JS文件中定义的变量和方法都是属于模块作用域的，不属于global，需要挂载；</li></ul><p>模块之间共享成员：<br>1.把变量和方法挂载到global上，但不推荐使用，会造成global变量污染<br>2.模块1 exports 成员，模块2 require模块1</p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/node1.jpg" alt></p><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/nodejs/node2.jpg" alt></p><p>exports和module.exports的关系<br>    1.两者引用的是同一个空对象，内存地址相同<br>    2.两者作用一致，都可以向外暴露成员<br>    3.一个模块作用域中，向外暴露成员时，以module.exports为准</p><p>今后在开发中，推荐使用module.exports暴露成员<br>习惯： 导出多个时使用exports，导出一个时使用module.exports</p><h1 id="4-ES6的模块化"><a href="#4-ES6的模块化" class="headerlink" title="4.ES6的模块化"></a>4.ES6的模块化</h1><p>ES6在语言标准层面上，实现了模块化功能，不依赖nodejs，完全可以取代commonjs和AMD，成为浏览器和服务器通用的模块化解决方案<br>ES6的模块化分为导出（export）与导入（import）两个模块。</p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodeJs介绍和文件路径API</title>
      <link href="/2019/05/01/9.nodeJs/1.nodeJS%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84API/"/>
      <url>/2019/05/01/9.nodeJs/1.nodeJS%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-什么是node-js"><a href="#1-什么是node-js" class="headerlink" title="1.什么是node.js"></a>1.什么是node.js</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p><h2 id="2-nodeJs中javascript的组成部分"><a href="#2-nodeJs中javascript的组成部分" class="headerlink" title="2.nodeJs中javascript的组成部分"></a>2.nodeJs中javascript的组成部分</h2><p>ECMAscript核心 + 全局成员 + 核心API模块<br>nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API</p><p>核心API是nodejs安装后自带的<br>想要访问核心API成员，使用require(“核心API名称”)</p><h2 id="3-nodejs可以做什么"><a href="#3-nodejs可以做什么" class="headerlink" title="3.nodejs可以做什么"></a>3.nodejs可以做什么</h2><p>使用JavaScript编写后端API接口或者网站<br>使用nodejs开发一些工具或包<br>基于socket技术开发即时通讯项目<br>基于electron环境开发桌面软件</p><h2 id="4-运行nodeJS的方式"><a href="#4-运行nodeJS的方式" class="headerlink" title="4.运行nodeJS的方式"></a>4.运行nodeJS的方式</h2><p>1）在powershell或者vscode的终端中输入 node xxx.js<br>2）使用repl方式 先输入node，进入repl命令，再输入js代码</p><h2 id="5-path环境变量"><a href="#5-path环境变量" class="headerlink" title="5.path环境变量"></a>5.path环境变量</h2><p>在Windows的高级系统设置里 设置Path环境变量为应用程序的路径 这样就可以在命令行快速启动应用程序</p><h1 id="二、fs文件系统"><a href="#二、fs文件系统" class="headerlink" title="二、fs文件系统"></a>二、fs文件系统</h1><p>fs 模块提供了一个 API，用于与文件系统进行交互。<br><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p><h2 id="1-引入fs模块"><a href="#1-引入fs模块" class="headerlink" title="1.引入fs模块"></a>1.引入fs模块</h2><p><code>const fs = require(&#39;fs&#39;)</code></p><h2 id="2-fs的文件操作"><a href="#2-fs的文件操作" class="headerlink" title="2.fs的文件操作"></a>2.fs的文件操作</h2><p>以下四个方法都是异步进行的，想要改成同步的话在方法名后面添加Sync</p><h3 id="1）读取文件-fs-readFile"><a href="#1）读取文件-fs-readFile" class="headerlink" title="1）读取文件 fs.readFile"></a>1）读取文件 fs.readFile</h3><pre><code>fs.readFile(&apos;读取文件的路径&apos;[,编码格式],回调函数)</code></pre><p>例如： <code>fs.readFile(&#39;1.txt&#39;,&#39;utf-8&#39;,function(err,data){})</code><br>err如果为null说明读取成功；err.message存放了失败时的错误信息<br>编码格式如果不写默认是null，读取出来是buffer16进制</p><h3 id="2-写入文件-fs-writeFile"><a href="#2-写入文件-fs-writeFile" class="headerlink" title="2) 写入文件 fs.writeFile"></a>2) 写入文件 fs.writeFile</h3><pre><code>fs.writeFile(&apos;文件路径&apos;,&apos;要写入的内容&apos;[,编码格式],回调函数)</code></pre><p>例如：<code>fs.writeFile(&#39;1.txt&#39;,&#39;写入的内容&#39;,function(err){})</code><br>文件如果不存在，会新建一个；如果原来有内容会覆盖掉。<br>编码格式默认是utf-8 一般不设置</p><h3 id="3-追加写入文件-fs-appendFile"><a href="#3-追加写入文件-fs-appendFile" class="headerlink" title="3) 追加写入文件 fs.appendFile"></a>3) 追加写入文件 fs.appendFile</h3><pre><code>fs.appendFile(&apos;文件路径&apos;,&apos;要追加的内容&apos;[,编码格式],回调函数)</code></pre><p>例如： <code>fs.appendFile(&#39;1.txt&#39;,&#39;追加的内容&#39;,function(err){})</code><br>文件如果不存在，会新建一个；不会覆盖掉原来的内容。<br>编码格式默认是utf-8 一般不设置</p><h3 id="4-复制文件-fs-copyFile"><a href="#4-复制文件-fs-copyFile" class="headerlink" title="4) 复制文件 fs.copyFile"></a>4) 复制文件 fs.copyFile</h3><pre><code>fs.copyFile(&apos;原文件&apos;,&apos;目标文件&apos;[,flag],回调函数)</code></pre><p>flag一般不指定，是修饰符</p><h3 id="5-删除文件-fs-unlinkFile"><a href="#5-删除文件-fs-unlinkFile" class="headerlink" title="5) 删除文件 fs.unlinkFile"></a>5) 删除文件 fs.unlinkFile</h3><pre><code>fs.unlinkFile(&apos;文件路径&apos;,回调函数)</code></pre><p>文件路径写相对路径时 可能会出现拼接问题<br>推荐使用__dirname：表示当前文件所处的文件夹路径<br>__dirname+”文件”</p><h3 id="6-读取目录下的文件名"><a href="#6-读取目录下的文件名" class="headerlink" title="6)读取目录下的文件名"></a>6)读取目录下的文件名</h3><pre><code>fs.readdir(&apos;文件路径&apos;,(err,filenames)=&gt;{})</code></pre><h1 id="三、Path路径操作"><a href="#三、Path路径操作" class="headerlink" title="三、Path路径操作"></a>三、Path路径操作</h1><p><code>const path = require(&#39;path&#39;)</code></p><h2 id="1-path-join-‘路径片段1’-’路径片段2’…"><a href="#1-path-join-‘路径片段1’-’路径片段2’…" class="headerlink" title="1.path.join(‘路径片段1’,’路径片段2’…)"></a>1.path.join(‘路径片段1’,’路径片段2’…)</h2><p>使用+号拼接需要考虑是否带./和/   容易出错<br>以后拼接路径时使用path.join方法配合__dirname<br>拼接的结果不带.<br>..会和上一级目录抵消掉</p><h2 id="2-path其他属性和方法"><a href="#2-path其他属性和方法" class="headerlink" title="2.path其他属性和方法"></a>2.path其他属性和方法</h2><p>path.sep 返回平台特定的路径分隔符 Windows下是 \  Linux是 /<br>path.basename(paths,[ext]) 返回文件的名称，可以指定扩展名<br>path.dirname(paths) 返回文件的路径，不含文件名<br>path.extname(paths) 返回文件的扩展名</p>]]></content>
      
      
      <categories>
          
          <category> nodeJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客个性化定制</title>
      <link href="/2019/04/16/8.diary/3.Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/"/>
      <url>/2019/04/16/8.diary/3.Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客的个性化修改主要涉及两个文件：<br>1.博客根目录下的config.yml  –博客配置文件<br>2.主题文件夹根目录下的config.yml  –主题配置文件</p></blockquote><h2 id="1-修改博客根目录的Config-yml"><a href="#1-修改博客根目录的Config-yml" class="headerlink" title="1.修改博客根目录的Config.yml"></a>1.修改博客根目录的Config.yml</h2><p>这个配置文件是针对你的博客整站进行配置，如网站标题，作者等，可以适应各个主题。<br>下面列举几个建议修改的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title:#网站标题</span><br><span class="line">subtitle: #网站子标题</span><br><span class="line">description: #网站描述</span><br><span class="line">keywords: #关键词</span><br><span class="line">author: #作者名称</span><br><span class="line">language: #默认语言 常见的有en,zh-CN，zh-Hans等</span><br><span class="line">timezone: #时区 一般无需修改</span><br><span class="line">url: #网站链接 如果有域名可以使用域名，如果没有就是github的默认域名</span><br><span class="line">root: #网站根目录 如果你的网站内容是放在子文件夹，此处应该修改为子文件夹</span><br><span class="line">per_page: #每页显示的文章数量，设置为0可以关闭分页功能</span><br><span class="line">theme: #博客使用的主题，应当和themes文件夹下的主题文件夹名字相同，默认是landscape</span><br><span class="line">deploy: #博客部署相关的信息，在上一篇博文里已经介绍</span><br></pre></td></tr></table></figure><h2 id="2-如何替换默认主题"><a href="#2-如何替换默认主题" class="headerlink" title="2.如何替换默认主题"></a>2.如何替换默认主题</h2><p>默认主题功能比较单一，网上有很多不同风格的hexo主题，官方主题链接：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>每个主题都有自己的github页面，详细介绍了主题如何安装，配置，下面拿NexT主题举例，NexT是一款简洁高效，功能强大的主题，内部集成了丰富的插件，使用响应式设计，可扩展性也很好，被广泛使用。<br>NexT官方文档：<a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a></p><ul><li>主题安装方法：<br>在Blog文件夹下，打开Git bash命令行窗口，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li></ul><p>完成后会在Blog/themes文件夹下看到多了一个next文件夹，主题的相关文件就在此文件夹下。</p><ul><li>切换至NexT主题<br>修改<strong>博客配置文件</strong>config.yml的theme字段，改成next即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li></ul><p>修改完成后，启动本地服务器打开localhost:4000，你会发现主题已经换成了NexT的默认样子<br><img src="https://d33wubrfki0l68.cloudfront.net/90fa9a4a64b8ddf623b4b88c59f821f60500655a/6bf8d/images/docs/next-default-scheme-linux.png" alt="NexT默认"><br>至此 你已经完成了主题的安装 搭建博客的两大步已经完成，后面要做的工作主要是在<strong>主题配置文件</strong>下进行的，比如修改样式，添加第三方服务等。</p><h2 id="3-修改NexT主题"><a href="#3-修改NexT主题" class="headerlink" title="3.修改NexT主题"></a>3.修改NexT主题</h2><p>参考本文：<a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39345384/article/details/80785373</a></p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github 博客搭建指南</title>
      <link href="/2019/04/16/8.diary/2.Hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/16/8.diary/2.Hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Git和node-JS"><a href="#1-安装Git和node-JS" class="headerlink" title="1.安装Git和node.JS"></a>1.安装Git和node.JS</h2><p>Git下载地址：<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">https://www.git-scm.com/download/win</a><br>node.JS下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>下载和安装过程不再赘述，可以按照需要更改安装路径，其他选项保持默认即可。<br>检测是否安装完成：<br>安装完成后，在桌面空白处右键，选择Git Bash here，弹出git命令行窗口<br>    输入node -v 回车 应当能看到nodeJs的版本号<br>    输入npm -v 回车 应当能看到npm版本号<br>以上步骤确认无误后，进行下一步</p><h2 id="2-注册GitHub账号，新建代码仓库"><a href="#2-注册GitHub账号，新建代码仓库" class="headerlink" title="2.注册GitHub账号，新建代码仓库"></a>2.注册GitHub账号，新建代码仓库</h2><ul><li>注册账号<br>注册地址：<a href="https://github.com/join?source=login" target="_blank" rel="noopener">https://github.com/join?source=login</a><br>账号注册完成后，点击右上角Sign in登录</li><li>创建代码仓库<br>登录成功，点击头像旁边的加号，选择new repository<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/newResp.jpg" alt="创建代码仓库"><br>在新窗口填写repository name为：<code>你的git账号昵称+.io</code><br>例如：我的git账号是dingx1an，新建的仓库名字就是dingx1an.io<br>其他选项不用修改，点击create repository<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/newrep1.jpg" alt="填写仓库参数"><br>创建完成后，在右上角，头像右侧有一个下拉按钮，点击your repositories<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/yourrep.jpg" alt="选择仓库"><br>可以看到当前账号下的所有仓库，此处只有一个dingx1an.io<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/myrepo.jpg" alt="所有仓库"></li><li>生成SSH key<br>打开git的命令行窗口，输入以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot; 回车</span><br><span class="line">git config --global user.email &quot;youremail&quot; 回车</span><br></pre></td></tr></table></figure></li></ul><p>yourname为你的github用户名，youremail为你的GitHub注册邮箱<br>创建SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>youremail为你的GitHub注册邮箱，输入命令后一路按下Enter键，直到命令窗口提示已经生成了ssh秘钥文件，默认是在 C:\Users\你的用户名\·ssh 文件夹下，文件名称是id_rsa.pub，使用记事本打开后复制全部内容备用</p><ul><li>将SSH key添加到Github<br>在github页面点击头像旁边的下拉按钮，选择settings，在左侧切换到SSH and GPG keys选项卡<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/sshkey.jpg" alt="添加ssh秘钥"><br>点击 New SSH key 输入title(随便)和key值，点击Add SSH key按钮<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/sshkeyadd.jpg" alt="添加ssh秘钥"><br>检查是否添加成功：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><p>如果成功会出现连接成功字样</p><h2 id="3-安装cnpm淘宝源"><a href="#3-安装cnpm淘宝源" class="headerlink" title="3.安装cnpm淘宝源"></a>3.安装cnpm淘宝源</h2><p>在桌面上进入git bash命令行，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>后续安装Npm包时只需要在原命令之前加个<code>c</code>即可<br>ps: 也可以将默认npm源地址切换到淘宝源，输入以下命令<br>临时修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>全局修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>撤销修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h2 id="4-安装Hexo博客组件"><a href="#4-安装Hexo博客组件" class="headerlink" title="4.安装Hexo博客组件"></a>4.安装Hexo博客组件</h2><p>在Git命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>等待一段时间后，命令行里会出现成功提示<br>可以使用<code>hexo -v</code>检查是否安装完成</p><h2 id="5-初始化Hexo和本地预览"><a href="#5-初始化Hexo和本地预览" class="headerlink" title="5.初始化Hexo和本地预览"></a>5.初始化Hexo和本地预览</h2><p>在你想要存放博客的文件夹内Git bash here，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init Blog</span><br></pre></td></tr></table></figure><p>命令执行完成后，会在你的当前文件夹内生成一个名字为Blog的文件夹（文件夹名字可以自定义），之后博客的所有相关文件都存放在Blog文件夹下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Blog //进入博客文件夹</span><br><span class="line">npm install //安装所需的npm包</span><br></pre></td></tr></table></figure><p>执行完成后 可以在本地文件夹下看到以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules: 依赖包</span><br><span class="line">public：存放生成的页面</span><br><span class="line">scaffolds：生成文章的一些模板</span><br><span class="line">source：用来存放你的文章和自定义页面</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml: 博客的配置文件</span><br></pre></td></tr></table></figure><p>在Blog文件夹下 打开git bash命令行 ，输入 <code>hexo g</code> 按下回车生成博客的静态文件，然后输入<code>hexo s</code> 按下回车，启动本地hexo server，之后可以看到<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hexos.jpg" alt="hexo服务器"></p><p>在浏览器中访问localhost:4000，就能看到当前博客的页面，只不过主题是默认的，后续再修改即可<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hexoland.png" alt="hexo默认页面"></p><h2 id="6-将博客部署到Github"><a href="#6-将博客部署到Github" class="headerlink" title="6.将博客部署到Github"></a>6.将博客部署到Github</h2><p>本地预览博客页面没问题后，修改博客文件夹的根目录下config.yml文件，<br>在文件顶部，修改url字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://github.com/dingx1an</span><br><span class="line">root: /dingx1an.io</span><br></pre></td></tr></table></figure><p>在文件最底部，修改repo字段：<br> <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/hxconfig.jpg" alt="hexo配置文件"><br>github字段修改成自己的库链接，添加branch字段，其他地方不用修改<br>修改完Config.yml文件后，在Blog文件夹内启动git bash，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -save</span><br></pre></td></tr></table></figure><p>安装hexo上传插件，安装完成后，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>实现博客的部署操作，注意deploy时可能要你输入GitHub的username和password</p><h2 id="7-开启github-pages服务"><a href="#7-开启github-pages服务" class="headerlink" title="7.开启github pages服务"></a>7.开启github pages服务</h2><p>部署成功后，可以在github的个人仓库页面看到本地上传的文件：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitfile.jpg" alt="github pages"><br>接下来需要开启github pages服务，将博客放到网络上：<br>在仓库页面，选择settings<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitpages1.jpg" alt="github pages"><br> 往下拉，直到Github Pages部分，按照下图选择<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/personal/hexo/gitpages2.jpg" alt="github pages"><br>这样就可以使用默认的地址（第一个蓝色框框后面的地址）访问你的博客了</p><blockquote><p>Hexo里常用的命令：<br><code>hexo s</code> 启动本地hexo服务器<br><code>hexo g</code> 生成本地的静态文件<br><code>hexo d</code> 部署本地文件到github<br><code>hexo clean</code> 清理本地静态文件缓存</p></blockquote><p>博客主题修改和自定义配置，在后面的文章里再补充把。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器touchmove事件存在的问题</title>
      <link href="/2019/03/28/0.tips/5.%E6%B5%8F%E8%A7%88%E5%99%A8touchmove%E4%BA%8B%E4%BB%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/28/0.tips/5.%E6%B5%8F%E8%A7%88%E5%99%A8touchmove%E4%BA%8B%E4%BB%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近做项目经常在 chrome 的控制台看到如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unable to preventDefault inside passive event listener due to target being treated as passive. </span><br><span class="line">See https://www.chromestatus.com/features/5093566007214080</span><br></pre></td></tr></table></figure><p>于是 Google 了一番，找到这篇文章，有了详细解释。<a href="https://developers.google.com/web/updates/2017/01/scrolling-intervention" target="_blank" rel="noopener">Making touch scrolling fast by default</a></p><p>简而言之：</p><p>由于浏览器必须要在执行事件处理函数之后，才能知道有没有掉用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。</p><p>所以为了让页面滚动的效果如丝般顺滑，从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, func) 效果和下面一句一样</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, func, &#123; passive: true &#125;)</span><br></pre></td></tr></table></figure><p>这就导致了一个问题：</p><p>如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为。<br>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  height: 2000px;</span><br><span class="line">  background: linear-gradient(to bottom, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 chrome56 中，照样滚动，而且控制台会有提示，blablabla</span><br><span class="line">window.addEventListener(&apos;touchmove&apos;, e =&gt; e.preventDefault())</span><br></pre></td></tr></table></figure><p>那么如何解决这个问题呢？不让控制台提示，而且 preventDefault() 有效果呢？<br>两个方案：<br>1、注册处理函数时，用如下方式，明确声明为不是被动的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;touchmove&apos;, func, &#123; passive: false &#125;)</span><br></pre></td></tr></table></figure><p>2、应用 CSS 属性<code>touch-action: none;</code> 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发。<br>touch-action 还有很多选项，详细请参考<a href="https://w3c.github.io/pointerevents/#the-touch-action-css-property" target="_blank" rel="noopener">touch-action</a></p><p>[注]未来可能所有的元素的 touchstart touchmove 事件处理函数都会默认为 passive: true</p><blockquote><p>注：本文转载自<a href="https://segmentfault.com/a/1190000008512184?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008512184?tdsourcetag=s_pcqq_aiomsg</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2019/03/26/0.tips/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/03/26/0.tips/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用Jq插件上传"><a href="#1-使用Jq插件上传" class="headerlink" title="1.使用Jq插件上传"></a>1.使用Jq插件上传</h2><p>使用jQuery-fileupload插件<br>1.引入以下三个文件：</p><ul><li>jquery.ui.widget.js</li><li>jquery.iframe-transport.js</li><li>jquery.fileupload.js</li></ul><p>2.file表单元素设置<br><code>name=&#39;file&#39;</code><br><code>data-url=&quot;后台接口地址&quot;</code></p><p>3.js里对表单控件操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#fileUpload'</span>).fileupload(&#123;</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    done: <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> imgUrl= data._response.result.picAddr;</span><br><span class="line">        $(<span class="string">"#showBrand"</span>).attr(<span class="string">"src"</span>,imgUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-使用ajax上传文件"><a href="#2-使用ajax上传文件" class="headerlink" title="2.使用ajax上传文件"></a>2.使用ajax上传文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#file"</span>).on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>]; <span class="comment">//是一个对象 存储了此图片相关的信息</span></span><br><span class="line">        <span class="keyword">var</span> filedata = <span class="keyword">new</span> FormData(); <span class="comment">//是一个对象 类型为FormData</span></span><br><span class="line">        filedata.append(<span class="string">"file"</span>, file); <span class="comment">//往此对象内部添加图片相关信息</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">"post"</span>,</span><br><span class="line">            url: <span class="string">"/category/addSecondCategoryPic"</span>,</span><br><span class="line">            data: filedata,</span><br><span class="line">            contentType: <span class="literal">false</span>, <span class="comment">//设置之后文件类型变为multipart/form-data</span></span><br><span class="line">            processData: <span class="literal">false</span>, <span class="comment">//不需要进行数据转换 用原格式发送</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                brandLogo = res.picAddr;</span><br><span class="line">                $(<span class="string">".brandimg"</span>).attr(<span class="string">"src"</span>, brandLogo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>contentType 类型：Boolean<br>作用是告诉服务器，浏览器发来了什么数据；一般情况下，我们不需要设置它。默认值为’application/x-www-form-urlencoded; charset=UTF-8’；<br>上传文件时，我们会将content-type设置成flase，这样在发送请求时，请求头里content-Type会变成multipart/form-data</li></ul><ul><li>processData  类型：Boolean<br>默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，设置为 false。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图床从七牛云换到腾讯</title>
      <link href="/2019/03/15/8.diary/1.%E5%9B%BE%E5%BA%8A%E4%BB%8E%E4%B8%83%E7%89%9B%E4%BA%91%E6%9B%BF%E6%8D%A2%E5%88%B0%E8%85%BE%E8%AE%AF/"/>
      <url>/2019/03/15/8.diary/1.%E5%9B%BE%E5%BA%8A%E4%BB%8E%E4%B8%83%E7%89%9B%E4%BA%91%E6%9B%BF%E6%8D%A2%E5%88%B0%E8%85%BE%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天收到邮件通知 七牛云存储空间默认的测试域名到期，被回收了，于是博客里所有外链图片都失效了。<br>百度得知，七牛图床如果没有自定义加速域名，测试域名的有效期只有30天，之后就会被回收。然鹅添加自定义域名需要备案 对小博客来说太麻烦了，所以不得已把图床换成了腾讯云。刚好现在博客是放在Coding上，也相当于在腾讯云里。腾讯云默认有6个月时效的免费空间，就算到期后收费标准也比较低，对于小破站来说完全可以接受。</p></blockquote><p>切换方法简述： </p><ul><li><p>在七牛云上新建存储空间newblog，使用七牛云的qshell工具，把原来的图片全部转移到新空间；因为新空间会有一个默认的测试域名，后面批量下载时会使用到新的测试域名。</p></li><li><p>使用批量下载七牛云图片的工具，把图片下载到本地。上传到腾讯云，博客文章里只需要使用sublime批量替换图片的域名即可，并不是很麻烦。</p></li><li><p>具体参考的博文：<br><a href="https://www.jianshu.com/p/a0c32c22ac3e" target="_blank" rel="noopener">七牛云测试域名失效怎么办</a><br><a href="https://boke112.com/4288.html" target="_blank" rel="noopener">如何批量下载七牛云图片</a><br><a href="https://blog.csdn.net/dataiyangu/article/details/85220829" target="_blank" rel="noopener">腾讯云使用</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端生词本</title>
      <link href="/2019/03/10/0.tips/2.%E5%89%8D%E7%AB%AF%E7%94%9F%E8%AF%8D%E6%9C%AC/"/>
      <url>/2019/03/10/0.tips/2.%E5%89%8D%E7%AB%AF%E7%94%9F%E8%AF%8D%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">name</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">hover</td><td align="center">徘徊，犹豫，鼠标移动到链接上</td></tr><tr><td align="center">indent</td><td align="center">缩进，文本缩进</td></tr><tr><td align="center">italic</td><td align="center">倾斜的 font-style设置字体倾斜</td></tr><tr><td align="center">nav</td><td align="center">导航-navigation的缩写</td></tr><tr><td align="center">solid</td><td align="center">立体的，结实的。在盒子边框属性中意为单实线</td></tr><tr><td align="center">dashed</td><td align="center">虚线，在盒子边框属性中意为虚线</td></tr><tr><td align="center">dotted</td><td align="center">密布的，意为边框使用点线</td></tr><tr><td align="center">collapse</td><td align="center">合并，例如表格边框合并成一条线</td></tr><tr><td align="center">valign</td><td align="center">vertical align的缩写，意为垂直对齐方式。vertical 垂直的。</td></tr><tr><td align="center">even</td><td align="center">偶数</td></tr><tr><td align="center">odd</td><td align="center">奇数</td></tr><tr><td align="center">deg</td><td align="center">degree的缩写，度数</td></tr><tr><td align="center">skew</td><td align="center">斜交 歪斜</td></tr><tr><td align="center">iteration</td><td align="center">反复，重复  iteration-count 播放次数</td></tr><tr><td align="center">alternate</td><td align="center">轮流 交替  在animation-direction里是倒放的意思</td></tr><tr><td align="center">opacity</td><td align="center">不透明度 为1时不透明  为0时透明</td></tr><tr><td align="center">stretch</td><td align="center">拉伸</td></tr><tr><td align="center">background-size</td><td align="center">cover,contain设置背景平铺方式</td></tr><tr><td align="center">background</td><td align="center">-webkit-linear-gradient 背景颜色渐变</td></tr><tr><td align="center">prompt</td><td align="center">浏览器获取输入 取到的是字符型</td></tr><tr><td align="center">parseInt</td><td align="center">转换成整数</td></tr><tr><td align="center">parseFloat</td><td align="center">转换成浮点型</td></tr><tr><td align="center">sibling</td><td align="center">兄弟姐妹</td></tr><tr><td align="center">append</td><td align="center">附加-appendChild添加节点</td></tr><tr><td align="center">propagation</td><td align="center">传播-stopPropagation阻止冒泡</td></tr><tr><td align="center">interval</td><td align="center">间隔-setInterval 设置定时器</td></tr><tr><td align="center">navigator</td><td align="center">领航员-是BOM里的浏览器对象</td></tr><tr><td align="center">explode</td><td align="center">爆炸-php里分割字符串的方法</td></tr><tr><td align="center">decode</td><td align="center">译码-php里json_decode把字符串转为数组的方法</td></tr><tr><td align="center">encode</td><td align="center">编码-php里json_encode把数组转为字符串</td></tr><tr><td align="center">serialize</td><td align="center">序列化-jq里Form表单的序列化方法</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生词本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识补充</title>
      <link href="/2019/03/10/0.tips/1.%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2019/03/10/0.tips/1.%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1-line-height会继承，如果给了ul，li没有设置的话会继承"><a href="#1-line-height会继承，如果给了ul，li没有设置的话会继承" class="headerlink" title="1.line-height会继承，如果给了ul，li没有设置的话会继承"></a>1.line-height会继承，如果给了ul，li没有设置的话会继承</h3><h3 id="2-伪元素不可以使用js控制，因为js无法选中伪元素"><a href="#2-伪元素不可以使用js控制，因为js无法选中伪元素" class="headerlink" title="2.伪元素不可以使用js控制，因为js无法选中伪元素"></a>2.伪元素不可以使用js控制，因为js无法选中伪元素</h3><h3 id="3-最初的伪元素用一个冒号-CSS3中开始使用两个冒号"><a href="#3-最初的伪元素用一个冒号-CSS3中开始使用两个冒号" class="headerlink" title="3.最初的伪元素用一个冒号: CSS3中开始使用两个冒号::"></a>3.最初的伪元素用一个冒号: CSS3中开始使用两个冒号::</h3><p>在 CSS3 中为了区别伪元素和伪类，为伪元素使用了双冒号，即 ::before为伪元素 ； :before    为伪类；<br>伪类有：:first-child ，:link，:visited，:hover，:active,:focus，:lang<br>伪元素有： ::first-line，::first-letter，::before，::after，::selection</p><h3 id="4-flex布局不能实现多个宽高不同的元素-无缝瀑布流布局；"><a href="#4-flex布局不能实现多个宽高不同的元素-无缝瀑布流布局；" class="headerlink" title="4.flex布局不能实现多个宽高不同的元素 无缝瀑布流布局；"></a>4.flex布局不能实现多个宽高不同的元素 无缝瀑布流布局；</h3><h3 id="5-flex可以实现多列布局，每列的高度按照内容最高的一列等高"><a href="#5-flex可以实现多列布局，每列的高度按照内容最高的一列等高" class="headerlink" title="5.flex可以实现多列布局，每列的高度按照内容最高的一列等高"></a>5.flex可以实现多列布局，每列的高度按照内容最高的一列等高</h3><h3 id="6-多列排版是CSS3的新特性"><a href="#6-多列排版是CSS3的新特性" class="headerlink" title="6.多列排版是CSS3的新特性"></a>6.多列排版是CSS3的新特性</h3><h3 id="7-数组元素未给值时是undifined，如arr-，其中每一项是undifined"><a href="#7-数组元素未给值时是undifined，如arr-，其中每一项是undifined" class="headerlink" title="7.数组元素未给值时是undifined，如arr = [ , , ]，其中每一项是undifined"></a>7.数组元素未给值时是undifined，如arr = [ , , ]，其中每一项是undifined</h3><h3 id="8-看以下JavaScript代码，控制台打印的结果是什么？"><a href="#8-看以下JavaScript代码，控制台打印的结果是什么？" class="headerlink" title="8.看以下JavaScript代码，控制台打印的结果是什么？"></a>8.看以下JavaScript代码，控制台打印的结果是什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line">x=<span class="number">10</span>;</span><br><span class="line">y=x++;</span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="9-阻止链接跳转-把链接的-改成javascript"><a href="#9-阻止链接跳转-把链接的-改成javascript" class="headerlink" title="9.阻止链接跳转 把链接的#改成javascript:;"></a>9.阻止链接跳转 把链接的#改成javascript:;</h3><h3 id="10-数组和字符串方法"><a href="#10-数组和字符串方法" class="headerlink" title="10.数组和字符串方法"></a>10.数组和字符串方法</h3><p>数组的方法：<br>数组转换为字符串： <code>arr.toString或者arr.join(&#39;分隔符&#39;)</code><br>数组截取1： <code>arr.slice(startIndex,endIndex)</code> 包含开始 不包含结束，如果只有一个值，往后截取到末尾<br>数组截取2： <code>arr.splice(startIndex,length,replace)</code> 从开始索引截取一定长度，replace是可选参数：替换被截取的元素，改变原数组</p><p>字符串的方法：<br>字符串转换为数组： <code>str.split(&quot;分隔符&quot;)</code> 按照字符串里的分隔符 转换为数组<br>字符串截取1： <code>str.substring(startIndex,endIndex)</code> 包含开始，不包含结束，如果只有一个值，往后截取到末尾<br>字符串截取2： <code>str.substr(startIndex,length)</code> 从某个字符开始截取，截取长度为length，如果只有一个值，截取到末尾</p><h3 id="11-js和jq里insertBefore方法的区别："><a href="#11-js和jq里insertBefore方法的区别：" class="headerlink" title="11.js和jq里insertBefore方法的区别："></a>11.js和jq里insertBefore方法的区别：</h3><p>js里insertBefore是操作DOM节点使用的，语法：<br><code>parentNode.insertBefore(要插入的节点m，某个子节点n)</code>  在子节点n前面插入节点m</p><p>jQuery里 insertBefore是HTML/CSS方法，在被选元素之前插入元素，语法：<br><code>$(要插入的元素m).insertBefore(&#39;选择器&#39;)</code>  在选择器中的元素之前插入元素m  </p><h3 id="12-art-template模板引擎识别HTML标签"><a href="#12-art-template模板引擎识别HTML标签" class="headerlink" title="12.art-template模板引擎识别HTML标签"></a>12.art-template模板引擎识别HTML标签</h3><p>art-template模板引擎识别HTML标签，需要不编码输出，需要在输出语句里加个井号；例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;#value.name&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="13-字符串padStart方法"><a href="#13-字符串padStart方法" class="headerlink" title="13.字符串padStart方法"></a>13.字符串padStart方法</h3><p>填充字符串使用：<br><code>str.padStart(长度，要填充的字符串);</code><br>例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'8'</span>;</span><br><span class="line">str.padStart(<span class="number">2</span>,<span class="string">'0'</span>); <span class="comment">//字符串变为'08'</span></span><br></pre></td></tr></table></figure><h3 id="14-鼠标双击事件"><a href="#14-鼠标双击事件" class="headerlink" title="14.鼠标双击事件"></a>14.鼠标双击事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.box&quot;).on(&apos;dbclick&apos;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="15-数组的findIndex方法"><a href="#15-数组的findIndex方法" class="headerlink" title="15.数组的findIndex方法"></a>15.数组的findIndex方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> index = arr.findIndex(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item == <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">index是<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源和跨域</title>
      <link href="/2018/07/08/7.AJAX/3.%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/07/08/7.AJAX/3.%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、同源"><a href="#一、同源" class="headerlink" title="一、同源"></a>一、同源</h1><p>同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。</p><h1 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h1><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。<br>跨域不能访问cookie和localstorage，不允许进行DOM操作，不能发送ajax请求。<br>允许跨域的标签：img,link,src,href。<br>跨域不是请求没有发出去，而是发出后，服务器返回的数据被浏览器拦截了。</p><h2 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2.跨域解决方案"></a>2.跨域解决方案</h2><ul><li>1) 服务器端跨域 CORS <em>cross origin resource sharing</em><br>在请求的php文件中设置响应头：<br><code>header(&quot;Access-Control-Allow-Origin:*&quot;)</code> 允许所有其他域向当前域发送请求。<br><code>header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;)</code> 允许指定的域向当前域发送请求。<br>不常用，服务器一般不允许这么设置。</li><li>2）JSONP<br>常用的跨域方式</li></ul><h2 id="3-JSONP跨域方案"><a href="#3-JSONP跨域方案" class="headerlink" title="3.JSONP跨域方案"></a>3.JSONP跨域方案</h2><h3 id="1）原理（原生js解释）"><a href="#1）原理（原生js解释）" class="headerlink" title="1）原理（原生js解释）"></a>1）原理（原生js解释）</h3><ul><li>前台修改：<br>其本质是利用了<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code>标签的src具有可跨域的特性，将操作数据的函数test拼接为callback的值。</li></ul><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/1eajEg68jYO4.png?imageslim" alt="mark"></p><ul><li>后台处理：<br>服务端返回一个‘预先定义好的Javascript函数的调用’，并且将‘服务器数据’以该‘函数参数’的形式传递过来<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/nsBDCM1kXu0C.png?imageslim" alt="mark"></li></ul><p><strong>只能以GET方式请求</strong></p><h3 id="2）jquery使用JSONP跨域的步骤："><a href="#2）jquery使用JSONP跨域的步骤：" class="headerlink" title="2）jquery使用JSONP跨域的步骤："></a>2）jquery使用JSONP跨域的步骤：</h3><ul><li><p>前台修改：在ajax请求里设置datatype为jsonp，开启跨域请求<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190608/Ic7JxGnJWcIw.png?imageslim" alt="mark"></p></li><li><p>后台处理：将所需结果返回即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data = file_get_contents(&quot;data.json&quot;);</span><br><span class="line">    echo $data;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>ajax和jsonp的本质不一样，jsonp是通过JavaScript标签发送请求；ajax是通过XMLhttpRequest实现发送请求</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板引擎</title>
      <link href="/2018/07/04/7.AJAX/2.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2018/07/04/7.AJAX/2.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<blockquote>> md文件中如果直接出现{{}}没有被代码块包裹时，会出现解析问题。要使用{%raw%}和{%endraw%}包裹起来。</blockquote><h1 id="一、模板引擎"><a href="#一、模板引擎" class="headerlink" title="一、模板引擎"></a>一、模板引擎</h1><h2 id="1-为什么使用模板引擎"><a href="#1-为什么使用模板引擎" class="headerlink" title="1.为什么使用模板引擎"></a>1.为什么使用模板引擎</h2><p>从json获取数据后，想要生成页面结构，需要拼接字符串，效率低且繁琐；</p><h2 id="2-什么是模板引擎"><a href="#2-什么是模板引擎" class="headerlink" title="2.什么是模板引擎"></a>2.什么是模板引擎</h2><p>为了使用户界面和业务数据分离，用于生成特定的网页结构块。为了动态渲染的时候简化字符串的拼接。</p><h2 id="3-流行模板引擎"><a href="#3-流行模板引擎" class="headerlink" title="3.流行模板引擎"></a>3.流行模板引擎</h2><p><a href="http://tangram.baidu.com/BaiduTemplate/" target="_blank" rel="noopener">BaiduTemplate</a><br><a href="http://aui.github.io/art-template/zh-cn/" target="_blank" rel="noopener">ArtTemplate</a><br><a href="https://github.com/shepherdwind/velocity.js/" target="_blank" rel="noopener">velocity.js</a><br><a href="http://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars</a> <br><br>速度最快，最常用的是<code>artTemplate</code></p><h2 id="4-art-template语法"><a href="#4-art-template语法" class="headerlink" title="4.art-template语法"></a>4.<code>art-template</code>语法</h2><p>分为原生语法和简洁语法，引入不同的js文件</p><ul><li>原生语法： 引入 <code>template-native.js</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式：` &lt;% 表达式 %&gt;` 里面可以写js代码循环或判断</span><br><span class="line">输出表达式： 编码输出：`&lt;%=content%&gt;`  不编码输出： `&lt;%=#content%&gt; `</span><br></pre></td></tr></table></figure><p>（编码可以防止数据中含有 HTML 字符串，避免引起 XSS 攻击）</p><ul><li>简洁语法： 引入<code>template.js</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式：&#123;&#123; 表达式 &#125;&#125;</span><br><span class="line">输出表达式： 编码输出&#123;&#123;content&#125;&#125; 不编码输出&#123;&#123;#content&#125;&#125;</span><br></pre></td></tr></table></figure><p>条件表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> 条件&#125;&#125;</span><br><span class="line">&lt;p&gt;内容<span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;else if value &gt; 0&#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;内容2&lt;/</span>p&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">&lt;p&gt;内容<span class="number">3</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/i</span>f&#125;&#125;</span><br></pre></td></tr></table></figure><p>循环遍历表达式：<br>value相当于传统写法的data[i],index相当于i<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each list <span class="keyword">as</span> value index&#125;&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123;value.user&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/</span>each&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简写为：</span></span><br><span class="line">默认有个$value和$index</span><br><span class="line">&#123;&#123;each list&#125;&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123;$value.user&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&#123;&#123;/</span>each&#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-art-template模板使用方法："><a href="#5-art-template模板使用方法：" class="headerlink" title="5.art-template模板使用方法："></a>5.<code>art-template</code>模板使用方法：</h2><ul><li><p>创建模板： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">"text/template"</span> id = <span class="string">"temp"</span>&gt; </span><br><span class="line">模板结构，可以写逻辑表达式 </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用模板函数：<code>template(模板id,数据)</code><br>函数返回值是页面结构（html）<br>数据格式只能是对象形式，如果数据是数组，要包装为对象{“items”:arr}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX编程</title>
      <link href="/2018/07/03/7.AJAX/1.ajax%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/03/7.AJAX/1.ajax%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1.Ajax"></a>1.Ajax</h2><p>即 Asynchronous Javascript And XML，AJAX 不是一门的新的语言，而是对现有技术的综合利用。</p><ul><li><ol><li>基于web标签的xhtml+css</li></ol></li><li><ol start="2"><li>可以使用dom进行动态的显示和交互</li></ol></li><li><ol start="3"><li>使用XML和XSLT(是一种用于将XML文档转换任意文本的描述语言)进行数据的交换和操作</li></ol></li><li><ol start="4"><li>使用XMLHttpRequest进行异步的数据查询和检索等操作</li></ol></li></ul><p>本质:   是在HTTP协议的基础上以异步的方式通过XMLHttpRequest对象与服务器进行通信。<br>作用：可以在页面不刷新的情况下，请求服务器，局部更新页面的数据；</p><h2 id="2-异步Asynchronous-ə’sɪŋkrənəs"><a href="#2-异步Asynchronous-ə’sɪŋkrənəs" class="headerlink" title="2.异步Asynchronous [ə’sɪŋkrənəs]"></a>2.异步Asynchronous [ə’sɪŋkrənəs]</h2><p>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。<br>异步可以提升程序的执行效率,增强用户体验</p><h2 id="3-XMLHttpRequest异步对象"><a href="#3-XMLHttpRequest异步对象" class="headerlink" title="3.XMLHttpRequest异步对象"></a>3.XMLHttpRequest异步对象</h2><p>浏览器的内置对象，用于后台与服务器进行交互。可以实现不刷新整个页面，局部更新数据</p><h3 id="1-异步对象发送请求"><a href="#1-异步对象发送请求" class="headerlink" title="1.异步对象发送请求"></a>1.异步对象发送请求</h3><ul><li>1 创建异步对象<pre><code>var xhr = new XMLHttpRequest();</code></pre></li><li>2 设置请求行 open(请求方式，请求url):<pre><code>xhr.open(&quot;get/post&quot;, &quot;url?参数可选&quot;);</code></pre>get请求如果有参数就需要在url？后面拼接参数<br>post如果有参数，就在请求体中传递</li><li>3 设置请求头 <pre><code>setRequestHeader(&apos;key&apos;,&apos;value&apos;)</code></pre>get方式不需要设置请求头<br>post需要设置 <code>xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code></li><li>4 设置请求体:发送请求 <pre><code>send(参数：key=value&amp;key=value)</code></pre>get在这个位置可以传递Null或空内容<pre><code>xhr.send(null)</code></pre>post如果有参数，应该在这个位置来传递参数<pre><code>xhr.send(&quot;name=&quot;+uname)</code></pre></li></ul><p><strong>注GET和POST请求方式的差异（面试题）</strong><br>1、GET没有请求主体，使用xhr.send(null)<br>2、GET可以通过在请求URL上添加请求参数<br>3、POST可以通过<code>xhr.send(&#39;name=itcast&amp;age=10&#39;)</code><br>4、POST需要设置<code>xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code> 如果没设置 参数无法传到服务器<br>5、GET大小限制约4K，POST则没有限制</p><h3 id="2-判断响应是否完成"><a href="#2-判断响应是否完成" class="headerlink" title="2.判断响应是否完成"></a>2.判断响应是否完成</h3><p>复习响应报文：<br>    报文行：响应状态码 响应状态信息 200 ok<br>    报文头：服务器返回给客户端的一些额外信息<br>    报文体：服务器返回给客户端的数据<br>异步对象的相关属性：<br><code>xhr.responseText</code>:服务器返回的普通字符串<br><code>xhr.responseXML</code>：服务器返回的xml格式的字符串，XML格式的字符串只能用此方法接收<br><code>xhr.status</code>:可以获取当前服务器的响应状态 200 》成功<br><code>xhr.readyState</code>: 监听异步对象的响应状态,<br>         readyState=0：已经创建了异步对象，但是还没有调用open方法 –未初始化<br>         readyState=1：说明已经调用了open方法，初始化完成 –载入<br>         readyState=2：send方法执行完毕，请求发送 –载入完成<br>         readyState=3：正在接收响应数据 –交互<br>         readyState=4：响应的内容解析完毕，可以在客户端使用了 –完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 1.服务器成功响应 2.数据已经返回到客户端并且可以使用了</span></span><br><span class="line"><span class="keyword">if</span> (xhr.status == <span class="number">200</span> &amp;&amp; xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line"><span class="comment">// 将返回结果在页面中展示</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".msg"</span>).innerHTML = xhr.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-XML"><a href="#4-XML" class="headerlink" title="4.XML"></a>4.XML</h2><p>XML是一种标记语言，类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190603/mcf1gXYhbf4I.png?imageslim" alt="mark"><br>1、第一句不可更改，必须有一个根元素<br>2、标签名称不可有空格、不可以数字或.开头、大小写敏感<br>3、不可交叉嵌套<br>4、属性双引号（浏览器自动修正成双引号了）<br>5、特殊符号要使用实体<br>6、注释和HTML一样<br>虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。<br>接收XML数据时，接收XML数据时，js使用xhr.responseXML接收，php设置响应头为header(“Content-Type:application/xml;charset=utf-8”)</p><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5.JSON"></a>5.JSON</h2><p>即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。JSON体积小、解析方便且高效，在实际开发成为首选。<br>接收json数据时，php设置响应头为header(“Content-Type:application/json;charset=utf-8”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">属性名<span class="number">1</span>:属性值,</span><br><span class="line">属性名<span class="number">2</span>:属性值</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">属性名<span class="number">3</span>:属性值,</span><br><span class="line">属性名<span class="number">4</span>:属性值</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="1、Javascript-解析json方法"><a href="#1、Javascript-解析json方法" class="headerlink" title="1、Javascript 解析json方法"></a>1、Javascript 解析json方法</h3><pre><code>JSON.parse()     可以将json格式的字符串 转换为js的数组或对象，类似php里的json_decode方法JSON.stringify()；    可以将js的数组或对象转换为json格式的字符串 ，类似php里的json_decode方法</code></pre><h3 id="2、PHP解析json方法"><a href="#2、PHP解析json方法" class="headerlink" title="2、PHP解析json方法"></a>2、PHP解析json方法</h3><pre><code>json_decode() 将字符串转换为数组或对象json_encode() 将数组或对象转换为字符串</code></pre><p>js和html混编：<br>    声明变量html存放生成的html标签，全部生成完后再添加到页面上</p><h2 id="6-封装AJAX工具函数"><a href="#6-封装AJAX工具函数" class="headerlink" title="6.封装AJAX工具函数"></a>6.封装AJAX工具函数</h2><p>将XMLHttpRequest封装成一个函数，提升开发效率</p><p><code>xhr.getResponseHeader(&quot;Content-Type&quot;)</code>可以获取响应头字符串，如<code>application/json;charset=utf-8</code></p><h2 id="7-jquery里的ajax"><a href="#7-jquery里的ajax" class="headerlink" title="7.jquery里的ajax"></a>7.jquery里的ajax</h2><p>jquery提供了$.ajax({})函数，参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- url 接口地址 </span><br><span class="line">- type 请求方式 </span><br><span class="line">- timeout 请求超时时间，单位是毫秒 </span><br><span class="line">- dataType 服务器返回格式，设置想要从服务器返回的数据格式 xml,json,text,html...</span><br><span class="line">- data 请求参数 使用对象形式&#123;&quot;aa&quot;:&quot;bb&quot;&#125;或者使用表单序列化方法</span><br><span class="line">- beforeSend:function()&#123;&#125; 请求发起前调用，可以实现验证操作 </span><br><span class="line">- success:funtion()&#123;&#125; 成功响应后调用 </span><br><span class="line">- error:funtion()&#123;&#125; 错误响应时调用,比如请求超时 </span><br><span class="line">- complete()&#123;&#125; 响应完成时调用（包括成功和失败），比如全局成员的释放，页面状态的重置</span><br></pre></td></tr></table></figure><p>jquery还提供了专门发送get和post类型的ajax请求的函数<br><code>$.get({url,data,success,datatype})  只能发送get请求</code><br><code>$.post({url,data,success,datatype})    只能发送post请求</code></p><p>表单序列化方法：<br><code>$(form表单).serialize();</code><br>是jquery提供的方法，可以将form里所有有name属性的表单收集，生成key=value&amp;key=value的格式的字符串<br>ajax支持处理两种格式的参数：<br>    1.对象形式 {“aa”:”bb”}<br>    2.key=value&amp;key=value格式的字符串</p><p>** 注册案例 **需要创建以下文件<br>    data.json 存储数据<br>    getCode.php 获取验证码<br>    register.php 注册操作<br>    validateUsername.php 验证用户名<br>    register.html 结构和自定js文件<br>    jquery.min.js<br>主要功能点：<br>    用户输入用户名，失去焦点时判断是否重名，给出提示；<br>    用户点击按钮获取验证码，从服务器取到验证码；<br>    用户点击注册按钮，把数据写入服务器json文件</p><p>如果ajax里设置了datatype为json，后台返回数据时要使用json格式：<br><code>echo json_encode(array(&quot;code&quot;=&gt;&quot;1&quot;,&quot;msg&quot;=&gt;&quot;用户名存在&quot;))</code></p><p><code>array_rand(arr)</code>:可以随机生成指定的数组长度内的索引</p><h3 id="附录：使用原生js编写的ajax工具函数"><a href="#附录：使用原生js编写的ajax工具函数" class="headerlink" title="附录：使用原生js编写的ajax工具函数"></a>附录：使用原生js编写的ajax工具函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> $ = &#123;</span><br><span class="line">        <span class="comment">// 将用户传递的 对象形式的参数 转换为字符串</span></span><br><span class="line">        getpa: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">"object"</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="string">"?"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">                    str = str + k + <span class="string">"="</span> + data[k] + <span class="string">"&amp;"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                str = str.substr(<span class="number">0</span>, str.length - <span class="number">1</span>); <span class="comment">//截取掉最后一个&amp; 得到?name=liu&amp;age=10这种格式</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;,</span><br><span class="line">        ajax: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> type = option.type || <span class="string">'get'</span>; <span class="comment">//请求类型</span></span><br><span class="line">            <span class="keyword">var</span> url = option.url || location.href; <span class="comment">//请求url</span></span><br><span class="line">            <span class="comment">//请求参数，option.data格式是&#123;"name":"liu","age":10&#125;，操作后data是?name=liu&amp;age=18</span></span><br><span class="line">            <span class="keyword">var</span> data = <span class="keyword">this</span>.getpa(option.data) || <span class="string">""</span>; <span class="comment">//this指向？</span></span><br><span class="line">            <span class="keyword">var</span> success = option.success; <span class="comment">//响应成功之后的回调函数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">"get"</span>) &#123;</span><br><span class="line">                url += data; <span class="comment">//如果是get 把参数加进url里</span></span><br><span class="line">                data = <span class="literal">null</span>; <span class="comment">//把data置为空，get发送请求体是Null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求行</span></span><br><span class="line">            xhr.open(type, url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求头,get不需要请求头</span></span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">"post"</span>) &#123;</span><br><span class="line">                xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">                <span class="comment">//去掉问号</span></span><br><span class="line">                data = data.substr(<span class="number">1</span>, data.length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求体</span></span><br><span class="line">            xhr.send(data);</span><br><span class="line"></span><br><span class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="comment">// 接收响应的返回值</span></span><br><span class="line">                    <span class="comment">// responseText   responseXML 获取响应头字符串判断是哪种类型</span></span><br><span class="line">                    <span class="keyword">var</span> rh = xhr.getResponseHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">                    <span class="comment">// 判断</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.indexOf(<span class="string">"xml"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> result = xhr.responseXML;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.indexOf(<span class="string">"json"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//字符串里不包括xml和json，按照普通数据接收</span></span><br><span class="line">                        <span class="keyword">var</span> result = xhr.responseText;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 接收数据之后，调用回调函数</span></span><br><span class="line">                    success &amp;&amp; success(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        url: <span class="string">"index.php"</span>,</span><br><span class="line">        data: &#123; <span class="string">"name"</span>: <span class="string">"liu"</span>, <span class="string">"age"</span>: <span class="number">18</span> &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前赤壁赋</title>
      <link href="/2018/06/01/6.%E5%8F%A4%E6%96%87/%E5%89%8D%E8%B5%A4%E5%A3%81%E8%B5%8B/"/>
      <url>/2018/06/01/6.%E5%8F%A4%E6%96%87/%E5%89%8D%E8%B5%A4%E5%A3%81%E8%B5%8B/</url>
      
        <content type="html"><![CDATA[<center>宋 苏轼</center><p>　　壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p><p>　　于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉；余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p><p>　　苏子愀然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞。’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长 江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</p><p>　　苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。“</p><p>　　客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP操作MySql数据库</title>
      <link href="/2018/06/01/5.PHP/7.PHP%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/06/01/5.PHP/7.PHP%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1.连接数据库"></a>1.连接数据库</h2><ul><li>第一步：设置编码格式<br>php文件的编码 <code>header(&quot;Content-Type:text/html;charset=utf-8&quot;)</code><br>服务器返回数据的编码<code>mysqli_set_charset($conn，&quot;utf8&quot;)</code> 默认就是utf-8，可以不设置</li><li>第二步：连接数据库<br><code>$conn = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;mybase&quot;)</code><br>如果连接成功返回连接对象conn，如果连接失败返回false</li></ul><h2 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2.操作数据库"></a>2.操作数据库</h2><p>操作数据是建立在连接数据库成功的前提下，即已经获取到了连接对象conn</p><h3 id="1-增加和删除语句"><a href="#1-增加和删除语句" class="headerlink" title="1.增加和删除语句"></a>1.增加和删除语句</h3><p>1)创建语句: <code>$sql = &quot;sql语句&quot;</code><br>2)执行语句：<code>mysqli_query($conn,$sql)</code><br>例如：<br><code>$sql = &quot;UPDATE mytable set name=&#39;刘啸&#39;,sex=&#39;男&#39;,age=23 where id = 1&quot;</code><br><code>mysqli_query($conn,$sql)</code><br>返回值 如果成功了返回true 失败了返回false<br>最近一条sql语句产生的错误信息存放在mysqli_error($conn)中</p><h3 id="2-查询语句"><a href="#2-查询语句" class="headerlink" title="2.查询语句"></a>2.查询语句</h3><p>1）创建sql查询语句 <code>$sql = &quot;sql语句&quot;</code><br>2）执行语句：<code>$res = mysqli_query($conn,$sql)</code><br>如果查询失败返回false，如果成功，分为两种情况，可以通过mysqli_num_rows($res)判断：</p><ul><li>有结果集但是没数据时<code>mysqli_num_rows($res) = 0</code></li><li>有结果集也有数据时<code>mysqli_num_rows($res) != 0</code></li></ul><p><strong>有数据时返回的结果也不是表里的具体数据，而是数据的引用</strong>。可以使用以下方法提取具体数据，生成数组：</p><ul><li><code>mysqli_fetch_array($res[,type])</code><pre><code>$res 查询语句的执行结果（结果集）type:限制生成的数组类型，取值有    MYSQLI_NUM 只生成索引数组    MYSQLI_ASSOC 只生成关联数组    MYSQLI_BOTH 同时生成两种数组</code></pre></li><li><code>mysqli_fetch_assoc($res)</code> 只生成关联数组</li><li><code>mysqli_fetch_row($res)</code> 只生成索引数组<br>如果没有读取到数据则返回空;<br>上面的函数都只能读取第一行，但是会自动将指针移动到下一行；<br>想要读取所有数据，需要使用while循环：把数据添加到$data里<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>($arr = mysqli_fetch_array($res,MYSQL_NUM))&#123;</span><br><span class="line">$result[]= $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-关闭数据库的连接"><a href="#3-关闭数据库的连接" class="headerlink" title="3.关闭数据库的连接"></a>3.关闭数据库的连接</h2><p>数据库连接数量有上限，当不需要继续连接数据库时，需要断开连接：<br><code>mysqli_close($conn)</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2018/06/01/5.PHP/6.MySQL/"/>
      <url>/2018/06/01/5.PHP/6.MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MySQL操作"><a href="#一、MySQL操作" class="headerlink" title="一、MySQL操作"></a>一、MySQL操作</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>mysql安装过程 参考菜鸟教程上的安装指导：<a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-install.html</a></p><h2 id="2-可视化工具"><a href="#2-可视化工具" class="headerlink" title="2.可视化工具"></a>2.可视化工具</h2><p>使用Navicat for MySQL</p><h1 id="二、SQL语句"><a href="#二、SQL语句" class="headerlink" title="二、SQL语句"></a>二、SQL语句</h1><h2 id="1-查询语句"><a href="#1-查询语句" class="headerlink" title="1.查询语句"></a>1.查询语句</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190601/DFnG3OGccYOr.png?imageslim" alt="mark"><br>查询所有数据：<br>    <code>SELECT * FROM mytable</code><br>查询某一字段的数据：<br>    <code>SELECT name,hobby FROM mytable</code><br>条件查询：<br>    <code>SELECT * FROM mytable WHERE id=3</code><br>    <code>SELECT * FROM mytable WHERE age&lt;=23</code><br>混合条件查询 ：<br>    and=&amp;&amp; not=! or=||<br>    <code>SELECT * FROM mytable WHERE age&lt;=23 and hobby=&quot;玩&quot;</code><br>可以给mytable起别名p：<br>    <code>SELECT p.name FROM mytable p where p.age=23</code><br>子查询 查询中嵌套另一个查询：<br>    <code>SELECT * FROM mytable WHERE age &gt; (SELECT age FROM mytable WHERE name=&quot;刘啸&quot;)</code><br>模糊查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mytable WHERE name LIKE &quot;刘%&quot;</span><br><span class="line">SELECT * FROM mytable WHERE age BETWEEN 23 and 28</span><br><span class="line">SELECT * FROM mytable WHERE id in &#123;1,3,4&#125;</span><br><span class="line">SELECT * FROM mytable WHERE age is NULL  不能用等号判空</span><br></pre></td></tr></table></figure><p>多表查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student,class where student.cid = class.classid</span><br></pre></td></tr></table></figure><p>更多使用<code>SELECT * FROM student JOIN class ON student.cid = class.classid</code><br>JOIN 还分为left join和right join，写在join左边的是左表<br>    left join：获取左表中所有数据 如果建立关联的字段在右表没有 右表的相应字段为空值<br>    right join：获取右表中所有数据 如果建立关联的字段在左表没有 左表的相应字段为空值</p><h2 id="2-增加语句"><a href="#2-增加语句" class="headerlink" title="2.增加语句"></a>2.增加语句</h2><p><code>insert(into) 表名[(字段1，字段2...)] values(值1，值2...)</code><br>[]表示可以不写字段，如果表名后面不写字段，要为每一个字段设置值；<br>如果表里有标识列，如id，增加时可以给null，系统会自动生成递增的标识；也可以不写标识列的字段，给其他字段的值就可以<br>可以为空的字段可以不给值，建议非空字段一定要赋值</p><h2 id="3-修改语句"><a href="#3-修改语句" class="headerlink" title="3.修改语句"></a>3.修改语句</h2><p><code>update 表名 set 字段1=值1，字段2=值2... where 条件</code><br>修改时要加条件 否则会修改字段的所有值</p><h2 id="4-删除语句"><a href="#4-删除语句" class="headerlink" title="4.删除语句"></a>4.删除语句</h2><p><code>delete from 表名 where 条件</code><br>删除和修改操作都是不可逆的</p><p><strong>注意：查询返回的是结果集，增删改返回的是受影响的行数</strong></p><h1 id="三、常见的数学函数"><a href="#三、常见的数学函数" class="headerlink" title="三、常见的数学函数"></a>三、常见的数学函数</h1><h2 id="1-count-计数函数"><a href="#1-count-计数函数" class="headerlink" title="1.count()计数函数"></a>1.count()计数函数</h2><p>括号里可以写：<code>*</code> 计算行数；<br>括号里写字段是计算当前字段的行数<br>null不计入计数</p><h2 id="2-max-和min-求最值的函数"><a href="#2-max-和min-求最值的函数" class="headerlink" title="2.max()和min() 求最值的函数"></a>2.max()和min() 求最值的函数</h2><p>字母比较是按照ASCII码排序</p><h2 id="3-avg-求平均值"><a href="#3-avg-求平均值" class="headerlink" title="3.avg() 求平均值"></a>3.avg() 求平均值</h2><p>括号里一般是数值型</p><h2 id="4-order-by-排序"><a href="#4-order-by-排序" class="headerlink" title="4. order by 排序"></a>4. order by 排序</h2><p><code>select * from 表名 order by id 排序字段;</code><br>排序字段： 默认是 asc 升序； desc 降序</p><h2 id="5-limit-获取指定范围的数据"><a href="#5-limit-获取指定范围的数据" class="headerlink" title="5.limit 获取指定范围的数据"></a>5.limit 获取指定范围的数据</h2><p>limit如果后面只有一个参数 获取指定的前n条记录:<br><code>select * from 表名 limit 5</code><br>如果后面有两个参数 偏移量,获取的记录数:<br><code>select * from 表名 Limit 2,4  从2开始 取4条数据</code><br>也可以使用<code>select * from 表名 limit 4 offset 2</code><br>偏移从0开始</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态保持-Cookie和Session</title>
      <link href="/2018/05/29/5.PHP/5.cookie%E5%92%8Csession/"/>
      <url>/2018/05/29/5.PHP/5.cookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<h1 id="一、HTTP无状态"><a href="#一、HTTP无状态" class="headerlink" title="一、HTTP无状态"></a>一、HTTP无状态</h1><p>http对事务处理没有记忆能力，不会存储之前请求产生的信息，如果当前步骤需要使用之前的信息，需要就进行重传；<br>大部分情况下 需要使用之前的信息 为了解决http无状态造成的问题，有两种HTTP状态保持方法：cookie和session</p><h1 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h1><h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h2><ul><li>客户端发送请求</li><li>服务器将用户当前操作的相关数据存储到Cookie中（键值对形式name=&gt;value），将cookie和响应结果一起返回给客户端，在请求头中使用set-cookie的方式返回</li><li>客户端接收到响应结果，结果中包含cookie</li><li>客户端再次发送请求时，会将之前的cookie一起发送给服务器</li><li>服务器接收到请求，对请求和客户端携带的cookie再次进行处理</li></ul><h2 id="2-php里面实现cookie"><a href="#2-php里面实现cookie" class="headerlink" title="2.php里面实现cookie"></a>2.php里面实现cookie</h2><h3 id="创建cookie："><a href="#创建cookie：" class="headerlink" title="创建cookie："></a>创建cookie：</h3><pre><code>setcookie(name[,value,expire,path,domain]);</code></pre><p>想要设置后面的参数 必须设置前面的参数<br>expire:有效期 单位是s，时间参考点是php默认起始时间(1970-1-1); 可以设置为time()+秒数；<br>　　　设置永久有效期：把expired设置为PHP_INT_MAX<br>path:访问目录权限 参照是网站根目录；设置目录为父级，子目录也能访问（反过来不行）； /代表整站都能访问<br>domain: 访问域名权限 </p><h3 id="获取cookie："><a href="#获取cookie：" class="headerlink" title="获取cookie："></a>获取cookie：</h3><pre><code>$_COOKIE[name]判断客户端是否有cookie： if(isset($_COOKIE[name])){ ，，， }</code></pre><h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie:"></a>删除cookie:</h3><pre><code>怎么创建就怎么删除，参数个数要对应1.有效期设置为过去时间2.将value设置为空字符串或false3.不设置value</code></pre><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><p>cookie数据不太安全；<br>cookie只能存储字符串值；<br>cookie存储文件容量大小有限制4kb</p><p>案例： 登录功能</p><h1 id="三、Session"><a href="#三、Session" class="headerlink" title="三、Session"></a>三、Session</h1><h2 id="1-session的原理"><a href="#1-session的原理" class="headerlink" title="1.session的原理"></a>1.session的原理</h2><p>1）客户端发送请求<br>2）服务器处理：开启一个session，同时生成一个用于存储数据的文件，为这个文件生成一个id号。将处理结果和id号返回给客户端<br>3）客户端获取处理结果和sessionId<br>4）客户端再次发送请求时，会把之前的sessionId传递给服务器<br>5）服务器根据sessionId找到相应的文件，根据文件对新请求进行处理</p><h2 id="2-php实现session"><a href="#2-php实现session" class="headerlink" title="2.php实现session"></a>2.php实现session</h2><p>php默认不会开启session功能，如果想要使用。需要添加代码session_start();</p><blockquote><p>想要默认开启，通过修改配置文件php.ini下的session.auto_start为1实现。注意：修改后，打开网页就会产生sessionId，不建议修改</p></blockquote><p>session_start的执行过程：<br>    动态生成一个sessionID；<br>    在服务器生成一个存放数据的文件，文件名以sess_sessionId构成；<br>    通过响应头设置cookie，存放了本次产生的sessionID，在将来返回</p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><pre><code>session_start();$_SESSION[&apos;name&apos;] = 值; 可以是各种数据类型</code></pre><h3 id="读取session"><a href="#读取session" class="headerlink" title="读取session"></a>读取session</h3><pre><code>session_start();$user = $_SESSION[&apos;user&apos;];</code></pre><h3 id="删除一个session信息"><a href="#删除一个session信息" class="headerlink" title="删除一个session信息"></a>删除一个session信息</h3><blockquote><p>tips: 删除session是在服务端进行的，通过浏览器查看sessionID会发现还存在，因为浏览器存储的是本地缓存，只有重新打开浏览器才能看到删除效果</p></blockquote><pre><code>session_start();unset($_SESSION[&apos;user&apos;]);</code></pre><h3 id="删除所有session信息"><a href="#删除所有session信息" class="headerlink" title="删除所有session信息"></a>删除所有session信息</h3><pre><code>session_start();方式1：unset($_SESSION);方式2：$_SESSION = []</code></pre><h3 id="销毁session"><a href="#销毁session" class="headerlink" title="销毁session"></a>销毁session</h3><pre><code>session_destroy(); 会销毁整个文件</code></pre><h2 id="3-session的优点"><a href="#3-session的优点" class="headerlink" title="3.session的优点"></a>3.session的优点</h2><p>Session数据存储在服务器端，相比cookie更加安全<br>可以存储除了资源以外的数据类型<br>存储容量大小没有限制，服务器放得下就行</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2018/05/29/5.PHP/4.HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/05/29/5.PHP/4.HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><h2 id="1-http的定义"><a href="#1-http的定义" class="headerlink" title="1.http的定义"></a>1.http的定义</h2><p>超文本传输协议  端与端之间的通讯协议</p><h2 id="2-建立连接-三次握手"><a href="#2-建立连接-三次握手" class="headerlink" title="2.建立连接-三次握手"></a>2.建立连接-三次握手</h2><ol><li>客户端向服务器发送一个连接请求</li><li>服务器向客户端返回一个确认信息</li><li>客户端将请求及这个确认信息发送服务器</li></ol><h2 id="3-关闭连接-四次挥手："><a href="#3-关闭连接-四次挥手：" class="headerlink" title="3.关闭连接-四次挥手："></a>3.关闭连接-四次挥手：</h2><pre><code>tcp标志位有6种标示:    SYN(synchronous建立联机)    ACK(acknowledgement 确认)    PSH(push传送)    FIN(finish结束)    RST(reset重置)    URG(urgent紧急) </code></pre><p>1.Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>2.Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>3.Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>4.Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。      </p><h2 id="4-约定内容："><a href="#4-约定内容：" class="headerlink" title="4.约定内容："></a>4.约定内容：</h2><pre><code>- 请求 / 响应报文格式- 请求方式 —— GET / POST / etc.- 响应状态 —— 200 / 404 / 302 / 304 / etc.- 预设的请求 / 响应头</code></pre><h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><h2 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/W0Ue8N51Qdsm.png?imageslim" alt="mark"><br>        请求行：GET /demo.php HTTP/1.1 即 请求方式 +请求路径 +HTTP 协议版本<br>        请求头：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/bWr2gOaFENki.png?imageslim" alt="mark"><br>        请求体：<br>            这次请求客户端想要发送给服务端的数据正文，一般在 GET 请求时很少用到</p><h2 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/ebEhifGjvaCI.png?imageslim" alt="mark"><br>        状态行： 协议+状态码+状态描述<br>        响应头：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190529/cdb97OubXsba.png?imageslim" alt="mark"><br>        响应体：<br>            服务端想要返回给客户端的数据正文，一般返回的都是 HTML，也可以返回 JavaScript 或者 CSS</p><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><ul><li><p>设置响应文件的类型<br><code>header(&quot;Content-Type: text/css&quot;)</code></p></li><li><p>重定向<br><code>header(&quot;Location: xxx.php&quot;)</code><br><code>header(&quot;refresh:3; url=xxx.php&quot;)</code> 重定向延迟3s跳转</p></li><li><p>下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 让文件下载</span><br><span class="line">header(&apos;Content-Type: application/octet-stream&apos;);</span><br><span class="line">// 设置默认下载文件名</span><br><span class="line">header(&apos;Content-Disposition: attachment; filename=demo.txt&apos;);</span><br></pre></td></tr></table></figure></li><li><p>图片防盗链</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求报文数据</span></span><br><span class="line"><span class="comment">// print_r(getallheaders());</span></span><br><span class="line">$refer = getallheaders()[<span class="string">"Referer"</span>];</span><br><span class="line"><span class="keyword">echo</span> $refer;</span><br><span class="line"><span class="comment">//获取url的各部分</span></span><br><span class="line">print_r(parse_url($refer));</span><br><span class="line">$host = parse_url($refer)[<span class="string">"host"</span>];</span><br><span class="line"><span class="keyword">if</span>($host === <span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"识别主机，响应"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"不响应"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP注册案例源码</title>
      <link href="/2018/05/27/5.PHP/3.PHP%E6%B3%A8%E5%86%8C%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81/"/>
      <url>/2018/05/27/5.PHP/3.PHP%E6%B3%A8%E5%86%8C%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><strong>本案例会把用户数据写入php同级目录下info.txt文件中，头像会存放在php文件同级目录下userAvatar文件夹下；这两个文件/文件夹需要自行创建</strong><br>以下是源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>($_SERVER[<span class="string">"REQUEST_METHOD"</span>]===<span class="string">"POST"</span>)&#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// $_POST打印出来格式如下</span></span><br><span class="line">        <span class="comment">// Array</span></span><br><span class="line">        <span class="comment">//     (</span></span><br><span class="line">        <span class="comment">//         [username] =&gt; liuxiao</span></span><br><span class="line">        <span class="comment">//         [nickname] =&gt; liu</span></span><br><span class="line">        <span class="comment">//         [age] =&gt; 18</span></span><br><span class="line">        <span class="comment">//         [tel] =&gt; 139</span></span><br><span class="line">        <span class="comment">//         [sex] =&gt; 男</span></span><br><span class="line">        <span class="comment">//         [banji] =&gt; 1</span></span><br><span class="line">        <span class="comment">//     )</span></span><br><span class="line">        <span class="comment">// 判断输入是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"username"</span>])||trim($_POST[<span class="string">"username"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入姓名"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"nickname"</span>])||trim($_POST[<span class="string">"nickname"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入昵称"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"age"</span>])||trim($_POST[<span class="string">"age"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入年龄"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"tel"</span>])||trim($_POST[<span class="string">"tel"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入电话"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">"sex"</span>])||trim($_POST[<span class="string">"sex"</span>])==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请输入性别"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//$_FILES的内容</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>($_FILES)||$_FILES[<span class="string">"photo"</span>][<span class="string">"error"</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"请上传头像"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            $type = $_FILES[<span class="string">"photo"</span>][<span class="string">"type"</span>];</span><br><span class="line">            <span class="keyword">if</span>(strpos($type,<span class="string">"image/"</span>)===<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//获取文件后缀名生成随机文件名</span></span><br><span class="line">                $houzhui = strrchr ($_FILES[<span class="string">"photo"</span>][<span class="string">"name"</span>],<span class="string">"."</span>);</span><br><span class="line">                $newFileName = time().rand(<span class="number">1000</span>,<span class="number">9999</span>).$_POST[<span class="string">"username"</span>].$houzhui;</span><br><span class="line">                move_uploaded_file($_FILES[<span class="string">"photo"</span>][<span class="string">"tmp_name"</span>],<span class="string">"./userAvatar/"</span>.$newFileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"上传的不是图片格式"</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        $_POST[]=$newFileName;</span><br><span class="line">        $str = implode($_POST,<span class="string">"|"</span>);<span class="comment">//最终存储到txt文件的字符串</span></span><br><span class="line">        <span class="comment">// echo $str;</span></span><br><span class="line">        file_put_contents(<span class="string">"./info.txt"</span>,$str.<span class="string">"\n"</span>,FILE_APPEND);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"./css/form.css"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">                * &#123;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">            padding: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        body &#123;</span><br><span class="line">            background: <span class="comment">#ccc;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        h1,</span><br><span class="line">        h2,</span><br><span class="line">        h3,</span><br><span class="line">        h4,</span><br><span class="line">        h5,</span><br><span class="line">        h6 &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        form &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            margin: <span class="number">50</span>px auto;</span><br><span class="line">            padding: <span class="number">20</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#eee;</span></span><br><span class="line">            border-radius: <span class="number">10</span>px;</span><br><span class="line">            background: <span class="comment">#fff;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'text'</span>],</span><br><span class="line">        input[type=<span class="string">'select'</span>],</span><br><span class="line">        input[type=<span class="string">'password'</span>],</span><br><span class="line">        input[type=<span class="string">'submit'</span>],</span><br><span class="line">        input[type=<span class="string">'password'</span>],</span><br><span class="line">        input[type=<span class="string">'file'</span>],</span><br><span class="line">        select &#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            display: block;</span><br><span class="line">            height: <span class="number">24</span>px;</span><br><span class="line">            margin-bottom: <span class="number">15</span>px;</span><br><span class="line">            border-radius: <span class="number">3</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#aaa;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'submit'</span>] &#123;</span><br><span class="line">            height: <span class="number">40</span>px;</span><br><span class="line">            background: rgb(<span class="number">209</span>, <span class="number">92</span>, <span class="number">92</span>);</span><br><span class="line">            border: none;</span><br><span class="line">            color: <span class="comment">#fff;</span></span><br><span class="line">            font-size: <span class="number">24</span>px;</span><br><span class="line">            ;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'radio'</span>],</span><br><span class="line">        input[type=<span class="string">'checkbox'</span>] &#123;</span><br><span class="line">            height: <span class="number">20</span>px;</span><br><span class="line">            width: <span class="number">20</span>px;</span><br><span class="line">            <span class="comment">/* display: inline; */</span></span><br><span class="line">            margin: <span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        input[type=<span class="string">'file'</span>] &#123;</span><br><span class="line">            border: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .box &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: <span class="number">10</span>px;</span><br><span class="line">            left: <span class="number">350</span>px;</span><br><span class="line">            width: <span class="number">73</span>px;</span><br><span class="line">            height: <span class="number">73</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid <span class="comment">#666;</span></span><br><span class="line">            border-radius: <span class="number">10</span>%;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;   </span><br><span class="line">    &lt;form action=<span class="string">"&lt;?php echo $_SERVER["</span>PHP_SELF<span class="string">"] ?&gt;"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">        头像： &lt;input type=<span class="string">"file"</span> name=<span class="string">"photo"</span> id=<span class="string">"photo"</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;</span><br><span class="line">        昵称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"nickname"</span>&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</span><br><span class="line">        电话：&lt;input type=<span class="string">"text"</span> name=<span class="string">"tel"</span>&gt;</span><br><span class="line">        性别：&lt;input type=<span class="string">"radio"</span> name=<span class="string">"sex"</span> value=<span class="string">"男"</span> checked&gt;男</span><br><span class="line">             &lt;input type=<span class="string">"radio"</span> name=<span class="string">"sex"</span> value=<span class="string">"女"</span> &gt;女</span><br><span class="line">             &lt;br&gt;</span><br><span class="line">        班级：&lt;select name=<span class="string">"banji"</span> &gt;</span><br><span class="line">                &lt;option value=<span class="string">"1"</span>&gt;黑马<span class="number">11</span>期&lt;/option&gt;</span><br><span class="line">                &lt;option value=<span class="string">"2"</span>&gt;黑马<span class="number">12</span>期&lt;/option&gt;</span><br><span class="line">                &lt;option value=<span class="string">"3"</span>&gt;黑马<span class="number">13</span>期&lt;/option&gt;</span><br><span class="line">             &lt;/select&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"添加信息"</span>&gt;</span><br><span class="line">        &lt;img class="box"&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现头像实时预览功能</span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> photo = document.querySelector(<span class="string">"#photo"</span>);</span><br><span class="line">        photo.onchange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> file = photo.files[<span class="number">0</span>]; <span class="comment">//表单的files属性存储了所有相关信息</span></span><br><span class="line">            <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();<span class="comment">//读取器</span></span><br><span class="line">            reader.readAsDataURL(file);<span class="comment">//读取器读取图片</span></span><br><span class="line">            reader.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//读取完毕后把图片路径给盒子的src</span></span><br><span class="line">                <span class="keyword">var</span> box = document.querySelector(<span class="string">".box"</span>);</span><br><span class="line">                box.src = reader.result;</span><br><span class="line">                console.log(reader.result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐列表案例</title>
      <link href="/2018/05/27/5.PHP/2.2.%E9%9F%B3%E4%B9%90%E5%88%97%E8%A1%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/05/27/5.PHP/2.2.%E9%9F%B3%E4%B9%90%E5%88%97%E8%A1%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、音乐列表"><a href="#一、音乐列表" class="headerlink" title="一、音乐列表"></a>一、音乐列表</h1><h2 id="1-功能点"><a href="#1-功能点" class="headerlink" title="1.功能点"></a>1.功能点</h2><pre><code>表格展示数据，增删改歌曲信息</code></pre><h2 id="2-数据存储"><a href="#2-数据存储" class="headerlink" title="2.数据存储"></a>2.数据存储</h2><p>数据如何描述和保存： 不再使用字符串加|的格式，因为无法区分值对应的属性名。<br>使用json描述数据： javascript object notation js对象的描述</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">属性名1:属性值,</span><br><span class="line">属性名2:属性值</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">属性名3:属性值,</span><br><span class="line">属性名4:属性值</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>语法：属性和值都用双引号，除非是数字；json文件中不能写任何注释；没有undifined<br>描述对象使用{}，描述数组使用[]<br><code>json_decode($str,boolean)</code>: 将json格式的字符串转换为php数组或对象<br>　　　字符串中的[]默认转换为数组，{}默认转换为对象<br>　　　第二个参数如果是true转换为数组，如果是false转换为对象<br><code>json_encode($arr或$obj)</code>: 将php数组或对象转换为json格式的字符串</p><h2 id="3-判断输入数据是否合法"><a href="#3-判断输入数据是否合法" class="headerlink" title="3.判断输入数据是否合法"></a>3.判断输入数据是否合法</h2><p>之前用echo提示，只能提示一个错误，并且显示的位置不合理；<br>需要一次性提示用户所有的错误输入信息；判断出错后，先存储所有的错误信息到数组errorArr里，后面再统一处理<br>        in_array方法（元素，数组）判断元素是否在数组中<br>操作提示信息盒子的类名：<br><code>&lt;?php echo in_array(&quot;title&quot;,_GLOBAL[&quot;error&quot;])?&quot;show&quot;:&quot;&quot; ?&gt;</code></p><h2 id="4-新增音乐功能"><a href="#4-新增音乐功能" class="headerlink" title="4.新增音乐功能"></a>4.新增音乐功能</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190603/LLSQmnOgPBsS.png?imageslim" alt="mark"><br>id用于标识区分是哪一行，方便后面的删除和编辑</p><h2 id="5-删除音乐功能"><a href="#5-删除音乐功能" class="headerlink" title="5.删除音乐功能"></a>5.删除音乐功能</h2><pre><code>`array_splice(数组，起始索引，删除几个元素)；`</code></pre><p>获取id号；<br>获取json数据 ，转换为数组；<br>根据id号删除数组中的元素（遍历数组）；<br>将删除后的数组数据重新写入json文件；<br>页面跳转到list.php列表页</p><h2 id="6-修改音乐功能"><a href="#6-修改音乐功能" class="headerlink" title="6.修改音乐功能"></a>6.修改音乐功能</h2>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GET和POST方法</title>
      <link href="/2018/05/27/5.PHP/2.1.GET%E5%92%8CPOST%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/27/5.PHP/2.1.GET%E5%92%8CPOST%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、GET请求"><a href="#一、GET请求" class="headerlink" title="一、GET请求"></a>一、GET请求</h1><h2 id="1-什么是GET"><a href="#1-什么是GET" class="headerlink" title="1.什么是GET"></a>1.什么是GET</h2><p>获取服务端的数据</p><h2 id="2-发起GET请求常见的方式"><a href="#2-发起GET请求常见的方式" class="headerlink" title="2.发起GET请求常见的方式"></a>2.发起GET请求常见的方式</h2><p>地址栏访问；<br>src/href；<br>表单；<br>网页中各种搜索框，详情页面，大部分超链接</p><h2 id="3-GET方式提交数据的格式"><a href="#3-GET方式提交数据的格式" class="headerlink" title="3.GET方式提交数据的格式"></a>3.GET方式提交数据的格式</h2><p><code>index.php?userName=jack&amp;password=123</code></p><h2 id="4-GET的特点"><a href="#4-GET的特点" class="headerlink" title="4.GET的特点"></a>4.GET的特点</h2><p>get方式在url后面拼接参数，只能以文本的形式传递数据<br>传递的数据量小，4KB左右（不同浏览器会有差异）<br>安全性低，会将数据显示在地址栏<br>速度快，通常用于对安全性要求不高的请求</p><h1 id="二、POST请求"><a href="#二、POST请求" class="headerlink" title="二、POST请求"></a>二、POST请求</h1><h2 id="1-什么是POST"><a href="#1-什么是POST" class="headerlink" title="1.什么是POST"></a>1.什么是POST</h2><p>字面上理解，post就是指<code>发送，提交</code>,它可以向指定的资源提交要被处理的数据</p><h2 id="2-为什么需要POST请求"><a href="#2-为什么需要POST请求" class="headerlink" title="2.为什么需要POST请求"></a>2.为什么需要POST请求</h2><p>GET方式提交数据通过URL传递到请求的页面，提交的数据量一般较小，用于请求页面数据。此外，GET方式传递的数据安全性低, 对于密码等隐私信息、文件上传必须使用POST方式提交。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190527/7xl1jbqYIx4u.png?imageslim" alt="mark"><br>要求：如果使用表单方式进行提交，表单的method必须设置为POST</p><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><p>1-post 方式 安全性比较高<br>2-传递数据量大，请求对数据长度没有要求<br>3-请求不会被缓存，也不会保留在浏览器历史记录中<br>用于：密码等安全性要求比较高的场合，提交的数据量比较大：发布文章，上传文件。</p><blockquote><p>POST方式提交数据上限默认为8M（可以在PHP的配置文件post_max_size选项中修改）</p></blockquote><h1 id="三、表单处理"><a href="#三、表单处理" class="headerlink" title="三、表单处理"></a>三、表单处理</h1><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>form表单元素有两个重要的属性：<br>            action：处理数据的页面，一般是后台页面xxx.php<br>            method：get/post<br>提交表单元素的数据 <strong>必须设置name属性</strong>，这样才能生成url里面的key=value的结构</p><p>php里有三个超全局变量，都是关联数组， 用于接收表单提交的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_GET  存储了以GET方法提交的参数</span><br><span class="line">$_POST 存储了以POST方法提交的参数</span><br><span class="line">$_REQUEST：用于获取 GET 或 POST 方式提交的参数</span><br></pre></td></tr></table></figure><h2 id="2-SERVER"><a href="#2-SERVER" class="headerlink" title="2.$_SERVER"></a>2.$_SERVER</h2><p>$_SERVER 存储了用户请求的相关数据，也是关联数组，常用的属性有：<br>    PHP_SELF: 获取当前文件的路径<br>    REQUEST_METHOD：请求方法名称<br>一般处理请求时需要进行判断再输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($_SERVER[&apos;REQUEST_METHOD&apos;] === &apos;POST&apos;) &#123;</span><br><span class="line">  // 表单提交请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常见表单元素处理方式"><a href="#3-常见表单元素处理方式" class="headerlink" title="3.常见表单元素处理方式"></a>3.常见表单元素处理方式</h2><p>系统会自动收集表单属性的value值<br><strong>单选按钮radio</strong>： 如果不设置value值，选中状态收集到的值是on<br><strong>复选框checkbox</strong>：如果不设置value值，选中状态收集到的值是on; 多个复选框name值设置为相同的并且要加[]，系统会把所有选中的值存储到数组中<br><strong>下拉列表select</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;sel&quot;&gt; </span><br><span class="line">&lt;option value=&quot;1&quot;&gt;唱&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;2&quot;&gt;跳&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;3&quot;&gt;rap&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;4&quot;&gt;篮球&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>如果没有给option设置value，会传递被选中的Option的文字内容；如果设置了value就会传递value </p><h2 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4.文件上传"></a>4.文件上传</h2><h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作:"></a>客户端操作:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;myFile&quot; multiple&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>form的enctype属性取值有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded 用来处理字符串 默认的编码格式</span><br><span class="line">multipart/form-data 用于处理特殊数据 如文件</span><br></pre></td></tr></table></figure><p>input的multiple属性: <code>添加multiple属性可以选择多个文件</code></p><h3 id="服务端操作："><a href="#服务端操作：" class="headerlink" title="服务端操作："></a>服务端操作：</h3><p>文件上传之后的相关信息都存储在$_FILES中，也是关联数组，$_FILES打印出来如下：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190527/WIKqASJ8BNIS.png?imageslim" alt="mark"><br>文件上传之后 如果不改变存放位置，会被删除，要使用函数移动文件位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(源文件全路径，目标路径);</span><br></pre></td></tr></table></figure><p>例如: <code>move_uploaded_file($_FILES[myFile][tmp_name],&quot;./upload/&quot;.文件名&quot;);</code></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1)判断用户是否进行了提交<br>            使用empty($_FILES)判断数组里是否有内容，有再进行移动位置<br>2)限制用户上传文件的类型：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1.设置表单属性 accept=&quot;.png,.jpg&quot;</span><br><span class="line">方法2.在服务端判断：获取$_FILES里面的文件类型$type=$_FILES[myFile][type]</span><br><span class="line">strpos(源字符串，目标字符串) 获取目标字符串在源字符串中第一次出现的索引，从0开始</span><br><span class="line">判断是否是图片类型：if（strpos($type,&quot;image/&quot;)===0）</span><br></pre></td></tr></table></figure><p>3)上传多个文件保存时不重名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把 时间time()+随机数rand(m,n)+文件扩展名 拼接作为新的文件名</span><br><span class="line">获取文件扩展名：strrchr(字符串m，字符n);  截取字符串m从n之后的字符，包含字符n</span><br></pre></td></tr></table></figure><p>4)php默认上传文件大小限制是2M，在php.ini中修改<code>upload_max_filesize</code>每次post请求传递的数据默认限制为8M，在php.ini中修改<code>post_max_size</code></p><p>5)上传多个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**客户端处理</span><br><span class="line">方式1：input表单添加multiple属性，但是只是能够选择多个文件，给input的name值后面添加中括号，这样$_FILES就能接收多个文件</span><br><span class="line">方式2：写多个input，并且给name加中括号</span><br><span class="line">**服务端处理</span><br><span class="line">和单个文件处理基本思想相同</span><br><span class="line">name和tmp_name只需要遍历一个即可，遍历时用$key=$value的方式，因为两个数组的索引是一一对应的</span><br></pre></td></tr></table></figure><h1 id="四、案例：基于文件的注册"><a href="#四、案例：基于文件的注册" class="headerlink" title="四、案例：基于文件的注册"></a>四、案例：基于文件的注册</h1><ul><li>php中如果直接写return，整个php代码执行就结束了；如果在方法中return，则只结束方法的执行，因此：判断完用户发送的是POST请求后，调用一个函数register，而不是直接把代码写在判断中</li><li>trim()方法 可以去除字符串中的空格</li><li>数据写入txt文件的格式是 qq|qqq|123|…</li><li>implode() 将关联数组的数据以指定的分隔符分割，转换为字符串(和explode相反)</li></ul><h1 id="五、图片即时预览功能"><a href="#五、图片即时预览功能" class="headerlink" title="五、图片即时预览功能"></a>五、图片即时预览功能</h1><p>使用js编写；<br>为文件输入表单添加change事件，操作写在change事件内；<br>图片存储在表单的files属性里,是一个伪数组； 表单.files[0]可以获取图片的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader(); 定义一个文件读取器</span><br><span class="line">reader.readAsDataURL(图片) 读取图片  读取结果存放在reader.result里</span><br></pre></td></tr></table></figure><p>本案例源码在下一篇日志。由于博客没有添加代码折叠功能，代码占据体积较大。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滕王阁序</title>
      <link href="/2018/05/27/6.%E5%8F%A4%E6%96%87/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/"/>
      <url>/2018/05/27/6.%E5%8F%A4%E6%96%87/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<center>唐 王勃</center><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><center>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</center><center>画栋朝飞南浦云，珠帘暮卷西山雨。</center><center>闲云潭影日悠悠，物换星移几度秋。</center><center>阁中帝子今何在？槛外长江空自流。</center>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滕王阁序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP介绍和语法</title>
      <link href="/2018/05/25/5.PHP/1.PHP%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/25/5.PHP/1.PHP%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、phpStudy工具使用"><a href="#一、phpStudy工具使用" class="headerlink" title="一、phpStudy工具使用"></a>一、phpStudy工具使用</h1><h2 id="1-设置网站根目录"><a href="#1-设置网站根目录" class="headerlink" title="1.设置网站根目录"></a>1.设置网站根目录</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/7VX3iJlHdLaw.png?imageslim" alt="mark"></p><h2 id="2-创建虚拟主机域名"><a href="#2-创建虚拟主机域名" class="headerlink" title="2.创建虚拟主机域名"></a>2.创建虚拟主机域名</h2><p>1.在根目录下创建子文件夹<br>2.在站点域名管理新建域名<br>3.修改host文件 映射添加的域名<br>4.修改配置文件vhosts.ini 在相应域名下修改 <code>Options Indexes FollowSymLinks ExecCGI</code></p><h2 id="3-VS配置文件修改"><a href="#3-VS配置文件修改" class="headerlink" title="3.VS配置文件修改"></a>3.VS配置文件修改</h2><p><code>&quot;php.validate.executablePath&quot;:路径</code></p><hr><h1 id="二、php语法特点"><a href="#二、php语法特点" class="headerlink" title="二、php语法特点"></a>二、php语法特点</h1><h2 id="1-输出语句"><a href="#1-输出语句" class="headerlink" title="1.输出语句"></a>1.输出语句</h2><p><code>echo</code> 输出字符串   echo “123”,”456”;  可以输出多个字符串<br><code>print</code>输出字符串   print “123”;    只能输出一个字符串<br><code>print_r();</code> 可以输出复杂类型 输出形式是key和值<br><code>var_dump();</code> 可以输出复杂类型 输出形式是key和值 同时可以获取值的长度<br><code>die()</code> 输出后,后面的代码不再执行</p><p>输出细节： 如果输出为true结果为1；如果为false输出为null</p><h2 id="2-与html混编"><a href="#2-与html混编" class="headerlink" title="2.与html混编"></a>2.与html混编</h2><p>php代码要写在php结构以内<code>&lt;?php代码 ?&gt;</code><br>html代码不能写在php结构内<br>1）普通嵌入<br><code>&lt;p&gt;&lt;?php代码 ?&gt;&lt;/p&gt;</code><br>2）混合编写<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/TVeSqwzC4svU.png?imageslim" alt="mark">    </p><h2 id="3-php注释"><a href="#3-php注释" class="headerlink" title="3.php注释"></a>3.php注释</h2><p>单行：#可以进行单行注释 但不常用<br>多行：<code>/*多行注释*/</code></p><hr><h1 id="三、php语法"><a href="#三、php语法" class="headerlink" title="三、php语法"></a>三、php语法</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><ul><li>所有的变量声明 必须以$符号做前缀</li><li>变量名区分大小写</li><li>变量名由字母，数字，下划线构成</li><li>声明变量时无需关注类型，和js的弱类型相似；</li><li>如果只声明不赋值，变量值默认为空</li><li>与变量相关的函数：<br>　　-isset() 判断变量是否存在/变量值是否为空，返回值是true和false<br>　　-empty() 判断变量是否为空  “”, 0, “0”, null, false, array()<br>　　-unset() 删除变量<br>　　　如果删除变量会把它的值置空；<br>　　　可以同时删除多个变量，中间加逗号<br>　　　如果在函数中删除全局变量，并不会真的 将全局变量删除</li></ul><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="索引数组："><a href="#索引数组：" class="headerlink" title="索引数组："></a>索引数组：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">或者 $arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组:"></a>关联数组:</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">'key1'</span> =&gt; <span class="string">'value1'</span>, <span class="string">'key2'</span> =&gt; <span class="string">'value2'</span>);</span><br><span class="line">或者$arr2 = [<span class="string">'key1'</span> =&gt; <span class="string">'value1'</span>, <span class="string">'key2'</span> =&gt; <span class="string">'value2'</span>];</span><br></pre></td></tr></table></figure><h3 id="隐形数组："><a href="#隐形数组：" class="headerlink" title="隐形数组："></a>隐形数组：</h3><p>$arr[] = 1  系统自动生成索引<br>对于索引数组 自动递增数组的索引；<br>对于关联数组 索引从0开始</p><h3 id="二维数组："><a href="#二维数组：" class="headerlink" title="二维数组："></a>二维数组：</h3><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/2GuTljX0D7n8.png?imageslim" alt="mark"></p><h3 id="索引数组的遍历："><a href="#索引数组的遍历：" class="headerlink" title="索引数组的遍历："></a>索引数组的遍历：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($arr);$i++)&#123;</span><br><span class="line"><span class="keyword">echo</span> $arr[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联数组的遍历："><a href="#关联数组的遍历：" class="headerlink" title="关联数组的遍历："></a>关联数组的遍历：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key=&gt;$value)&#123;</span><br><span class="line"><span class="keyword">echo</span> $key;</span><br><span class="line"><span class="keyword">echo</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以遍历索引数组<br>括号里不需要key可以不写</p><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $value)&#123;</span><br><span class="line"><span class="keyword">foreach</span>($value <span class="keyword">as</span> $value1)&#123;</span><br><span class="line">print_r($value1);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h2><ul><li>强制类型转换：<br>在变量前面添加：  (类型)变量;<br>任何变量都可以转换为数组： (array)变量  变量值会变成数组的元素</li><li>自动类型转换：<br>php大部分情况下都是自动转换</li></ul><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算术运算符： + - * / % ++ --</span><br><span class="line">赋值运算符：= += -= *= /=</span><br><span class="line">逻辑运算符： ! &amp;&amp; ||</span><br><span class="line">比较运算符： &gt; &gt;= &lt; &lt;= == === !=</span><br><span class="line">三元运算符： a&gt;b? &quot;xxx&quot; : &quot;xxx&quot;</span><br></pre></td></tr></table></figure><ul><li>加号+：只能是算术运算符，自动将加号两边的变量转换为数字，如果可以转换就转换，如果不能转换会返回这个数据类型的默认值：int-&gt;0  object-&gt;null  bool-&gt;false   float-&gt;0.0 </li><li>点号.: 用于连接字符串</li></ul><h2 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5.流程控制"></a>5.流程控制</h2><p>if分支指令式写法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>():</span><br><span class="line"><span class="keyword">elseif</span>():</span><br><span class="line"><span class="keyword">elseif</span>():</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="keyword">endif</span>;</span><br></pre></td></tr></table></figure><p>for指令式写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>():</span><br><span class="line"><span class="keyword">endfor</span>;</span><br></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><p>和js的区别：<br>　　　在js中函数内部可以使用外部的全局变量；<br>　　　但是在php中函数内部不能使用函数外部的成员<br>　　　想要在函数内部使用外部的变量（针对不传参数的情况），需要使用关键字global：<br>　　　　　　<code>global $num;</code><br>把外部变量$num声明为内部可以使用的全局变量　　　　　<br>如果想要在函数内修改$num的值，需要另起一行 $num = 10;<br>如果在函数内修改了全局变量的值，那么函数外使用到这个值也会受影响</p><h2 id="7-php超全局变量"><a href="#7-php超全局变量" class="headerlink" title="7.php超全局变量"></a>7.php超全局变量</h2><p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。<br>在函数或方法中无需执行 global $variable; 就可以访问它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS — 引用全局作用域中可用的全部变量，存储了所有的全局变量</span><br><span class="line">$_SERVER — 获取服务端相关信息</span><br><span class="line">$_REQUEST — 获取提交参数</span><br><span class="line">$_POST — 获取 POST 提交参数</span><br><span class="line">$_GET — 获取 GET 提交参数</span><br><span class="line">$_FILES — 获取上传文件</span><br><span class="line">$_ENV — 操作环境变量</span><br><span class="line">$_COOKIE — 操作 Cookie</span><br><span class="line">$_SESSION — 操作 Session</span><br></pre></td></tr></table></figure><h2 id="8-常量"><a href="#8-常量" class="headerlink" title="8.常量"></a>8.常量</h2><p>定义语法： <code>define(名称，值，是否对大小写敏感);</code><br>常量名一般大写；第三个参数insensitive：默认是false，区分大小写<br>例如 define(“PI”,3.14,false);<br><strong>php中的魔术常量</strong>： 根据不同的使用场合返回不同的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__LINE__：获取当前的代码行</span><br><span class="line">__FILE__:获取当前文件路径：目录+文件名</span><br><span class="line">__DIR__:获取当前文件目录</span><br><span class="line">__FUNCTION__:获取当前魔术常量所在的函数</span><br></pre></td></tr></table></figure><h2 id="9-载入其他文件"><a href="#9-载入其他文件" class="headerlink" title="9.载入其他文件"></a>9.载入其他文件</h2><p>本质：把其他php文件的代码复制到载入文件的地方<br>PHP中引入其他 PHP 文件有四种方式：</p><ul><li><p>require    文件载入失败会影响后续代码执行；重复载入文件会载入多次</p></li><li><p>require_once  文件载入失败会影响后续代码执行；重复载入文件也只会载入一次</p></li><li><p>include    文件载入失败不会影响后续代码执行；重复载入文件会载入多次</p></li><li><p>include_once  文件载入失败不会影响后续代码执行；重复载入文件也只会载入一次</p></li></ul><p>使用环境：<br>如果是公共文件，不能影响后续代码执行，要使用include；<br>如果是必须文件，不能缺少，使用require</p><h2 id="10-常用API"><a href="#10-常用API" class="headerlink" title="10.常用API"></a>10.常用API</h2><p><code>strlen($str)</code> 获取字符串的长度<br>　　　不能处理宽字符集，如中文等；GB2312每个字符占2字节；UTF-8每个字符占3字节<br><code>mb_internal_encoding()</code> 获取php当前文件的默认编码<br><code>mb_strlen($str)</code>获取字符串的长度，能够处理宽字符集，把中文字符识别成一个字节<br>　　　默认情况下不能使用，需要在配置文件php.ini里修改php_mbstring.dll字段<br><code>explode(&quot;分隔符&quot;,$str)</code> 把字符串按照分隔符分割为数组<br><code>count($arr)</code>获取数组长度<br><code>date(&quot;Y-m-d H:i:s&quot;)</code>获取当前时间<br>　　　默认是格林威治时间，修改php.ini的timezone字段可以获取本地时间<br>　　　可以通过 strtotime() 将有格式的时间字符串转换为时间戳<br><code>time()</code>获取从格林威治时间 1970-01-01 00:00:00到当前时间的秒数</p><h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><p><code>file_get_contents 读取文件内容；</code><br>　　　读取成功返回文件内容；读取失败返回false<br>　　　读取图片时要设置浏览器的读取方式:<code>header(&quot;Content-Type:image/jpeg&quot;);</code><br><code>file_put_contents(文件路径,需要写入的内容,FILE_APPEND);</code><br>　　　写入内容，同时返回写入的长度,第三个参数如果添加，是追加内容，不添加会覆盖原有文件内容</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/14.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/14.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1.什么是正则表达式"></a>1.什么是正则表达式</h2><p>用于匹配规律规则的表达式；正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h2><p>1.给定的字符串是否符合正则表达式的过滤逻辑(匹配)<br>2.可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)<br>3.强大的字符串替换能力(替换)</p><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><ol><li>灵活性、逻辑性和功能性非常的强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂</li></ol><hr><h1 id="二、组成"><a href="#二、组成" class="headerlink" title="二、组成"></a>二、组成</h1><h2 id="1-普通字符"><a href="#1-普通字符" class="headerlink" title="1.普通字符"></a>1.普通字符</h2><pre><code>如abc，123等</code></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h2><p>正则表达式中有特殊意义的字符<br>1）常用元字符<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/tcrNY9X9hDNz.png?imageslim" alt="mark"><br>2）限定符<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/zenqTADv6Bc2.png?imageslim" alt="mark"></p><p>[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思<br>[^]  匹配除中括号以内的内容<br>\ 转义符 匹配有特殊意义的字符时，需要进行转义<br>| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱<br>() 从两个直接量中选择一个，例如：gr(a|e)y匹配gray和grey<br><code>[\u4e00-\u9fa5]</code> 匹配汉字</p><hr><h1 id="三、JS里的正则表达式"><a href="#三、JS里的正则表达式" class="headerlink" title="三、JS里的正则表达式"></a>三、JS里的正则表达式</h1><h2 id="1-正则对象"><a href="#1-正则对象" class="headerlink" title="1.正则对象"></a>1.正则对象</h2><p>内置对象RegExp  regularExpression</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span>：<span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(表达式，flag);  <span class="comment">//括号内是字符串格式</span></span><br><span class="line">方式<span class="number">2</span>：<span class="keyword">var</span> reg = <span class="regexp">/表达式/</span>flag  <span class="comment">//不需要是字符串格式，不加''</span></span><br></pre></td></tr></table></figure><p>flag: ‘i’ 忽略大小写   ‘g’ 全局匹配   ‘gi’全局匹配并且忽略大小写</p><h2 id="2-正则表达式的方法"><a href="#2-正则表达式的方法" class="headerlink" title="2.正则表达式的方法"></a>2.正则表达式的方法</h2><p><strong>test和exec是正则对象的方法</strong><br><strong>match,replace,split是字符串的方法</strong></p><h3 id="1）匹配："><a href="#1）匹配：" class="headerlink" title="1）匹配："></a>1）匹配：</h3><p><code>reg.test(str)    如果str和reg匹配返回true，否则返回false</code></p><h3 id="2）提取："><a href="#2）提取：" class="headerlink" title="2）提取："></a>2）提取：</h3><p>提取时reg不写开始和结束符号，经常使用全局匹配：<code>/表达式/g</code><br><code>reg.exec(str)</code>  一次只返回符合表达式的一个结果<br><code>str.match(reg)</code> 返回str字符串中符合表达式的结果，如果是全局匹配，会返回所有结果<br>返回值都是数组形式</p><h3 id="3）分组提取："><a href="#3）分组提取：" class="headerlink" title="3）分组提取："></a>3）分组提取：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'2019-5-22'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/</span>;</span><br><span class="line">reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>把reg用括号分成不同的组；<br>执行任意一种表达式方法后，可以用<code>RegExp.$1</code>获取第一组，<code>RegExp.$2</code>获取第二组…</p><h3 id="4）切割split"><a href="#4）切割split" class="headerlink" title="4）切割split"></a>4）切割split</h3><p>字符串的split方法可以配合正则表达式使用<br><code>str.split(/[分隔符]/)  返回的是数组</code></p><h3 id="5）替换replace"><a href="#5）替换replace" class="headerlink" title="5）替换replace"></a>5）替换replace</h3><p><code>str.replace(字符1，字符2);</code><br>把字符1替换为字符2，只替换匹配的第一个；<br>字符1可以使用正则表达式，加上全局匹配g，这样就可以全部替换<br>去掉字符串所有空格的第二种方法 <code>str.split(&#39;&#39;).join(&#39;&#39;);</code></p><h2 id="3-贪婪模式和非贪婪模式"><a href="#3-贪婪模式和非贪婪模式" class="headerlink" title="3.贪婪模式和非贪婪模式"></a>3.贪婪模式和非贪婪模式</h2><p><strong>贪婪模式</strong>：正则表达式进行匹配时，默认是贪婪模式；<br>　　　　　例如匹配页面所有的标签&lt;.+&gt; 这样会把双标签内的文本也获取到；<br><strong>非贪婪模式</strong>： &lt;.+?&gt;在结束符号之前加问号，这样匹配到一个符合的就不再匹配后续字符</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包、递归和对象拷贝</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/13.%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/13.%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="函数的执行过程"><a href="#函数的执行过程" class="headerlink" title="函数的执行过程"></a>函数的执行过程</h2><p>调用函数：创建内存地址<br>1）进栈 进入执行环境<br>2）压栈 执行当前环境的代码<br>3）出栈 返回执行环境<br>4）销毁内存空间</p><h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><p>一个作用域可以访问其他作用域的变量；<br>一个封闭的执行环境（隔离区域）<br>函数才能起到闭包作用</p><h2 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h2><p>在一个作用域内部 访问外部的变量或者函数</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>函数调用函数本身，注意添加结束条件，否则会出现内存溢出问题</p><p>递归的应用：遍历DOM树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadTree</span>(<span class="params">parent, callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parent.children.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> child = parent.children[i];</span><br><span class="line"><span class="keyword">if</span> (callback) &#123;</span><br><span class="line">callback(child);</span><br><span class="line">&#125;</span><br><span class="line">loadTree(child, callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h1><p>把obj1的成员复制给obj2 </p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">obj2[k] = obj1[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只复制obj1的第一层成员，如果obj1里面还有obj3或者数组，那么obj2只是复制了obj3的地址，不会创建新的对象；<br>拷贝完成后，修改obj1的复杂类型，会同步修改obj2</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>拷贝obj1的多层属性;<br>拷贝完成后，obj1中的属性发生变化，不会影响obj2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj1) &#123;</span><br><span class="line"><span class="comment">//如果是数组</span></span><br><span class="line"><span class="keyword">if</span> (obj1[k] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">obj2[k] = [];</span><br><span class="line">deepCopy(obj1[k], obj2[k]); <span class="comment">//递归调用拷贝方法;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是object类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj1[k] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">obj2[k] = &#123;&#125;;</span><br><span class="line">deepCopy(obj1[k], obj2[k]); <span class="comment">//递归调用拷贝方法;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">obj2[k] = obj1[k]; <span class="comment">//普通拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断顺序不能改变，因为数组也属于对象</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数高级</title>
      <link href="/2017/12/20/4.js%E9%AB%98%E7%BA%A7/12.%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
      <url>/2017/12/20/4.js%E9%AB%98%E7%BA%A7/12.%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="声明函数的第三种方式"><a href="#声明函数的第三种方式" class="headerlink" title="声明函数的第三种方式"></a>声明函数的第三种方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function(&apos;var name=&quot;liuxiao&quot;;console.log(name)&apos;);</span><br></pre></td></tr></table></figure><p>传参数写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function(&apos;a&apos;,&apos;b&apos;,&apos;console.log(a+b)&apos;);</span><br><span class="line">fn(1,2)</span><br></pre></td></tr></table></figure><p>这种方式运行速度较慢，一般不使用;<br>console.dir(fn);会发现函数也是对象，fn是Function的实例</p><h2 id="函数调用方式和this指向"><a href="#函数调用方式和this指向" class="headerlink" title="函数调用方式和this指向"></a>函数调用方式和this指向</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190522/xmfFjGt5FfJS.png?imageslim" alt="mark"><br>函数内部的this指向，不是由书写的时候确定的，而是在函数调用时确定的</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><p>处理函数内部 this 指向问题的三个方法<br>1）fn.call(obj,其他参数)<br>改变this指向为obj，并且调用，返回值就是函数的返回值<br>应用： 让伪数组可以调用数组的方法</p><p>2）fn.apply(obj,[参数数组])<br>改变this指向为obj，并且调用，返回值就是函数的返回值；<br>参数以数组的形式传递 ，并不是真的数组<br>应用：可以把数组展开，每一项传递给方法<br>求数组的最大值；打印数组中的每一项</p><p>3）fn.bind(obj,其他参数)<br>改变this指向为obj，不调用，返回新的函数，需要定义变量接收bind<br>应用： 改变定时器的this指向；改变事件处理函数的this指向</p><h2 id="函数中的其他成员"><a href="#函数中的其他成员" class="headerlink" title="函数中的其他成员"></a>函数中的其他成员</h2><p>1）arguments<br>实参的伪数组<br>2）caller<br>函数的调用者，如果在全局调用，返回null<br>3）name<br>函数的名字<br>4）length<br>函数形参的个数</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>当函数作为参数或者返回值时，就产生了高阶函数</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/11.js%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/11.js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类,新的类能吸收已有类的数据属性和行为,并能扩展新的能力<br>如Student和Teacher的共同成员 提取到 Person里，实现代码复用<br>一般做框架时才用继承，做网页特效不使用继承</p><h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">name</span>: <span class="string">'liuxiao'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">sex</span>: <span class="string">'男'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="直接复制"><a href="#直接复制" class="headerlink" title="直接复制"></a>直接复制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o2[k]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o2[k] = o1[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(o2);</span><br></pre></td></tr></table></figure><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child[k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                child[k] = parent[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    extend(o1, o2);</span><br><span class="line">    <span class="built_in">console</span>.log(o2)</span><br></pre></td></tr></table></figure><h3 id="用arguments传参数"><a href="#用arguments传参数" class="headerlink" title="用arguments传参数"></a>用arguments传参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        extend: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> <span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>[k]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>[k] = <span class="built_in">arguments</span>[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.extend(o1, o2, o3);</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>缺点：原型继承无法设置构造函数的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = <span class="string">'liuxiao'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Stu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Stu.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">   Stu.prototype.constructor = Person;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> stu = <span class="keyword">new</span> Stu();</span><br><span class="line">   <span class="built_in">console</span>.log(stu.name);</span><br></pre></td></tr></table></figure><p>不能给stu设置参数。只能继承Person的参数；</p><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>缺点：无法重用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'liuxiao'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stu); <span class="comment">//可以设置参数</span></span><br><span class="line">    stu.sayHi(); <span class="comment">//报错提示没有此方法</span></span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>既能设置参数 又能调用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">    Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'liuxiao'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stu);</span><br><span class="line">    stu.sayHi();</span><br></pre></td></tr></table></figure><h2 id="快速继承create"><a href="#快速继承create" class="headerlink" title="快速继承create()"></a>快速继承create()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">        name: <span class="string">'liuxiao'</span>,</span><br><span class="line">        friends: <span class="string">'dyx'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">    <span class="built_in">console</span>.log(anotherPerson.friends)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自调用函数</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/10.%E8%87%AA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/10.%E8%87%AA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>普通函数不调用不执行，立即执行函数不需要调用，能够自己执行，也称为自调用函数</p><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(形参) &#123;&#125;)(实参) 或者 (function()&#123;&#125;())</span><br></pre></td></tr></table></figure><p>可以传递参数；<br>有多个立即执行函数要用分号隔开；<br>立即执行函数会创建一个独立的作用域，里面的变量都是局部变量；<br>全局作用域下的变量不会被销毁，局部作用域的变量在关闭浏览器时会销毁；</p><h3 id="解决变量或方法的命名冲突问题："><a href="#解决变量或方法的命名冲突问题：" class="headerlink" title="解决变量或方法的命名冲突问题："></a>解决变量或方法的命名冲突问题：</h3><p>把同一个js文件的内容写在自调用函数里，开启一个新的作用域<br>(function(){js代码})()<br>注意把构造函数赋值给window,这样外部才能访问到： window.Food = Food;</p><h3 id="为了提升浏览器加载速度，要把所有js文件放到单个Index-js文件里"><a href="#为了提升浏览器加载速度，要把所有js文件放到单个Index-js文件里" class="headerlink" title="为了提升浏览器加载速度，要把所有js文件放到单个Index.js文件里"></a>为了提升浏览器加载速度，要把所有js文件放到单个Index.js文件里</h3><h3 id="自调用函数的问题："><a href="#自调用函数的问题：" class="headerlink" title="自调用函数的问题："></a>自调用函数的问题：</h3><p>连续写多个自调用函数时 前面要加分号，否则代码解析时会出现错误</p><h3 id="自调用函数的参数window和undifined"><a href="#自调用函数的参数window和undifined" class="headerlink" title="自调用函数的参数window和undifined"></a>自调用函数的参数window和undifined</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(function(window,undifined)&#123;</span><br><span class="line">//code</span><br><span class="line">&#125;)(window,undifined)</span><br></pre></td></tr></table></figure><p>window方便代码压缩，undifined防止被重命名</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/9.%E5%8E%9F%E5%9E%8B/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/9.%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>每个构造函数都有一个属性 原型或原型对象prototype<br>一般把构造函数的方法用原型声明在构造函数外部，这样不同实例使用此方法，不会开辟新的内存地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;属性&#125;;</span><br><span class="line">Person.prototype.sing = function()&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有很多方法时这样写比较麻烦，第6点会讲解如何解决</p><h2 id="构造函数、原型、对象实例之间的关系"><a href="#构造函数、原型、对象实例之间的关系" class="headerlink" title="构造函数、原型、对象实例之间的关系"></a>构造函数、原型、对象实例之间的关系</h2><p>原型图：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190519/PBHHf1AL8WL5.png?imageslim" alt="mark"></p><h2 id="为什么使用原型"><a href="#为什么使用原型" class="headerlink" title="为什么使用原型"></a>为什么使用原型</h2><p>减少内存占用、便于开发、资源共享</p><h2 id="获取属性-方法：原型链"><a href="#获取属性-方法：原型链" class="headerlink" title="获取属性/方法：原型链"></a>获取属性/方法：原型链</h2><p>实例对象调用方法和属性时，先去构造函数内寻找，如果构造函数内找到了，就停止寻找；如果构造函数内没有，去当前构造函数的原型对象内查找，如果还没有再去原型的原型找，直到找到，如果最终找不到则为null；</p><h2 id="设置属性："><a href="#设置属性：" class="headerlink" title="设置属性："></a>设置属性：</h2><p>给对象s1设置新的属性attr时，不会搜索原型链，而是直接给对象直接添加attr属性</p><h2 id="构造函数方法的写法"><a href="#构造函数方法的写法" class="headerlink" title="构造函数方法的写法"></a>构造函数方法的写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Student()&#123;xxx&#125;;</span><br><span class="line">Student.prototype = &#123;//在原型对象内部直接写方法</span><br><span class="line">say: function()&#123;</span><br><span class="line">&#125;，</span><br><span class="line">eat: function()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上步骤修改prototype后，prototype内已经没有constructor属性了。<br>所以对象实例的constructor属性的指向就不再是Student()了，而是Object(通过原型链找到的)；<br>可以手动再给prototype加上constructor属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = &#123;</span><br><span class="line">constructor: Student, //手动添加</span><br><span class="line">say: function()&#123;</span><br><span class="line">&#125;,</span><br><span class="line">eat: function()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明实例对象必须要在prototype修改之后，否则实例无法调用里面的方法：先设置原型对象，再使用其中的成员</p><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>数组或string中的prototype是不可以修改的；因为会覆盖原来的方法；<br>给内置对象添加方法时，只能用这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.getSum = function()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：-随机生成方块"><a href="#案例：-随机生成方块" class="headerlink" title="案例： 随机生成方块"></a>案例： 随机生成方块</h2><p>方块对象<br>工具对象：{生成随机数}</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象和构造函数</title>
      <link href="/2017/12/01/4.js%E9%AB%98%E7%BA%A7/8.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2017/12/01/4.js%E9%AB%98%E7%BA%A7/8.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象介绍"><a href="#面向对象介绍" class="headerlink" title="面向对象介绍"></a>面向对象介绍</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>(1) 对象是单个事物的抽象。<br>(2) 对象是一个容器，封装了属性（property）和方法（method）。<br>在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。<br>ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。</p><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。<br>面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目</p><p>面向对象与面向过程： </p><p>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊<br>面向对象就是找一个对象，指挥得结果<br>面向对象将执行者转变成指挥者<br>面向对象不是面向过程的替代，而是面向过程的封装</p><p>面向对象的特性：</p><p>封装性<br>继承性<br>[多态性]抽象</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &apos;Jack&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createPerson (name, age) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="工厂模式和构造函数"><a href="#工厂模式和构造函数" class="headerlink" title="工厂模式和构造函数"></a>工厂模式和构造函数</h2><p>工厂模式创建的实例 person instanceof Person返回是false，即不能识别对象<br>构造函数创建的实例 person instanceof Person返回是true，可以判断实例对象的类型</p><h2 id="构造函数和实例对象的关系"><a href="#构造函数和实例对象的关系" class="headerlink" title="构造函数和实例对象的关系"></a>构造函数和实例对象的关系</h2><p>实例对象没有constructor属性<br>是通过原型对象的constructor属性指向它的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log（person.constructor === Person）   // true</span><br></pre></td></tr></table></figure><p>但是检测某个实例 是否 是构造函数的实例时，一般使用instanceof方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log（person instanceof Person）   // true</span><br></pre></td></tr></table></figure><h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><p>成员：即属性或者方法<br>实例成员/对象成员： 跟对象相关的成员，将来使用对象的方式来调用 person.sing()<br>静态成员： 跟构造函数相关的成员，使用构造函数来调用 Person.version</p><h2 id="构造函数创建方法的问题"><a href="#构造函数创建方法的问题" class="headerlink" title="构造函数创建方法的问题"></a>构造函数创建方法的问题</h2><p>多个实例对象会存储多个同名的方法，造成内存浪费    –通过原型声明方法    </p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jq插件和其他方法</title>
      <link href="/2017/08/03/3.jquery/7.jquery%E6%8F%92%E4%BB%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/"/>
      <url>/2017/08/03/3.jquery/7.jquery%E6%8F%92%E4%BB%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="jq插件"><a href="#jq插件" class="headerlink" title="jq插件"></a>jq插件</h1><h2 id="常用的jq插件网站"><a href="#常用的jq插件网站" class="headerlink" title="常用的jq插件网站"></a>常用的jq插件网站</h2><p><a href="http://www.htmleaf.com/" target="_blank" rel="noopener">jquery之家</a><br><a href="www.jq22.com">jquery插件库</a></p><h3 id="瀑布流插件"><a href="#瀑布流插件" class="headerlink" title="瀑布流插件"></a>瀑布流插件</h3><p><a href="http://www.jq22.com/search?seo=%E7%80%91%E5%B8%83%E6%B5%81" target="_blank" rel="noopener">瀑布流插件</a></p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>可视区的图片显示，其他的不加载<br><a href="http://www.jq22.com/jquery-info11629" target="_blank" rel="noopener">easylazyload.js</a></p><p>原生js写法： 图片距离页面顶部的距离 &lt;= 可视区高度 + 页面卷去的头部时显示当前图片<br>不满足条件时，把正确src地址放在自定义属性data-img里，src里面放一张空白图片<br>满足条件时再取出正确图片路径 放入src属性</p><h3 id="bootstrap-js插件"><a href="#bootstrap-js插件" class="headerlink" title="bootstrap js插件"></a>bootstrap js插件</h3><p><a href="https://v3.bootcss.com/javascript/" target="_blank" rel="noopener">bootstrap插件库</a></p><h3 id="fullpage全屏滚动插件"><a href="#fullpage全屏滚动插件" class="headerlink" title="fullpage全屏滚动插件"></a>fullpage全屏滚动插件</h3><p><a href="http://www.jq22.com/jquery-info1124" target="_blank" rel="noopener">全屏滚动插件</a></p><h1 id="补充方法"><a href="#补充方法" class="headerlink" title="补充方法"></a>补充方法</h1><h2 id="jquery对象拷贝"><a href="#jquery对象拷贝" class="headerlink" title="jquery对象拷贝"></a>jquery对象拷贝</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190519/hLnYgBNfzx88.png?imageslim" alt="mark"></p><h2 id="change-事件"><a href="#change-事件" class="headerlink" title="change()事件"></a>change()事件</h2><p>当元素的值发生改变时，会触发 change 事件<br>该事件仅适用于text field，textarea 和 select 元素。<br>当用于 select 元素时，change 事件会在选择状态发生变化时发生。<br>当用于 text field 或 textarea 时，该事件会在元素失去焦点时发生。</p><h2 id="toFixed-2"><a href="#toFixed-2" class="headerlink" title="toFixed(2)"></a>toFixed(2)</h2><p>把数字转换为2位小数</p><h2 id="hover事件"><a href="#hover事件" class="headerlink" title="hover事件"></a>hover事件</h2><p>hover([over,]out) 模仿悬停事件<br>over是鼠标经过的函数，out是鼠标离开的函数<br>如果只写一个函数，鼠标经过和离开都会触发这个函数（可以把toggle函数写在里面）</p><h2 id="end-事件"><a href="#end-事件" class="headerlink" title="end()事件"></a>end()事件</h2><p>改变元素操作对象时会改变this指向，使用end()可以让this指向原来的元素</p><h2 id="index-属性"><a href="#index-属性" class="headerlink" title="index()属性"></a>index()属性</h2><p>获取元素的索引值  li.index()</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery事件</title>
      <link href="/2017/08/02/3.jquery/6.jquery%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/08/02/3.jquery/6.jquery%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h1><h2 id="一次只能注册一个事件"><a href="#一次只能注册一个事件" class="headerlink" title="一次只能注册一个事件"></a>一次只能注册一个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/tkuWFWDp0xEE.png?imageslim" alt="mark"></p><h2 id="链式方式注册多个事件"><a href="#链式方式注册多个事件" class="headerlink" title="链式方式注册多个事件"></a>链式方式注册多个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/1b3U50h2hvKV.png?imageslim" alt="mark"></p><h2 id="on注册"><a href="#on注册" class="headerlink" title="on注册"></a>on注册</h2><p>语法：<code>on(events,[selector],[data],fn)</code></p><h1 id="on的优势"><a href="#on的优势" class="headerlink" title="on的优势"></a>on的优势</h1><h2 id="on可以一次绑定多个事件"><a href="#on可以一次绑定多个事件" class="headerlink" title="on可以一次绑定多个事件"></a>on可以一次绑定多个事件</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/u1GNMuDtDpr7.png?imageslim" alt="mark"><br>如果 多个事件的 事件处理函数一样，还可以这样写：<br>注意多个事件之间加空格<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/2oBPUSugwi6x.png?imageslim" alt="mark"></p><h2 id="on可以实现事件委派"><a href="#on可以实现事件委派" class="headerlink" title="on可以实现事件委派"></a>on可以实现事件委派</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/boxgKT38RLx7.png?imageslim" alt="mark"><br>click是绑定在ul上，但是触发对象是li，this指向li</p><h2 id="on可以给动态创建的元素绑定事件"><a href="#on可以给动态创建的元素绑定事件" class="headerlink" title="on可以给动态创建的元素绑定事件"></a>on可以给动态创建的元素绑定事件</h2><p>给动态创建的元素绑定事件必须用on事件委托</p><p>方法one()类似on，也可以添加事件，但是只会触发一次：$(“div”).one(“click”,function(){})</p><h1 id="off解绑事件"><a href="#off解绑事件" class="headerlink" title="off解绑事件"></a>off解绑事件</h1><h2 id="off"><a href="#off" class="headerlink" title="off()"></a>off()</h2><p>通过on绑定的事件，可以使用off()方法解绑；<br>$(“div”).off()<br>如果括号内为空，会解绑div的所有事件<br>括号里为(“事件类型”)，会解绑div的某个事件<br>$(“ul”).off(“click”,”li”) 解绑事件委托</p><h1 id="自动触发事件"><a href="#自动触发事件" class="headerlink" title="自动触发事件"></a>自动触发事件</h1><h2 id="元素-事件"><a href="#元素-事件" class="headerlink" title="元素.事件()"></a>元素.事件()</h2><p>例如: $(“div”).click()<br>会触发事件冒泡</p><h2 id="元素-trigger-“type”"><a href="#元素-trigger-“type”" class="headerlink" title="元素.trigger(“type”)"></a>元素.trigger(“type”)</h2><p>例如: $(“div”).trigger(“click”)<br>会触发事件冒泡，可以用以下方法阻止事件冒泡<br>        1.e.stopPropagation()<br>        2.return false 在原生js里不能阻止</p><h2 id="元素-triggerHandler-“type”"><a href="#元素-triggerHandler-“type”" class="headerlink" title="元素.triggerHandler(“type”)"></a>元素.triggerHandler(“type”)</h2><p>例如: $(“div”).triggerHandler(“click”)<br>区别：不会触发元素的默认行为，不会触发事件冒泡<br>        例如文本框通过focus事件获取了焦点，会有光标闪烁，但是使用triggerHandler不会有光标闪烁</p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><h2 id="元素-事件-1"><a href="#元素-事件-1" class="headerlink" title="元素.事件()"></a>元素.事件()</h2><p>只要有事件发生就会产生事件对象e<br>element.on(events,[selector],function(e){})<br>    属性：<br>        e.type 事件类型<br>        e.target 触发事件的元素<br>        e.pageX,pageY 鼠标位置<br>    方法：<br>        e.preventDefault() 阻止默认行为<br>        e.stopPropagation() 阻止事件冒泡</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery尺寸和位置操作</title>
      <link href="/2017/08/02/3.jquery/5.jquery%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/02/3.jquery/5.jquery%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="尺寸方法"><a href="#尺寸方法" class="headerlink" title="尺寸方法"></a>尺寸方法</h1><h2 id="width"><a href="#width" class="headerlink" title="width()"></a>width()</h2><p>width</p><h2 id="innerWidth"><a href="#innerWidth" class="headerlink" title="innerWidth()"></a>innerWidth()</h2><p>width+padding</p><h2 id="outerWidth"><a href="#outerWidth" class="headerlink" title="outerWidth()"></a>outerWidth()</h2><p>width+padding+border<br>括号里参数为true时：width+padding+border+margin<br>以上尺寸方法 ：如果括号为空是获取，如果是数字是修改</p><h1 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h1><h2 id="offset"><a href="#offset" class="headerlink" title="offset()"></a>offset()</h2><p>元素距离文档的位置<br>获取：    括号为空时，返回的是对象，包括left和top<br>offset().top 返回距离文档top值<br>offset().left 返回距离文档left值<br>设置： offset({top: 200,left: 100})</p><h2 id="position"><a href="#position" class="headerlink" title="position()"></a>position()</h2><p>元素距离带有定位的父元素的位置<br>只能获取，不能设置偏移</p><h2 id="scrollTop-scrollLeft"><a href="#scrollTop-scrollLeft" class="headerlink" title="scrollTop()/scrollLeft()"></a>scrollTop()/scrollLeft()</h2><p>被卷去的头部/左侧<br>$(window).scrollTop() 页面被卷去的头部<br>$(“html”).scrollTop() 文档被卷去的头部<br>如果要添加动画效果，只能给元素添加，window和document不能添加<br>scrollTop()括号不写内容是获取，写数字是设置</p><h2 id="案例：电梯导航"><a href="#案例：电梯导航" class="headerlink" title="案例：电梯导航"></a>案例：电梯导航</h2><p>1.滚动到一定位置显示隐藏侧边栏<br>2.点击侧边栏 滚动到相应模块<br>3.滚动到某个模块，侧边栏相应模块变色</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery操作</title>
      <link href="/2017/08/02/3.jquery/4.jquery%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/02/3.jquery/4.jquery%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery样式操作"><a href="#jQuery样式操作" class="headerlink" title="jQuery样式操作"></a>jQuery样式操作</h1><h2 id="操作css方法"><a href="#操作css方法" class="headerlink" title="操作css方法"></a>操作css方法</h2><p>$(“div”).css(“属性名”) 不写属性值是获取，返回字符串<br>$(“div”).css(“属性名”,”属性值”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).css(&#123;</span><br><span class="line">属性名:&quot;属性值&quot;,</span><br><span class="line">属性名:&quot;属性值&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>属性值是数字可以不用加引号</p><h2 id="设置类样式方法"><a href="#设置类样式方法" class="headerlink" title="设置类样式方法"></a>设置类样式方法</h2><p>$(“div”).addClass(“类名”)    添加类<br>$(“div”).removeClass(“类名”)    移除类<br>$(“div”).toggleClass(“类名”)    切换类<br>原生js里的div.className = “box”会覆盖原来的类名。jQuery类名操作不会覆盖。</p><h1 id="jquery属性操作"><a href="#jquery属性操作" class="headerlink" title="jquery属性操作"></a>jquery属性操作</h1><h2 id="prop"><a href="#prop" class="headerlink" title="prop()"></a>prop()</h2><p>获取或设置元素固有属性  比如获取checkbox的checked属性<br>$(“div”).prop(“属性名”)            获取属性<br>$(“div”).prop(“属性名”,”属性值”)    设置属性</p><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p>获取或设置元素固有属性和自定义属性<br>$(“div”).attr(“属性名”)            获取属性<br>$(“div”).attr(“属性名”,”属性值”)    设置属性</p><h2 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h2><p>数据缓存，存储在元素的内存里，不改变DOM元素的属性<br>$(“div”).data(“属性名”)            获取属性<br>        可以获取h5属性data-index；不用写data-,返回的是数字<br>$(“div”).data(“属性名”,”属性值”)    设置属性</p><h2 id="removeAttr"><a href="#removeAttr" class="headerlink" title="removeAttr()"></a>removeAttr()</h2><p>$(“div”).removeAttr(“属性名”)        移除属性</p><h1 id="jq文本操作"><a href="#jq文本操作" class="headerlink" title="jq文本操作"></a>jq文本操作</h1><h2 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h2><p>获取：括号里不写内容是获取<br>设置：<code>html(&quot;&lt;p&gt;123&lt;/p&gt;&quot;)</code> 括号里可以写html内容</p><h2 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h2><p>不解析html标签，其他和html用法相同</p><h2 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h2><p>操作表单元素文字专用<br>获取： val()  获取到的是字符型<br>设置： val(值)</p><h1 id="jq元素操作"><a href="#jq元素操作" class="headerlink" title="jq元素操作"></a>jq元素操作</h1><h2 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var li = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</span><br><span class="line">var li = html(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>内部添加<br>$(“ul”).append(li);    放到最后面  等价于li.appendTo($(“ul”))<br>$(“ul”).prepend(li);     放到最前面  等价于li.prependTo($(“ul”))<br>外部添加<br>$(“div”).after(p);    放到div后面<br>$(“div”).before(p);     放到div前面</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>$(“ul”).remove()     删除自己<br>$(“ul”).empty()     删除内部的子节点<br>$(“ul”).html(“”)    删除内部的子节点 如果子元素有事件 只是清除元素内容 事件还会保留</p><h2 id="遍历DOM元素"><a href="#遍历DOM元素" class="headerlink" title="遍历DOM元素"></a>遍历DOM元素</h2><p>方法1<br>$(“div”).each(function (i, ele) {<br>    xxx;<br>})<br>里面的回调函数有2个参数：i 是每个元素的索引号; ele 是每个DOM元素对象，不是jquery对象<br>所以要想使用jquery方法，需要给这个dom元素转换为jquery对象  $(ele)<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/C1X5AeFNVALp.png?imageslim" alt="mark"></p><p>方法2<br>$.each(arr,function(i, ele){ })  遍历数据 ele就是arr[i]<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/rtdUGtNRBPrG.png?imageslim" alt="mark"></p><p>案例： 购物车<br>    全选按钮 数量调整 动态计算价格  计算总件数总价（封装函数）  删除商品  选中的商品添加背景</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery简介</title>
      <link href="/2017/08/02/3.jquery/1.jquery%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/08/02/3.jquery/1.jquery%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h1><h2 id="JavaScript库"><a href="#JavaScript库" class="headerlink" title="JavaScript库"></a>JavaScript库</h2><p>即js library，是封装好的方法和函数特定的集合；<br>简单理解就是一个JS文件；<br>jQuery就是属于JS库的一种</p><h2 id="jQuery的概念"><a href="#jQuery的概念" class="headerlink" title="jQuery的概念"></a>jQuery的概念</h2><p>write less, do more<br>封装了JavaScript常用的功能代码<br>jQuery的出现大大提高了JavaScript的开发速度</p><h2 id="jQuery的优点"><a href="#jQuery的优点" class="headerlink" title="jQuery的优点"></a>jQuery的优点</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/Q7ngmOhqkzi6.png?imageslim" alt="Jq的优点"></p><h1 id="jQuery的基本使用"><a href="#jQuery的基本使用" class="headerlink" title="jQuery的基本使用"></a>jQuery的基本使用</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://jquery.com/" target="_blank" rel="noopener">jquery官方网站</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>引入jQuery的js文件</p><h2 id="jQuery入口程序"><a href="#jQuery入口程序" class="headerlink" title="jQuery入口程序"></a>jQuery入口程序</h2><p>写在入口函数里的代码是在DOM元素加载完毕执行，等价于原生js里的DOMContentLoaded</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">代码； //最常用</span><br><span class="line">&#125;);</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">代码；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery的顶级对象"><a href="#jQuery的顶级对象" class="headerlink" title="jQuery的顶级对象$"></a>jQuery的顶级对象$</h2><p>$就是指jQuery，代码里它们可以互相替换  $ = jQuery<br>他们之间的关系，类似于原生js里面的window和无window</p><h2 id="jQuery对象和DOM对象的区别"><a href="#jQuery对象和DOM对象的区别" class="headerlink" title="jQuery对象和DOM对象的区别"></a>jQuery对象和DOM对象的区别</h2><p>用原生js获取的对象就是DOM对象； document.querySeletor(“div”)<br>用jQuery方法获取的对象就是jQuery对象； $(“div”)<br>jquery对象是对DOM对象进行包装后产生的，是伪数组形式；<br>两种对象只能使用各自的属性和方法</p><h2 id="两种对象转换："><a href="#两种对象转换：" class="headerlink" title="两种对象转换："></a>两种对象转换：</h2><p>jq对象转dom对象：  $(“div”)[0] 或者 $(“div”).get(0)<br>dom对象转jq对象：    $(div) 里面的div已经获取到了所以不用加引号</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery动画</title>
      <link href="/2017/08/02/3.jquery/3.jquery%E5%8A%A8%E7%94%BB/"/>
      <url>/2017/08/02/3.jquery/3.jquery%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h1><h2 id="显示隐藏效果"><a href="#显示隐藏效果" class="headerlink" title="显示隐藏效果"></a>显示隐藏效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show([speed],[easing],[fn])显示</span><br><span class="line">hide([speed],[easing],[fn])隐藏</span><br><span class="line">toggle([speed],[easing],[fn])切换</span><br></pre></td></tr></table></figure><h2 id="上拉下拉效果"><a href="#上拉下拉效果" class="headerlink" title="上拉下拉效果"></a>上拉下拉效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slideUp([speed],[easing],[fn])上拉收起</span><br><span class="line">slideDown([speed],[easing],[fn])下拉显示</span><br><span class="line">slideToggle([speed],[easing],[fn]) 切换</span><br></pre></td></tr></table></figure><h2 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fadeIn([speed],[easing],[fn]) 淡入显示</span><br><span class="line">fadeOut([speed],[easing],[fn]) 淡出隐藏</span><br><span class="line">fadeToggle([speed],[easing],[fn])切换</span><br></pre></td></tr></table></figure><p>参数一般省略:<br>speed: 速度 “slow” “normal” “fast” 或者时间 1000<br>easing: 运动曲线，默认是swing中间较快,可选linear匀速；<br>可以使用jquery.easing.min.js添加其他的运动曲线<br>fn: 回调函数  </p><h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a>动画队列</h2><p>停止动画排队： 把stop()写在动画效果的前面 如$(“div”).stop().toggle();<br>防止鼠标滑动过快动画一直播放</p><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animate(&#123;样式对象&#125;,[speed],[easing],[fn])</span><br></pre></td></tr></table></figure><p>样式属性名可以不带引号，不支持改变颜色，需要借助插件<br>动画只能给元素添加，不能是document和window<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).animate(&#123; </span><br><span class="line">width: 200,</span><br><span class="line">height: &quot;100%&quot;, </span><br><span class="line">fontSize: &quot;10em&quot;, </span><br><span class="line">borderWidth: 10</span><br><span class="line">&#125;, 1000 );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jq选择器</title>
      <link href="/2017/08/02/3.jquery/2.jquery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2017/08/02/3.jquery/2.jquery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jq选择器"><a href="#jq选择器" class="headerlink" title="jq选择器"></a>jq选择器</h1><p>jq推荐使用双引号””</p><h2 id="jq基础选择器"><a href="#jq基础选择器" class="headerlink" title="jq基础选择器"></a>jq基础选择器</h2><p>$(“div”)          标签选择器<br>$(“.box”)         类名选择器<br>$(“#box”)           id选择器<br>$(“*”)            全选选择器<br>$(“div,p”)        并集选择器</p><h2 id="jq层级选择器"><a href="#jq层级选择器" class="headerlink" title="jq层级选择器"></a>jq层级选择器</h2><p>$(“div&gt;p”)    子元素选择器<br>$(“div p”)    后代选择器</p><h2 id="jq筛选选择器"><a href="#jq筛选选择器" class="headerlink" title="jq筛选选择器"></a>jq筛选选择器</h2><p>$(“li:first”)    选择第一个li元素<br>$(“li:last”)    选择最后一个li元素<br>$(“li:nth-of-type(n)”)    选择第n个li元素<br>$(“li:eq(2)”)    选择索引为2的li元素<br>$(“li:odd”)        选择索引为奇数的li元素<br>$(“li:even”)    选择索引为偶数的li元素</p><h2 id="jq筛选方法"><a href="#jq筛选方法" class="headerlink" title="jq筛选方法"></a>jq筛选方法</h2><p>$(“div”).parent()         选择亲爸爸<br>$(“div”).parents(“.box”)    选择div的父级里类名是box的元素<br>$(“div”).children(“p”)         选择亲儿子p         相当于div&gt;p<br>$(“div”).find(“p”)         选择所有后代里的p    相当于div p<br>$(“div”).siblings(“p”)        选择所有亲兄弟里的p<br>$(“ul li”).eq(0)            选择ul里的第一个li    相当于:eq(0) 更推荐使用<br>$(“div”).next()            选择后面的第一个兄弟<br>$(“div”).nextAll(“p”)        选择后面所有的兄弟p<br>$(“div”).prev()            选择前面的第一个兄弟<br>$(“div”).prevAll(“p”)        选择前面所有的兄弟p<br>$(“div”).hasClass(“类名”)     判断div是否有类名，如果有返回true        </p><h2 id="jq排他思想"><a href="#jq排他思想" class="headerlink" title="jq排他思想"></a>jq排他思想</h2><p>jq里的this写法： $(this)<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190516/VQ79oXXeoTV0.png?imageslim" alt="mark"></p><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><p>jq会自动遍历jq对象内部的DOM元素，称为隐式迭代</p><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>节省代码量，看起来更优雅<br>上面例子可以用以下一句话写；<br>$(this).css(“background”,”pink”).siblings().css(“background”,””)<br>什么时候可以链式编程：<br>    设置型操作可以一直链式编程；jq的大部分方法都是定义在原型上的，方法执行完返回的原来的对象，this又指回了原来的对象，因此可以链式编程<br>    获取型操作会断链；</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地存储</title>
      <link href="/2017/06/20/2.webAPI/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
      <url>/2017/06/20/2.webAPI/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-本地存储特性"><a href="#1-本地存储特性" class="headerlink" title="1.本地存储特性"></a>1.本地存储特性</h2><p>数据存储在用户浏览器中（不与服务器打交道）<br>设置读取方便，刷新也不会丢失</p><h2 id="2-window-sessionStorage"><a href="#2-window-sessionStorage" class="headerlink" title="2.window.sessionStorage"></a>2.window.sessionStorage</h2><p>1.生命周期为关闭浏览器窗口<br>2.存储在当前页面内存，只在同一个页面以下数据共享<br>3.以键值对形式存储<br>4.最大5M</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem(<span class="string">'key'</span>,value)</span><br><span class="line">获取： sessionStorage.getItem(<span class="string">'key'</span>)</span><br><span class="line">删除： sessionStorage.removeItem(<span class="string">'key'</span>)</span><br><span class="line">删除所有: sessionStorage.clear()</span><br></pre></td></tr></table></figure><h2 id="3-window-localStorage"><a href="#3-window-localStorage" class="headerlink" title="3.window.localStorage"></a>3.window.localStorage</h2><p>1.存储到本地内存，不同页面也可以数据共享<br>2.最大20M<br>3.生命周期为永久<br>方法和sessionStorage完全类似</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端网页特效案例</title>
      <link href="/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、触屏事件"><a href="#一、触屏事件" class="headerlink" title="一、触屏事件"></a>一、触屏事件</h1><h2 id="1-常见触摸事件"><a href="#1-常见触摸事件" class="headerlink" title="1.常见触摸事件"></a>1.常见触摸事件</h2><p><code>touchstart</code>  手指触摸元素<br><code>touchmove</code> 手指在元素上移动<br><code>touchend</code> 手指不再触摸元素</p><h2 id="2-触摸事件对象"><a href="#2-触摸事件对象" class="headerlink" title="2.触摸事件对象"></a>2.触摸事件对象</h2><p><code>e.touches</code>  正在触摸屏幕的所有手指列表<br><code>e.targetTouches</code> 正在触摸当前dom元素的手指列表<br><code>e.changedTouches</code> 手指状态发生改变的列表 从无到有或者从有到无<br>手指离开屏幕时 touches和targetTouches没有了，但是changedTouches还有<br><code>e.targetTouches[0]</code> 是触摸元素的第一个手指的相关信息 包括坐标,触摸对象等；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.clientX 手指在可视区的X坐标</span><br><span class="line">e.clientY 手指在可视区的Y坐标</span><br><span class="line">e.pageX 手指在页面文档的X坐标</span><br><span class="line">e.pageY 手指在页面文档的Y坐标</span><br><span class="line">e.screenX 手指在手机屏幕的X坐标</span><br><span class="line">e.screenY 手指在手机屏幕的Y坐标</span><br></pre></td></tr></table></figure><h1 id="二、移动端轮播图"><a href="#二、移动端轮播图" class="headerlink" title="二、移动端轮播图"></a>二、移动端轮播图</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/HNQ4xw5KAKJR.png?imageslim" alt="Image"></p><h2 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h2><p>（1）搭建结构和样式：ol里面的小圆点不再自动生成，ul不添加定位。因为移动位置是使用translate方法不需要定位。<br>（2）自动轮播功能：使用 定时器+CSS3过渡+translate移动位置；<br>　　　注意无缝滚动功能需要克隆图片，向左滑动功能也需要克隆图片<br>（3）小圆点跟随滚动变化样式： 不再使用排他方法，使用classList操作；也是在过渡结束后圆点才发生变化<br>（4）手指拖动功能： 和手指拖动盒子写法类似<br>（5）判断滑动完播放哪一张图片</p><h2 id="2-新知识"><a href="#2-新知识" class="headerlink" title="2.新知识"></a>2.新知识</h2><p>transitionend事件 过渡结束<br><code>element.classList</code> 返回元素的类名 伪数组形式<br><code>div.classList.add(&#39;类名&#39;)</code> 给div追加一个新类名<br>　　　不会覆盖以前的类<br>　　　一次只能添加一个类名，注意不加.<br><code>div.classList.remove(&#39;类名&#39;)</code> div删除一个类名<br><code>div.classList.toggle(&#39;类名&#39;)</code> 切换类名<br>　　　自动检测，如果有此类则去掉，如果没有则加上；<br><code>div.classList.item(索引)</code>  获取div的第n个类名<br><code>div.classList.contains(&#39;类名&#39;)</code> 判断是否有这个类名<br>　　　如果有返回true 没有返回false</p><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3.源码"></a>3.源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">'.focus'</span>);</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.querySelector(<span class="string">'ol'</span>);</span><br><span class="line">    <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.自动播放功能</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">        ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">        ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">    <span class="comment">//无缝滚动，判断条件在每次播放完成之后再检测，需要使用transitionend事件</span></span><br><span class="line">    ul.addEventListener(<span class="string">'transitionend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//播放到最后一张或再往后时跳到图1</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//无过渡的跳到第一张，因此先去掉过渡</span></span><br><span class="line">            ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">            <span class="comment">//直接跳到第一张</span></span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果拖动到最左边的图3(索引是负数),跳到索引是2的图3位置</span></span><br><span class="line">        <span class="comment">//---目前不会出现索引负数，等下面添加了手指滑动事件才有可能出现</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">2</span>;</span><br><span class="line">            ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.小圆点跟随变化功能</span></span><br><span class="line">        <span class="comment">// 也要写在transitionend里面，因为是每次滚动完一张小圆点发生变化</span></span><br><span class="line">        <span class="comment">// 选出带current类名的圆点，去掉类名</span></span><br><span class="line">        ol.querySelector(<span class="string">'.current'</span>).classList.remove(<span class="string">'current'</span>);</span><br><span class="line">        <span class="comment">//滚动到的那一张（即index）的小圆圈加上类名  </span></span><br><span class="line">        <span class="comment">//小圆圈索引是0-2 index在这里的取值也被限制为0-2</span></span><br><span class="line">        ol.children[index].classList.add(<span class="string">'current'</span>);</span><br><span class="line">        <span class="comment">//可以加上过渡效果更美观，在css里设置</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.手指滑动功能</span></span><br><span class="line">    <span class="keyword">var</span> startX = <span class="number">0</span>; <span class="comment">//手指初始坐标</span></span><br><span class="line">    <span class="keyword">var</span> moveX = <span class="number">0</span>; <span class="comment">//手指移动距离</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>; <span class="comment">//判断手指是否移动的变量</span></span><br><span class="line">    ul.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        startX = e.targetTouches[<span class="number">0</span>].pageX;</span><br><span class="line">        <span class="comment">//手指触摸停止定时器</span></span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    ul.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        moveX = e.targetTouches[<span class="number">0</span>].pageX - startX;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动ul:  ul原来位置+移动距离</span></span><br><span class="line">        <span class="keyword">var</span> x = -index * focusWidth + moveX;</span><br><span class="line">        ul.style.transition = <span class="string">'none'</span>;</span><br><span class="line">        ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手指移动过，设flag为true</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//判断滑动完播放哪一张图片</span></span><br><span class="line">    ul.addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//用户有可能只是单击后松手，也会触发touchend事件，但是此时没有移动，判断moveX没有意义，所以设置flag判断用户是否移动了手指，如果移动了再判断moveX</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//移动超过50像素，就切换图片</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(moveX) &gt; <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="comment">// 右划播放上一张，左滑播放下一张</span></span><br><span class="line">                <span class="keyword">if</span> (moveX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    index--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moveX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断完后移动距离</span></span><br><span class="line">                <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">                ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">                ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不超过50像素，回弹到原来位置</span></span><br><span class="line">                <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">                ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">                ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手指离开重新开始定时器，先清除，保证只有一个定时器</span></span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">var</span> x = -index * focusWidth;</span><br><span class="line">            ul.style.transition = <span class="string">'all .3s'</span>;</span><br><span class="line">            ul.style.transform = <span class="string">'translateX('</span> + x + <span class="string">'px)'</span>;</span><br><span class="line">        &#125;, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、移动端返回顶部"><a href="#三、移动端返回顶部" class="headerlink" title="三、移动端返回顶部"></a>三、移动端返回顶部</h1><p>和PC端写法一样</p><h1 id="四、移动端click延时问题"><a href="#四、移动端click延时问题" class="headerlink" title="四、移动端click延时问题"></a>四、移动端click延时问题</h1><p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面；<br>解决方案：<br>1.禁用缩放 user-scalable=no 禁止双击缩放<br>2.自己封装函数判断是否是点击事件<br>3.使用fastclick插件</p><h1 id="五、移动端插件"><a href="#五、移动端插件" class="headerlink" title="五、移动端插件"></a>五、移动端插件</h1><h2 id="1-swiper插件-轮播图插件"><a href="#1-swiper插件-轮播图插件" class="headerlink" title="1.swiper插件 轮播图插件"></a>1.swiper插件 轮播图插件</h2><p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a><br>1.引入swiper.min.css文件和swiper.min.js<br>2.在demo文件夹找到想要的轮播图效果，去对应的源代码里复制html和样式<br>3.复制swiperjs代码</p><h2 id="2-superslide插件"><a href="#2-superslide插件" class="headerlink" title="2.superslide插件"></a>2.superslide插件</h2><p><a href="http://www.superslide2.com/" target="_blank" rel="noopener">http://www.superslide2.com/</a></p><h2 id="3-iscroll滚动弹回插件"><a href="#3-iscroll滚动弹回插件" class="headerlink" title="3.iscroll滚动弹回插件"></a>3.iscroll滚动弹回插件</h2><p><a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">https://github.com/cubiq/iscroll</a></p><h2 id="4-zy-media-js移动端视频插件"><a href="#4-zy-media-js移动端视频插件" class="headerlink" title="4.zy.media.js移动端视频插件"></a>4.zy.media.js移动端视频插件</h2><h2 id="5-插件使用总结："><a href="#5-插件使用总结：" class="headerlink" title="5.插件使用总结："></a>5.插件使用总结：</h2><pre><code>1.确认插件实现的功能2.去官网查看使用说明3.下载插件4.打开demo实例文件，查看需要引入的相关文件，并且引入5.复制demo实例文件中的结构html，样式css以及js代码</code></pre><h1 id="六、移动端常用开发框架"><a href="#六、移动端常用开发框架" class="headerlink" title="六、移动端常用开发框架"></a>六、移动端常用开发框架</h1><p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p><p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。<br>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端<br>前端常用的移动端插件有 swiper、superslide、iscroll等。<br>框架： 大而全，一整套解决方案<br>插件： 小而专一，某个功能的解决方案<br>bootstrap轮播图<br>1.引入jquery.min.js文件和bootstrap.min.js<br>2.引入bootstrap.min.css<br>3.把html代码复制进focus盒子里，更改图片</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC端网页特效案例</title>
      <link href="/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/06/20/2.webAPI/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、网页轮播图"><a href="#一、网页轮播图" class="headerlink" title="一、网页轮播图"></a>一、网页轮播图</h1><h2 id="1-结构搭建"><a href="#1-结构搭建" class="headerlink" title="1.结构搭建"></a>1.结构搭建</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/W0D7LIbLoYmb.png?imageslim" alt="Image">    </p><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h2><p>动态设置ul的宽度<br>1）鼠标经过轮播图区域左右箭头才显示<br>2）动态生成小圆圈<br>3）点击小圆圈切换图片 配合animate函数<br>    - 变量index 是点击时小圆圈的索引号<br>4）点击方向箭头切换图片，小圆圈也跟着变化<br>    - 变量num 控制箭头切换图片<br>    - 变量circle 是小圆圈跟随变化新的索引号<br>    - 克隆最后一张图实现无缝滚动<br>5）自动播放：<br>定时器 + 手动调用点击事件 arrowr.click();<br>鼠标经过停止定时器<br>6）添加节流阀：<br>防止轮播图按钮连续点击造成播放过快。<br>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。<br>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<br>开始设置一个变量<code>var flag= true;</code><br><code>If(flag){flag = false; do something}       关闭水龙头</code><br><code>利用回调函数动画执行完毕， flag = true     打开水龙头</code></p><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3.源码"></a>3.源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">'.focus'</span>);</span><br><span class="line">    <span class="keyword">var</span> arrowl = <span class="built_in">document</span>.querySelector(<span class="string">'.arrow-l'</span>);</span><br><span class="line">    <span class="keyword">var</span> arrowr = <span class="built_in">document</span>.querySelector(<span class="string">'.arrow-r'</span>);</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    <span class="keyword">var</span> imglis = ul.children;</span><br><span class="line">    <span class="keyword">var</span> ol = <span class="built_in">document</span>.querySelector(<span class="string">'ol'</span>);</span><br><span class="line">    <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示隐藏功能</span></span><br><span class="line">    focus.addEventListener(<span class="string">'mouseenter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowl.style.display = <span class="string">'block'</span>;</span><br><span class="line">        arrowr.style.display = <span class="string">'block'</span>;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;)</span><br><span class="line">    focus.addEventListener(<span class="string">'mouseleave'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowl.style.display = <span class="string">'none'</span>;</span><br><span class="line">        arrowr.style.display = <span class="string">'none'</span>;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            arrowr.click();</span><br><span class="line">        &#125;, <span class="number">1500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态生成圆圈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imglis.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.setAttribute(<span class="string">'index'</span>, i);</span><br><span class="line">        ol.appendChild(li);</span><br><span class="line">        <span class="comment">//点击圆圈切换图片和圆圈样式</span></span><br><span class="line">        li.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//排他思想设置小圆圈颜色</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> index = <span class="keyword">this</span>.getAttribute(<span class="string">'index'</span>);</span><br><span class="line">            num = index;</span><br><span class="line">            circle = index;</span><br><span class="line">            animate(ul, -index * focusWidth);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ol.children[<span class="number">0</span>].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右按钮功能</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> circle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> lastli = imglis[<span class="number">0</span>].cloneNode(<span class="literal">true</span>);</span><br><span class="line">    ul.appendChild(lastli);</span><br><span class="line"></span><br><span class="line">    arrowr.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == ul.children.length - <span class="number">1</span>) &#123;</span><br><span class="line">                ul.style.left = <span class="number">0</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            circle++;</span><br><span class="line">            <span class="keyword">if</span> (circle == ol.children.length) &#123;</span><br><span class="line">                circle = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ol.children[circle].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//左按钮功能</span></span><br><span class="line">    arrowl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                ul.style.left = -focusWidth * (ul.children.length - <span class="number">1</span>) + <span class="string">'px'</span>;</span><br><span class="line">                num = ul.children.length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            circle--;</span><br><span class="line">            <span class="keyword">if</span> (circle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                circle = ol.children.length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">''</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ol.children[circle].className = <span class="string">'current'</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//自动轮播定时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrowr.click();</span><br><span class="line">    &#125;, <span class="number">1500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="二、返回顶部案例"><a href="#二、返回顶部案例" class="headerlink" title="二、返回顶部案例"></a>二、返回顶部案例</h1><h2 id="1-窗口滚动事件"><a href="#1-窗口滚动事件" class="headerlink" title="1.窗口滚动事件"></a>1.窗口滚动事件</h2><p><code>window.scroll(x,y);</code>  使窗口滚动到某个坐标，x和y不写单位<br><code>window.pageYOffset</code> 是页面被卷去的头部  IE9 以上兼容</p><h2 id="2-思想"><a href="#2-思想" class="headerlink" title="2.思想"></a>2.思想</h2><p>修改animate函数来实现缓慢滚动到顶部</p><h1 id="三、筋斗云案例"><a href="#三、筋斗云案例" class="headerlink" title="三、筋斗云案例"></a>三、筋斗云案例</h1><p>利用animate函数 记录点击的位置，作为下一次移动的起点</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js动画函数</title>
      <link href="/2017/06/20/2.webAPI/BOM/5.JS%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2017/06/20/2.webAPI/BOM/5.JS%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、动画实现原理"><a href="#一、动画实现原理" class="headerlink" title="一、动画实现原理"></a>一、动画实现原理</h1><h2 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1.核心原理"></a>1.核心原理</h2><p>通过定时器 setInterval() 不断移动盒子位置</p><h2 id="2-实现步骤："><a href="#2-实现步骤：" class="headerlink" title="2.实现步骤："></a>2.实现步骤：</h2><p>1.获得盒子当前位置<br>2.让盒子在当前位置加上1个移动距离<br>3.利用定时器不断重复这个操作<br>4.加一个结束定时器的条件<br>5.注意此元素需要添加定位，才能使用element.style.left</p><h1 id="二、动画函数封装"><a href="#二、动画函数封装" class="headerlink" title="二、动画函数封装"></a>二、动画函数封装</h1><h2 id="1-封装函数"><a href="#1-封装函数" class="headerlink" title="1.封装函数"></a>1.封装函数</h2><p>把动画封装进一个函数，传的参数是 obj调用对象 和 target动画结束条件</p><h2 id="2-给不同元素添加不同定时器"><a href="#2-给不同元素添加不同定时器" class="headerlink" title="2.给不同元素添加不同定时器"></a>2.给不同元素添加不同定时器</h2><p>可以减少内存占用<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/YglwUtGXe9NJ.png?imageslim" alt="Image"><br>把var timer 改成 obj.timer，这样每个调用函数的元素都有了自己的定时器</p><h1 id="三、缓动动画"><a href="#三、缓动动画" class="headerlink" title="三、缓动动画"></a>三、缓动动画</h1><h2 id="1-核心原理-1"><a href="#1-核心原理-1" class="headerlink" title="1.核心原理"></a>1.核心原理</h2><p>缓动：运动速度慢慢变小，实现缓慢停下来的效果<br>让盒子每次移动的距离慢慢变小： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">step = (目标位置-现在位置) / <span class="number">10</span>;</span><br><span class="line">step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br></pre></td></tr></table></figure><p>步长如果是正值向上取值，如果是负值向下取整<br>封装的缓动动画用于轮播图案例里 实现图片滚动效果</p><h2 id="2-缓动动画添加回调函数"><a href="#2-缓动动画添加回调函数" class="headerlink" title="2.缓动动画添加回调函数"></a>2.缓动动画添加回调函数</h2><p>回调函数原理： 把函数P当做一个参数传递到另外一个函数fn里，当fn全部执行完毕之后才会执行此函数P，这个过程称为回调<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/jUee2pFPX7fm.png?imageslim" alt="Image"><br>根据定义 定时器全部执行完才执行回调函数，因此回调函数写在定时器结束时。如果有回调函数 则调用此函数；</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的执行机制</title>
      <link href="/2017/06/20/2.webAPI/BOM/4.JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/06/20/2.webAPI/BOM/4.JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>JS执行机制</p><h1 id="一、JS是单线程"><a href="#一、JS是单线程" class="headerlink" title="一、JS是单线程"></a>一、JS是单线程</h1><p>js代码是从上往下执行，同一时间只能做一件事,称为js单线程<br>单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待</p><h1 id="二、同步和异步"><a href="#二、同步和异步" class="headerlink" title="二、同步和异步"></a>二、同步和异步</h1><p>HTML5提出了同步任务和异步任务的概念</p><h2 id="1-同步任务"><a href="#1-同步任务" class="headerlink" title="1.同步任务"></a>1.同步任务</h2><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 形成执行栈    </p><h2 id="2-异步任务"><a href="#2-异步任务" class="headerlink" title="2.异步任务"></a>2.异步任务</h2><p>不进入主线程、而进入‘任务队列’的任务，当主线程中的任务运行完了，才会从‘任务队列’取出异步任务放入主线程执行。<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/9EutwcwXfKh9.png?imageslim" alt="Image">     </p><h1 id="三、JS事件循环"><a href="#三、JS事件循环" class="headerlink" title="三、JS事件循环"></a>三、JS事件循环</h1><p>主线程执行完毕，查询任务队列，取出一个任务推入主线程运行；反复以上过程称为事件循环<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/PJywDry0ayyb.png?imageslim" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM三大系列</title>
      <link href="/2017/06/20/2.webAPI/BOM/3.BOM%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97/"/>
      <url>/2017/06/20/2.webAPI/BOM/3.BOM%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、offset系列"><a href="#一、offset系列" class="headerlink" title="一、offset系列"></a>一、offset系列</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>元素偏移量 动态获得元素在网页中的位置或大小，返回数值没有单位；</p><h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/afM5Jis7SW4l.png?imageslim" alt="Image"></p><p>offsetTop和offsetLeft以带有定位的父元素为准，如果没有父亲或者父亲没有定位，则以Body为准</p><h2 id="3-offset和style的区别"><a href="#3-offset和style的区别" class="headerlink" title="3.offset和style的区别"></a>3.offset和style的区别</h2><p>style只能获得行内样式表的样式值，offset所有样式写法都可以获得。<br>style获得的left和top是带有单位的字符串，offsetLeft和Top获得不带单位的数值<br>style不包含padding和border，offset包含padding和border<br>style可以读写，而offset是只读属性<br>获取元素的大小位置用offset，更改元素的大小位置用style</p><p><strong>案例：</strong><br>1.拖拽的模态框<br>2.京东放大镜：</p><p>鼠标经过小图片盒子，蒙层和大图片盒子显示，离开隐藏<br>蒙层跟随鼠标，且不超出小盒子<br>移动蒙层时大图片等比例移动</p><p>求大图移动距离的公式：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/lNwrKcSMpc0i.png?imageslim" alt="Image"></p><p>如果大图片和蒙层都是正方形，只要计算一个比例，如果不是正方形要计算宽和高两个比例</p><h1 id="二、client系列"><a href="#二、client系列" class="headerlink" title="二、client系列"></a>二、client系列</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p>获取元素可视区的相关信息</p><h2 id="2-client系列属性"><a href="#2-client系列属性" class="headerlink" title="2.client系列属性"></a>2.client系列属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/PDunjAa9uFk0.png?imagesli" alt="Image"><br>和offsetWidth唯一的区别是clientWidth不包含边框</p><h1 id="三、scroll系列"><a href="#三、scroll系列" class="headerlink" title="三、scroll系列"></a>三、scroll系列</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h2><p>scroll 系列的相关属性可以动态的得到该元素内容的实际大小、滚动距离</p><h2 id="2-scroll系列属性"><a href="#2-scroll系列属性" class="headerlink" title="2.scroll系列属性"></a>2.scroll系列属性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/5c6pP1s7kk2x.png?imageslim" alt="Image"><br>scrollTop和scrollHeight 常用<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/KUMH12U4SN3f.png?imageslim" alt="Image">                        </p><h2 id="3-scroll事件"><a href="#3-scroll事件" class="headerlink" title="3.scroll事件"></a>3.scroll事件</h2><p><code>scroll</code> 滚动事件 只要滚动就会触发<br><code>window.pageYOffset</code> 是页面被卷去的头部  IE9 以上兼容<br><code>window.pageXOffset</code> 是页面被卷去的左侧  IE9 以上兼容<br><code>元素.scrollTop</code> 是元素被卷去的头部<br><code>元素.scrollLeft</code> 是元素被卷去的左侧</p><p>案例： 随着页面滚动，侧边栏发生变化</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM三大对象</title>
      <link href="/2017/06/20/2.webAPI/BOM/2.BOM%E4%B8%89%E5%A4%A7%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/06/20/2.webAPI/BOM/2.BOM%E4%B8%89%E5%A4%A7%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、location对象"><a href="#一、location对象" class="headerlink" title="一、location对象"></a>一、location对象</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><pre><code>window的location属性用于获取或设置窗体的URL，返回的是一个对象</code></pre><h2 id="2-URL"><a href="#2-URL" class="headerlink" title="2.URL"></a>2.URL</h2><p>统一资源定位符 格式：<br><code>protocol://host[:port]/path/[?query]#fragment</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/mNM8pYKkq7kw.png?imageslim" alt="Image"></p><h2 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h2><p>重点记住href和search<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/XwqIcSj9HHSV.png?imageslim" alt="Image"></p><h2 id="4-方法"><a href="#4-方法" class="headerlink" title="4.方法"></a>4.方法</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/nRL0iMQ2eij2.png?imageslim" alt="Image">    </p><h1 id="二、navigator对象"><a href="#二、navigator对象" class="headerlink" title="二、navigator对象"></a>二、navigator对象</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>包含浏览器相关信息</p><h2 id="2-常用属性"><a href="#2-常用属性" class="headerlink" title="2.常用属性"></a>2.常用属性</h2><p>navigator.userAgent<br>前端也可以判断访问类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">"手机链接"</span>;     </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">"PC链接"</span>;     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="三、history对象"><a href="#三、history对象" class="headerlink" title="三、history对象"></a>三、history对象</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p>window对象给我们提供了一个history对象，与浏览器历史记录进行交互。<br>该对象包含浏览器访问过的URL</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/f649lwXnB1NV.png?imageslim" alt="Image">        </p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM介绍和常用事件</title>
      <link href="/2017/06/20/2.webAPI/BOM/1.BOM%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/06/20/2.webAPI/BOM/1.BOM%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、BOM概述"><a href="#一、BOM概述" class="headerlink" title="一、BOM概述"></a>一、BOM概述</h1><h2 id="1-什么是BOM"><a href="#1-什么是BOM" class="headerlink" title="1.什么是BOM"></a>1.什么是BOM</h2><p>浏览器对象模型，提供了与浏览器窗口进行交互的对象<br>BOM的核心对象是window<br>BOM是非标准的，兼容性较差，不同浏览器厂商的BOM可能不同</p><h2 id="2-BOM的构成"><a href="#2-BOM的构成" class="headerlink" title="2.BOM的构成"></a>2.BOM的构成</h2><p>BOM包含DOM<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/ShyMnvO6msYS.png?imageslim" alt="Image">    </p><h2 id="3-window对象"><a href="#3-window对象" class="headerlink" title="3.window对象"></a>3.window对象</h2><p>window是浏览器的顶级对象，是一个全局对象；<br>全局变量和方法都可以被window调用，直接调用时相当于省略了window<br>window有一个特殊属性<code>window.name</code></p><h1 id="二、window对象常见事件"><a href="#二、window对象常见事件" class="headerlink" title="二、window对象常见事件"></a>二、window对象常见事件</h1><p>以下事件都有两种添加方式,带on和不带on</p><h2 id="1-窗口加载事件"><a href="#1-窗口加载事件" class="headerlink" title="1.窗口加载事件"></a>1.窗口加载事件</h2><pre><code>load </code></pre><p>整个页面全部加载完才执行里面的代码，可以利用此事件把js代码放到任意位置<br>传统方式只能写一次，addEventListener()可以写多个</p><pre><code>DOMContentLoaded</code></pre><p>DOM元素加载完就执行代码，不包括图片文字css等元素，加载速度更快</p><h2 id="2-调整窗口大小事件"><a href="#2-调整窗口大小事件" class="headerlink" title="2.调整窗口大小事件"></a>2.调整窗口大小事件</h2><p><code>resize</code> 浏览器窗口大小发生变化就会触发事件<br><code>window.innerWidth</code> 当前浏览器窗口宽度<br><code>window.innerHeight</code> 当前浏览器窗口高度</p><h1 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h1><h2 id="1-setTimeout延时器"><a href="#1-setTimeout延时器" class="headerlink" title="1.setTimeout延时器"></a>1.setTimeout延时器</h2><pre><code>window.setTimeout(调用函数, 延迟毫秒数)</code></pre><p>延迟一段时间后开始执行函数，只执行一次<br>window一般省略<br>调用函数可以写函数名或整个函数<br>延迟毫秒数如果省略是0立即执行<br>页面中可能有很多定时器，需要给定时器起名字区分</p><h2 id="2-setInterval定时器"><a href="#2-setInterval定时器" class="headerlink" title="2.setInterval定时器"></a>2.setInterval定时器</h2><pre><code>setInterval(调用函数, 间隔毫秒数)</code></pre><p>间隔多少时间重复执行 第一次调用也会有延迟时间，可以先调用一次函数 再定时</p><h2 id="3-停止定时器"><a href="#3-停止定时器" class="headerlink" title="3.停止定时器"></a>3.停止定时器</h2><pre><code>clearTimeout(定时器名字);clearInterval(定时器名字);</code></pre><h1 id="四、this指向问题"><a href="#四、this指向问题" class="headerlink" title="四、this指向问题"></a>四、this指向问题</h1><p>this的指向在函数执行时才能确定，一般指向调用函数的对象<br>全局作用域下、或者普通函数中this永远指向window（注意定时器里面的this指向window）；<br>方法/事件调用中 this指向方法/事件的调用者；<br>构造函数中 this指向函数的实例对象</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用鼠标和键盘事件</title>
      <link href="/2017/06/20/2.webAPI/DOM/9.%E5%B8%B8%E7%94%A8%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/06/20/2.webAPI/DOM/9.%E5%B8%B8%E7%94%A8%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用鼠标事件："><a href="#1-常用鼠标事件：" class="headerlink" title="1.常用鼠标事件："></a>1.常用鼠标事件：</h2><pre><code>click 点击  focus 获得焦点  blur 失去焦点 mouseover 鼠标经过mouseout 鼠标离开mouseenter 鼠标经过（不冒泡）mouseleave 鼠标离开（不冒泡）mousemove 鼠标移动 只要移动鼠标就会触发事件contextmenu 右键菜单 阻止默认行为可以禁用右键菜单selectstart 鼠标开始选中 阻止默认行为可以禁止选中文字</code></pre><h2 id="2-鼠标事件对象："><a href="#2-鼠标事件对象：" class="headerlink" title="2.鼠标事件对象："></a>2.鼠标事件对象：</h2><pre><code>e.clientX 鼠标在可视区的X坐标e.clientY 鼠标在可视区的Y坐标e.pageX 鼠标在页面文档的X坐标e.pageY 鼠标在页面文档的Y坐标e.screenX 鼠标在电脑屏幕的X坐标e.screenY 鼠标在电脑屏幕的Y坐标</code></pre><h2 id="3-常用键盘事件"><a href="#3-常用键盘事件" class="headerlink" title="3.常用键盘事件"></a>3.常用键盘事件</h2><pre><code>keyup     键盘弹起触发keydown     键盘按下触发 keypress     键盘按下触发 不识别功能键如ctrl shift 方向键等        </code></pre><p>如果三个事件都存在，执行顺序： 先keydown – keypress –keyup后</p><h2 id="4-键盘事件对象"><a href="#4-键盘事件对象" class="headerlink" title="4.键盘事件对象"></a>4.键盘事件对象</h2><pre><code>e.keyCode 返回该键的ASCII码值 </code></pre><p>keyup和keydown不区分字母大小写 a和A都是65<br>keypress区分大小写</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件高级</title>
      <link href="/2017/06/20/2.webAPI/DOM/8.%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
      <url>/2017/06/20/2.webAPI/DOM/8.%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、传统操作事件"><a href="#一、传统操作事件" class="headerlink" title="一、传统操作事件"></a>一、传统操作事件</h1><h2 id="1-传统方式注册"><a href="#1-传统方式注册" class="headerlink" title="1.传统方式注册"></a>1.传统方式注册</h2><p>行内注册<code>&lt;button onclick = &#39;alert(&#39;hello&#39;)&#39;&gt;点击&lt;/button&gt;</code><br>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.querySelector(&apos;button&apos;);</span><br><span class="line">btn.onclick = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><p>特点：同一个事件只能注册一个监听器(即回调函数)</p><h2 id="2-传统方式删除"><a href="#2-传统方式删除" class="headerlink" title="2.传统方式删除"></a>2.传统方式删除</h2><p>元素.onclick = null;<br>或者把function设置为null</p><h1 id="二、方法监听操作事件"><a href="#二、方法监听操作事件" class="headerlink" title="二、方法监听操作事件"></a>二、方法监听操作事件</h1><h2 id="1-方法监听注册"><a href="#1-方法监听注册" class="headerlink" title="1.方法监听注册"></a>1.方法监听注册</h2><pre><code>元素.addEventListener(&apos;事件类型&apos;,监听器,[第三个参数]);</code></pre><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">alert(&apos;hello&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事件类型要加引号，且不带on;<br>同一个元素 同一个事件可以添加多个监听器（事件处理程序）<br>第三个参数下面事件流有解释</p><p>IE9以下用attachEvent(‘事件类型带on’，监听器); 只在IE浏览器有效</p><h2 id="2-方法监听删除"><a href="#2-方法监听删除" class="headerlink" title="2.方法监听删除"></a>2.方法监听删除</h2><pre><code>元素.removeEventListener（&apos;事件类型&apos;,监听器名字 ） </code></pre><p>要写函数名字所以要把函数单独声明，删除时不带()</p><p>IE9以下使用 detachEvent(‘onclick’,fn)</p><h1 id="三、DOM事件流"><a href="#三、DOM事件流" class="headerlink" title="三、DOM事件流"></a>三、DOM事件流</h1><h2 id="1-事件流定义"><a href="#1-事件流定义" class="headerlink" title="1.事件流定义"></a>1.事件流定义</h2><p>js代码只能执行捕获或冒泡其中一个阶段<br>传统的添加事件方法onclick、attachEvent只能获取冒泡阶段，看不到捕获状态<br>addEventListener第三个参数如果为true是捕获阶段，为false或省略是冒泡阶段<br>有的事件是没有冒泡的如blur focus mouseenter mouseleave<br>当处于目标阶段时，捕获和冒泡按照代码书写顺序执行，不一定是先捕获再冒泡<br>事件流和位置没有关系，只要有嵌套都会传播事件</p><h1 id="四、事件对象-事件源参数"><a href="#四、事件对象-事件源参数" class="headerlink" title="四、事件对象(事件源参数)"></a>四、事件对象(事件源参数)</h1><p>可以自己定义名称event、evt、e<br>事件对象写在侦听器的小括号里，当形参来看；<br>有事件就存在事件对象，不需要传递参数，系统自动创建；<br>包含了事件相关的信息集合，如鼠标事件集合、键盘事件集合<br>IE678只兼容window.event，兼容性处理： e = e || window.event</p><h2 id="1-事件对象常见的属性"><a href="#1-事件对象常见的属性" class="headerlink" title="1.事件对象常见的属性"></a>1.事件对象常见的属性</h2><p><code>e.target</code> 返回触发事件的对象  和this的区别：this是返回绑定事件的对象<br><code>e.srcElement</code> IE678兼容 返回触发事件的对象<br><code>e.type</code> 返回事件类型</p><h2 id="2-事件对象常见的方法"><a href="#2-事件对象常见的方法" class="headerlink" title="2.事件对象常见的方法"></a>2.事件对象常见的方法</h2><p><strong>1.阻止默认行为</strong><br>让链接不跳转 让提交按钮不提交<br><code>e.preventDefault();</code> 是方法  标准写法 不支持ie678<br><code>return false; return</code>后面代码不执行 仅限于传统注册方式<br><code>e.returnValue;</code> 是属性  非标准 ie678使用<br><strong>2.阻止冒泡</strong><br><code>e.stopPropagtion();</code> 写在哪里从哪个元素开始不再冒泡</p><p>事件冒泡的应用：事件委托<br>原理：把事件注册给父元素，利用冒泡原理，子元素冒泡到父元素上，减少dom操作次数提高性能</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点和节点操作</title>
      <link href="/2017/06/20/2.webAPI/DOM/7.%E8%8A%82%E7%82%B9%E5%92%8C%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/20/2.webAPI/DOM/7.%E8%8A%82%E7%82%B9%E5%92%8C%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么学节点操作"><a href="#一、为什么学节点操作" class="headerlink" title="一、为什么学节点操作"></a>一、为什么学节点操作</h1><p>利用节点间的关系获取元素更简单，逻辑性比较强</p><h1 id="二、节点概述"><a href="#二、节点概述" class="headerlink" title="二、节点概述"></a>二、节点概述</h1><h2 id="1-什么是节点"><a href="#1-什么是节点" class="headerlink" title="1.什么是节点"></a>1.什么是节点</h2><p>网页中所有内容（属性、文本、元素等）都是节点，在DOM中用node表示</p><h2 id="2-节点属性和分类"><a href="#2-节点属性和分类" class="headerlink" title="2.节点属性和分类"></a>2.节点属性和分类</h2><p>nodeType节点类型 元素节点是1  属性节点是2 文本节点是3<br>nodeName节点名称<br>nodeValue节点值<br>我们主要操作的是<strong>元素节点</strong></p><h1 id="三、节点层级"><a href="#三、节点层级" class="headerlink" title="三、节点层级"></a>三、节点层级</h1><p>如果没有找到节点返回null</p><h2 id="1-父节点"><a href="#1-父节点" class="headerlink" title="1.父节点"></a>1.父节点</h2><pre><code>element.parentNode</code></pre><p>得到离元素最近的父亲节点（亲爸爸）</p><h2 id="2-子节点"><a href="#2-子节点" class="headerlink" title="2.子节点"></a>2.子节点</h2><pre><code>element.childNodes 得到所有子节点的集合，包括所有节点类型，不提倡使用element.children 得到子元素节点的集合，只获得元素节点，实际常用element.firstChild 得到第一个子节点 .lastChild 得到最后一个子节点element.firstElementChild 得到第一个子元素节点  IE9以上支持element.lastElementChild 得到第一个子元素节点 IE9以上支持</code></pre><p>实际开发使用children加索引号选择first和last，既没有兼容性问题又能选择元素节点<br>        如第一个ul.children[0]<br>        最后一个ul.children[ul.children.length-1]</p><h2 id="3-兄弟节点-使用较少"><a href="#3-兄弟节点-使用较少" class="headerlink" title="3.兄弟节点 使用较少"></a>3.兄弟节点 使用较少</h2><pre><code>node.nextSibling 下一个兄弟节点 包括所有类型node.previousSibling 上一个兄弟节点 包括所有类型node.nextElementSibling 下一个兄弟元素节点 IE9以上支持node.previousElementSibling 上一个兄弟元素节点 IE9以上支持</code></pre><h1 id="四、节点操作"><a href="#四、节点操作" class="headerlink" title="四、节点操作"></a>四、节点操作</h1><h2 id="1-创建节点"><a href="#1-创建节点" class="headerlink" title="1.创建节点"></a>1.创建节点</h2><pre><code>document.createElement(&apos;标签名&apos;)</code></pre><p>创建完要添加才能看到</p><h2 id="2-添加节点"><a href="#2-添加节点" class="headerlink" title="2.添加节点"></a>2.添加节点</h2><pre><code>父节点.appendChild(子节点)  </code></pre><p>添加的子节点是放在父亲的末尾</p><pre><code>父节点.insertBefore(&apos;要插入的节点&apos;, 子节点) </code></pre><p>添加在某个子节点之前</p><h2 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.删除节点"></a>3.删除节点</h2><pre><code>父节点.removeChild(子节点)</code></pre><h2 id="4-克隆节点"><a href="#4-克隆节点" class="headerlink" title="4.克隆节点"></a>4.克隆节点</h2><pre><code>node.cloneNode(参数) 得到node的克隆节点</code></pre><p>参数：true 表示完全克隆，默认false 只克隆元素标签  </p><h1 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h1><p>创建多个元素时<br><code>document.write(&#39;&lt;p&gt;&lt;/p&gt;&#39;)</code>直接将内容写入页面的内容流，但是页面加载完毕会导致页面重绘<br><code>innerHTML</code>拼接字符串时，效率比较低，采取数组形式效率很高但是结构较复杂<br><code>createElement(&#39;p&#39;)</code>创建多个元素效率稍低，但是结构更清晰</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义属性</title>
      <link href="/2017/06/20/2.webAPI/DOM/6.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/06/20/2.webAPI/DOM/6.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义属性操作"><a href="#自定义属性操作" class="headerlink" title="自定义属性操作"></a>自定义属性操作</h2><p>自定义属性是程序员自己创建的属性</p><h3 id="1）获取属性值有两种方法："><a href="#1）获取属性值有两种方法：" class="headerlink" title="1）获取属性值有两种方法："></a>1）获取属性值有两种方法：</h3><pre><code>element.属性名  只能获取内置属性element.getAttribute(&apos;属性名&apos;)  还可以获取自定义属性，获取到的是字符型</code></pre><h3 id="2）修改属性值的两种方法："><a href="#2）修改属性值的两种方法：" class="headerlink" title="2）修改属性值的两种方法："></a>2）修改属性值的两种方法：</h3><pre><code>element.属性名 = &apos;属性值&apos;;  只能修改内置属性element.setAttribute(&apos;属性名&apos;,&apos;属性值&apos;);  可以修改自定义属性</code></pre><h3 id="3）移除属性的方法"><a href="#3）移除属性的方法" class="headerlink" title="3）移除属性的方法"></a>3）移除属性的方法</h3><pre><code>element.removeAttribute(&apos;属性名&apos;);</code></pre><h2 id="tab栏切换案例-重要"><a href="#tab栏切换案例-重要" class="headerlink" title="tab栏切换案例 重要"></a>tab栏切换案例 重要</h2><p>设置自定义属性判断用户点了哪一个tab栏</p><h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p>属性有时不好确认是内置属性还是自定义属性；<br>H5规定所有新增的自定义属性命名都由data-开头</p><p>H5新增了获取自定义属性的方法： (IE11以上支持)<br>例如自定义属性是data-index-name，获取时：<code>element.dataset.indexName</code>或<code>element.dataset[&#39;indexName&#39;]</code><br>dataset是一个集合 里面存放了所有以data-开头的自定义属性</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排他思想</title>
      <link href="/2017/06/20/2.webAPI/DOM/5.%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3/"/>
      <url>/2017/06/20/2.webAPI/DOM/5.%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：<br>1.所有元素全部清除样式<br>2.给当前元素设置样式<br>3.注意顺序不能颠倒<br>利用双层for循环<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190525/izPokjzR8tgX.png?imageslim" alt="Image"></p><p>案例：百度换肤<br>案例：隔行变色<br>案例：全选反选 重点</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="/2017/06/20/2.webAPI/DOM/4.DOM%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/20/2.webAPI/DOM/4.DOM%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-改变元素内容"><a href="#1-改变元素内容" class="headerlink" title="1.改变元素内容"></a>1.改变元素内容</h1><p><code>element.innerText  = 内容;</code><br><code>element.innerHTML  = 内容;</code><br>都可以读写，获取/修改文字内容<br>获取的区别：<br>    <code>innerText 不获取空格 标签 只会获取文本</code><br>    <code>innerHTML 获取空格 标签 和文本</code><br>设置内容时的区别：<br>    <code>innerText 不会解析html标签</code><br>    <code>innerHTML 会解析html标签</code></p><hr><h1 id="2-修改元素属性"><a href="#2-修改元素属性" class="headerlink" title="2.修改元素属性"></a>2.修改元素属性</h1><p><code>element.属性 = 属性值;</code><br>案例： 分时问候</p><hr><h1 id="3-修改表单元素的属性"><a href="#3-修改表单元素的属性" class="headerlink" title="3.修改表单元素的属性"></a>3.修改表单元素的属性</h1><p>修改表单元素里面的内容 是通过改变value属性修改的；<br>其他可以操作的表单属性还有<code>type value checked selected disabled</code><br>使用举例：btn.disabled = true; 表示此按钮被禁用了</p><p>事件下的this指向事件的调用者<br>属性名 = 属性值 js里用true表示 如<code>checked，disabled，selected</code></p><p>案例：密码框文字显示隐藏</p><hr><h1 id="4-修改样式属性"><a href="#4-修改样式属性" class="headerlink" title="4.修改样式属性"></a>4.修改样式属性</h1><h2 id="1）行内样式操作"><a href="#1）行内样式操作" class="headerlink" title="1）行内样式操作"></a>1）行内样式操作</h2><p><code>element.style.属性=&#39;属性值&#39;;</code><br>属性采取驼峰命名法书写，如fontSize,backgroundColor<br>修改完，生成的是行内样式 权重比较高<br>案例：循环精灵图、显示隐藏文本框内容</p><h2 id="2）类名样式操作"><a href="#2）类名样式操作" class="headerlink" title="2）类名样式操作"></a>2）类名样式操作</h2><p><code>element.className = &#39;类名&#39;;</code><br>有很多样式需要修改时，style方式书写较为麻烦，采取类名修改样式属性<br>在css新类里写好要变化的样式，在事件函数里设置<br>        element.className = ‘类名’<br>更改元素的样式<br>*<em>注意: *</em>会覆盖原来的类名，要保留原来的类名需要在两个类之间加空格</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素获取</title>
      <link href="/2017/06/20/2.webAPI/DOM/3.DOM%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96/"/>
      <url>/2017/06/20/2.webAPI/DOM/3.DOM%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p><strong>元素才能使用这些方法</strong></p><h2 id="1-根据id获取"><a href="#1-根据id获取" class="headerlink" title="1.根据id获取"></a>1.根据id获取</h2><p><code>document.getElementById(&quot;id值&quot;)</code><br>id加引号 区分大小写<br>只能是document<br>返回的是DOM的元素对象,类型是object<br>console.dir(元素);可以查看元素对象的详细信息</p><h2 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2.根据标签名获取"></a>2.根据标签名获取</h2><p><code>getElementsByTagName()</code><br>括号里标签名要加引号；<br>返回的是元素对象的集合，以伪数组的形式存储；<br>可以通过遍历的方式依次打印元素对象<br>元素对象是动态的<br>可以通过<code>element.getElementsByTagName(&#39;&#39;)</code>获取某种元素里面的所有标签</p><h2 id="3-根据类名获取"><a href="#3-根据类名获取" class="headerlink" title="3.根据类名获取"></a>3.根据类名获取</h2><p><code>getElementsByClassName()</code><br>返回的也是伪数组形式的对象集合，想要访问单个对象需要加索引号</p><h2 id="4-H5新增获取元素的方法"><a href="#4-H5新增获取元素的方法" class="headerlink" title="4.H5新增获取元素的方法"></a>4.H5新增获取元素的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#id&apos;)</span><br><span class="line">document.querySelector(&apos;.classname&apos;) </span><br><span class="line">document.querySelector(&apos;标签名&apos;)</span><br></pre></td></tr></table></figure><p>如果有多个相同的id、类名、标签名，只获取第一个<br>如果想获取全部的，使用<code>document.querySelectorAll()</code><br>返回的是伪数组对象集合nodelist<br>括号里面还可以写div:first-child</p><h2 id="5-获取特殊元素"><a href="#5-获取特殊元素" class="headerlink" title="5.获取特殊元素"></a>5.获取特殊元素</h2><p>1)获取body元素<br><code>document.body</code><br>2)获取html元素<br><code>document.documentElement</code></p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件基础</title>
      <link href="/2017/06/20/2.webAPI/DOM/2.%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/06/20/2.webAPI/DOM/2.%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事件概述"><a href="#1-事件概述" class="headerlink" title="1.事件概述"></a>1.事件概述</h2><p>事件：可以被js侦测到的行为</p><h2 id="2-事件三要素"><a href="#2-事件三要素" class="headerlink" title="2.事件三要素"></a>2.事件三要素</h2><ul><li>事件源 事件被触发的对象 谁被触发</li><li>事件类型 如何触发 什么事件</li><li>事件处理程序 通过一个函数赋值的方式完成<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">alert(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-事件执行的步骤"><a href="#3-事件执行的步骤" class="headerlink" title="3.事件执行的步骤"></a>3.事件执行的步骤</h2><ul><li>获取事件源  </li><li>注册事件/绑定事件  不是必须有的</li><li>添加事件处理程序 函数赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API和DOM简介</title>
      <link href="/2017/06/20/2.webAPI/DOM/1.API%E5%92%8CDOM%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/06/20/2.webAPI/DOM/1.API%E5%92%8CDOM%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h1><h2 id="1-Web-APIs和js基础关联性"><a href="#1-Web-APIs和js基础关联性" class="headerlink" title="1.Web APIs和js基础关联性"></a>1.Web APIs和js基础关联性</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190524/ko6kIKqonlsF.png?imageslim" alt="Image"></p><h2 id="2-API和Web-API"><a href="#2-API和Web-API" class="headerlink" title="2.API和Web API"></a>2.API和Web API</h2><p>API:应用程序编程接口，是给程序员提供的一种工具，以便轻松实现想要的功能<br>Web API:浏览器提供的操作浏览器功能（BOM）和页面元素（DOM）的API，主要针对浏览器做交互效果</p><h1 id="二、DOM"><a href="#二、DOM" class="headerlink" title="二、DOM"></a>二、DOM</h1><h2 id="1-DOM简介"><a href="#1-DOM简介" class="headerlink" title="1.DOM简介"></a>1.DOM简介</h2><p>文档对象模型，处理HTML和XML的标准编程接口。可以改变网页的内容、结构和样式<br>DOM树：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190524/UoqjwpaqNzMq.png?imageslim" alt="Image"><br>文档： document     元素：element所有标签     节点： node所有内容<br>DOM把以上内容都看做是对象</p>]]></content>
      
      
      <categories>
          
          <category> WebAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单类型和复杂类型</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/9.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/9.%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简单数据类型（值类型）"><a href="#一、简单数据类型（值类型）" class="headerlink" title="一、简单数据类型（值类型）"></a>一、简单数据类型（值类型）</h1><h2 id="1-五大类"><a href="#1-五大类" class="headerlink" title="1.五大类"></a>1.五大类</h2><p><code>string ，number，boolean，undefined，null(null是一个空object)</code></p><h2 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2.存储方式"></a>2.存储方式</h2><p>存储在栈中，内存直接开辟空间，存放的是值</p><h2 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的<strong>值复制</strong>了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部的变量。</p><h1 id="二、复杂数据类型（引用类型）"><a href="#二、复杂数据类型（引用类型）" class="headerlink" title="二、复杂数据类型（引用类型）"></a>二、复杂数据类型（引用类型）</h1><h2 id="1-用new声明的都是"><a href="#1-用new声明的都是" class="headerlink" title="1.用new声明的都是"></a>1.用new声明的都是</h2><p>Object、Array、Date等</p><h2 id="2-存储方式-1"><a href="#2-存储方式-1" class="headerlink" title="2.存储方式"></a>2.存储方式</h2><p>在栈里存放的是地址（16进制），地址指向堆内存里的数据， 真正的对象实例存放在堆空间中</p><h2 id="3-参数传递-1"><a href="#3-参数传递-1" class="headerlink" title="3.参数传递"></a>3.参数传递</h2><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的<strong>堆地址复制</strong>给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内置对象</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/8.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/8.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-js对象分类"><a href="#1-js对象分类" class="headerlink" title="1.js对象分类"></a>1.js对象分类</h2><p>自定义对象（ECMAScript）、内置对象（ECMAScript）、浏览器对象（JSAPI）</p><h2 id="2-什么是内置对象"><a href="#2-什么是内置对象" class="headerlink" title="2.什么是内置对象"></a>2.什么是内置对象</h2><p>JS自带的一些对象，提供了常用的功能和方法，优点：帮助我们快速开发</p><h2 id="3-有哪些内置对象"><a href="#3-有哪些内置对象" class="headerlink" title="3.有哪些内置对象"></a>3.有哪些内置对象</h2><p>Math,Date,Array,String等</p><hr><h1 id="二、内置对象学习方法"><a href="#二、内置对象学习方法" class="headerlink" title="二、内置对象学习方法"></a>二、内置对象学习方法</h1><h2 id="1-MDN"><a href="#1-MDN" class="headerlink" title="1.MDN"></a>1.MDN</h2><p><a href="http://developer.mozilla.org" target="_blank" rel="noopener">http://developer.mozilla.org</a></p><h2 id="2-使用内置对象的方法"><a href="#2-使用内置对象的方法" class="headerlink" title="2.使用内置对象的方法"></a>2.使用内置对象的方法</h2><p>  查阅该方法的功能<br>  查看里面参数的意义和类型<br>  查看返回值的意义和类型<br>  通过demo进行测试</p><hr><h1 id="三、Math对象"><a href="#三、Math对象" class="headerlink" title="三、Math对象"></a>三、Math对象</h1><p>Math不是构造函数，不需要new关键字</p><h2 id="1-属性PI，最大值max最小值min"><a href="#1-属性PI，最大值max最小值min" class="headerlink" title="1.属性PI，最大值max最小值min"></a>1.属性PI，最大值max最小值min</h2><pre><code>Math.PIMath.max()Math.min()</code></pre><h2 id="2-绝对值"><a href="#2-绝对值" class="headerlink" title="2.绝对值"></a>2.绝对值</h2><pre><code>Math.abs();</code></pre><h2 id="3-三个取整方法"><a href="#3-三个取整方法" class="headerlink" title="3.三个取整方法"></a>3.三个取整方法</h2><pre><code>向下取整： Math.floor();向上取整： Math.ceil();四舍五入： Math.round();    注意Math.round(-1.5) 结果是-1 因为.5往大了取</code></pre><h2 id="4-随机数方法"><a href="#4-随机数方法" class="headerlink" title="4.随机数方法"></a>4.随机数方法</h2><pre><code>Math.random()返回随机小数，默认范围在[0,1)之间；括号内没有参数；1）想要得到两个数之间的随机整数，包括最小和最大值：function getRandom(min, max) {    return Math.floor(Math.random() * (max - min + 1)) + min;  }2）随机点名    把数组的索引号改成随机整数即可，范围在 0 ~ length-1之间</code></pre><hr><h1 id="四、日期对象"><a href="#四、日期对象" class="headerlink" title="四、日期对象"></a>四、日期对象</h1><p>Date()是构造函数，必须使用new来调用 类似的还有Array()和Object()</p><h2 id="1-使用Date"><a href="#1-使用Date" class="headerlink" title="1.使用Date"></a>1.使用Date</h2><pre><code>如果没有参数 返回系统当前时间    var date1 = new Date();  有参数时：     参数是数字型 var date2 = new Date(2019,10,01);    11月    参数是字符串型 var date3 = new Date(&apos;2019-10-1 10:59:00&apos;);</code></pre><h2 id="2-日期的方法：格式化日期"><a href="#2-日期的方法：格式化日期" class="headerlink" title="2.日期的方法：格式化日期"></a>2.日期的方法：格式化日期</h2><p>var date = new Date();<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/nMYv7O8QJMHw.png?imageslim" alt="mark"></p><pre><code>方法：    date.getFullYear() 获取年份    date.getMonth() 获取月份 取值是0-11    date.getDate() 获取日    date.getDay() 获取周几 取值是0-6 对应周日-周六    date.getHours()  获取时    date.getMinutes() 获取分    date.getSeconds() 获取秒获取毫秒值的方法： 自1970年1月1日开始    date.valueOf()  获取当前毫秒数    date.getTime()  获取当前毫秒数    var times = +new Date(); 最常用              不给参数是当前时间             给参数是指定时间的毫秒数    Date.now()  h5新增 不需要new对象</code></pre><h2 id="倒计时案例："><a href="#倒计时案例：" class="headerlink" title="倒计时案例："></a>倒计时案例：</h2><p>用 时间戳（毫秒数） 转换为时分秒<br>输入时间总毫秒数 - 当前时间总毫秒数 获得 倒计时总时间<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/9G3XdiEmCqUo.png?imageslim" alt="mark"></p><hr><h1 id="五、数组对象"><a href="#五、数组对象" class="headerlink" title="五、数组对象"></a>五、数组对象</h1><h2 id="1-判断对象是否某种类型"><a href="#1-判断对象是否某种类型" class="headerlink" title="1.判断对象是否某种类型"></a>1.判断对象是否某种类型</h2><pre><code>var arr =[];1.instanceof方法        arr instanceof Array  返回true      null instanceof Object返回true2.Array.isArray(arr) 返回true</code></pre><h2 id="2-添加删除数组元素的方法"><a href="#2-添加删除数组元素的方法" class="headerlink" title="2.添加删除数组元素的方法"></a>2.添加删除数组元素的方法</h2><pre><code>数组名.push(元素);     向数组末尾添加元素 返回值是数组长度数组名.pop();         删除数组末尾的元素 返回值是被删除的元素数组名.unshift(元素);     在数组前面添加元素 返回值是数组长度数组名.shift();         删除数组第一个元素 返回值是被删除的元素</code></pre><h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><pre><code>数组名.reverse(); 翻转数组元素 返回新数组 改变原数组数组名.sort(); 给数组元素排序，参数是排序函数 返回新数组 改变原数组sort(function(a,b){    return a-b; //升序    return b-a; //降序})</code></pre><h2 id="4-数组元素索引方法"><a href="#4-数组元素索引方法" class="headerlink" title="4.数组元素索引方法"></a>4.数组元素索引方法</h2><pre><code>数组名.indexOf(元素)      从前往后查找    只返回第一个满足条件的索引号；    数组中如果没有该元素返回-1；数组名.lastIndexOf(元素)      倒着查找 返回值相同</code></pre><p>利用此方法实现数组去重<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/H20KEJIBbFzY.png?imageslim" alt="mark"></p><h2 id="5-数组转换为字符串"><a href="#5-数组转换为字符串" class="headerlink" title="5.数组转换为字符串"></a>5.数组转换为字符串</h2><pre><code>arr.toString()arr.join(‘分隔符’)  不写分隔符默认是逗号 常用的分隔符  -  &amp;</code></pre><h2 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6.其他方法"></a>6.其他方法</h2><pre><code>arr1.concat(arr2)  连接两个数组     返回新数组     不改变原数组slice(开始索引,结束索引)  截取数组     不改变原数组    截取部分数组元素 包含开始不包含结束      返回截取掉的新数组    如果只给一个参数，从此索引开始往后截取splice(开始索引，截取长度，替换元素)  截取数组     返回截取掉的新数组    改变原数组     替换元素是替换了被截取掉的元素</code></pre><hr><h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><h2 id="1-基本包装类型"><a href="#1-基本包装类型" class="headerlink" title="1.基本包装类型"></a>1.基本包装类型</h2><p>概念<br>对象才有属性和方法，为什么字符串也有length属性？<br>因为存在基本包装类型：JS 把 简单数据类型 包装成 复杂数据类型</p><p>后台包装过程：<br>    1.创建对象，变量是b<br>    2.把变量b给变量a<br>    3.销毁变量b<br>基本包装类型创建完就销毁，不能再添加其他属性和方法。<br>可以使用部分js定义的属性和方法</p><h2 id="2-字符串不可变性"><a href="#2-字符串不可变性" class="headerlink" title="2.字符串不可变性"></a>2.字符串不可变性</h2><p>给字符串重新赋值，不会删除原有的字符串，只是改变了字符串变量的内存地址。原来的内存空间仍然存在。因此不要大量拼接字符串，可以把数据放在数组里，然后转换为字符串。</p><h2 id="3-字符串方法"><a href="#3-字符串方法" class="headerlink" title="3.字符串方法"></a>3.字符串方法</h2><p><strong>所有字符串方法都不改变原来的字符串</strong></p><h3 id="1-查找字符位置"><a href="#1-查找字符位置" class="headerlink" title="1.查找字符位置"></a>1.查找字符位置</h3><pre><code>indexOf(&apos;字符&apos;,起始位置)和数组的indexOf方法相同，找到返回索引值，找不到返回-1案例：统计某个字符出现的位置和次数</code></pre><h3 id="2-查找对应位置的字符"><a href="#2-查找对应位置的字符" class="headerlink" title="2.查找对应位置的字符"></a>2.查找对应位置的字符</h3><pre><code>str.charAt(索引）        返回对应索引的字符str.charCodeAt(索引)       返回字符的ASCII码，可以判断用户按下的哪个键str[索引] H5新增</code></pre><h3 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3.拼接字符串"></a>3.拼接字符串</h3><pre><code>str1.concat(str2) 把str1和str2相连  返回新字符串 推荐使用加号</code></pre><h3 id="4-转换成大写"><a href="#4-转换成大写" class="headerlink" title="4.转换成大写"></a>4.转换成大写</h3><pre><code>str.toUpperCase() 把整个字符串转换成大写str[i].toUpperCase()  可以单独转换某个字符</code></pre><h3 id="5-转换成小写"><a href="#5-转换成小写" class="headerlink" title="5.转换成小写"></a>5.转换成小写</h3><pre><code>str.toLowerCase() 把整个字符串转换成小写str[i].toLowerCase() 单独转换某个字符</code></pre><h3 id="6-截取"><a href="#6-截取" class="headerlink" title="6.截取"></a>6.截取</h3><pre><code>substring(开始索引，结束索引); 包括开始不包括结束，如果只有一个值，从该索引截取到字符串末尾</code></pre><h3 id="7-替换字符"><a href="#7-替换字符" class="headerlink" title="7.替换字符"></a>7.替换字符</h3><pre><code>str.replace(&apos;a&apos;,&apos;b&apos;)  把字符a 替换为字符b 只会替换第一个遇到的字符    </code></pre><h3 id="8-转换成数组"><a href="#8-转换成数组" class="headerlink" title="8.转换成数组"></a>8.转换成数组</h3><pre><code>str.split(&apos;分隔符&apos;)  把字符串转换为数组，并添加分隔符分隔符取决于原来字符串内的分隔符</code></pre>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
            <tag> 内置对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/7.%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/7.%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对象概念"><a href="#一、对象概念" class="headerlink" title="一、对象概念"></a>一、对象概念</h1><h2 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1.什么是对象"></a>1.什么是对象</h2><p>是一个具体的事物，不能是泛指的概念<br>JS中，对象是一组无序的相关属性和方法的集合，<br>键值对的集合、数据集和功能集 的集合</p><h2 id="2-为什么需要对象"><a href="#2-为什么需要对象" class="headerlink" title="2.为什么需要对象"></a>2.为什么需要对象</h2><p>和变量和数组相比，对象可以保存的信息结构更清晰</p><h1 id="二、创建对象的三种方式"><a href="#二、创建对象的三种方式" class="headerlink" title="二、创建对象的三种方式"></a>二、创建对象的三种方式</h1><h2 id="1-用字面量创建"><a href="#1-用字面量创建" class="headerlink" title="1.用字面量创建"></a>1.用字面量创建</h2><p>方式1    var 对象字面量： {属性和方法}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name : <span class="string">'shawn'</span>,</span><br><span class="line">sayHi : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2 创建空对象，再添加值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;&#125;;</span><br><span class="line">obj.name=<span class="string">'shawn'</span>;</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-使用Object"><a href="#2-使用Object" class="headerlink" title="2.使用Object"></a>2.使用Object</h2><p>方式1 先创建空对象再给值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'shawn'</span>;</span><br></pre></td></tr></table></figure><p>方式2 创建同时赋值：    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">name : <span class="string">'shawn'</span>,</span><br><span class="line">age : <span class="number">18</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-使用构造函数创建对象"><a href="#3-使用构造函数创建对象" class="headerlink" title="3.使用构造函数创建对象"></a>3.使用构造函数创建对象</h2><p>以上方式一次只能创建一个对象<br>构造函数： 把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面，这种思想称为工厂模式；<br>    构造函数里面封装的是对象，泛指的某一大类;对象是特指的某一个<br>语法格式：<br>    声明：    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.属性 = 值；</span><br><span class="line"><span class="keyword">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<code>var  对象名 = new 构造函数名(实参);</code><br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/SEYJWlvB0TTh.png?imageslim" alt="mark">        </p><p>1.构造函数名首字母要大写；<br>2.构造函数不需要return就可以返回结果，返回的是对象；<br>3.调用构造函数必须使用new关键字</p><p>利用构造函数创建对象的过程也称为对象的实例化</p><p>ps:工厂模式和构造函数封装对象的不同之处：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/y8R94kw8rh5g.png?imageslim" alt="mark"><br>函数名首字母不需要大小；内部需要定义一个空对象；需要return此对象；不需要使用new和this关键字</p><h2 id="4-对象的使用方法"><a href="#4-对象的使用方法" class="headerlink" title="4.对象的使用方法"></a>4.对象的使用方法</h2><p>1）获取对象的属性<br>    方法1： 对象名.属性名  <code>obj.name</code><br>    方法2： 对象名[‘属性名’]   <code>obj[&#39;age&#39;]</code><br>2）调用对象的方法： 对象名.方法名  <code>obj.sayHi();</code></p><h1 id="三、new关键字"><a href="#三、new关键字" class="headerlink" title="三、new关键字"></a>三、new关键字</h1><p>new的执行过程<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/unQzcVf4UKME.png?imageslim" alt="mark">    </p><h1 id="四、对象的遍历"><a href="#四、对象的遍历" class="headerlink" title="四、对象的遍历"></a>四、对象的遍历</h1><p>使用for in 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(k);  <span class="comment">//输出属性名和方法名</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[k]);  <span class="comment">//输出属性值和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和预解析</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/6.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/6.%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h1><h2 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h2><p>代码名字（变量）在某个范围内起作用，这个范围就是作用域<br>目的是为了提高程序的可靠性，减少命名冲突<br>不同作用域下，相同的名字不会冲突</p><h2 id="2-js作用域分类（ES6之前）"><a href="#2-js作用域分类（ES6之前）" class="headerlink" title="2.js作用域分类（ES6之前）"></a>2.js作用域分类（ES6之前）</h2><p>全局作用域：整个script标签或者整个js文件<br>局部作用域：代码名字只在函数内部起作用<br>现阶段没有块级作用域，在ES6中新增了块级作用域，即{ }花括号里面的变量外面不能使用</p><h2 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h2><p>根据作用域的不同，变量分为两种，全局变量和局部变量<br>    全局变量：在任何地方都可以使用；只有在浏览器关闭时才会销毁，占内存更多<br>    局部变量：在函数内部的变量，只能在当前函数内使用；函数结束时就会销毁，节约内存空间</p><p>在函数内部 不声明只赋值的变量 也属于全局变量<br>函数的形参也属于局部变量</p><h2 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h2><p>函数嵌套时，内部函数可以访问外部函数的变量，用链式查找的方式决定变量的值，这种结构称为作用域链。取值按照就近原则。</p><h1 id="二、预解析"><a href="#二、预解析" class="headerlink" title="二、预解析"></a>二、预解析</h1><p>js解释器运行js代码分为两步<br>    1.预解析 ：把js代码所有var和function提升到当前作用域的最前面<br>    2.代码执行 ：从上到下执行代码</p><h1 id="1-变量预解析（变量提升）：只提升声明，不提升赋值"><a href="#1-变量预解析（变量提升）：只提升声明，不提升赋值" class="headerlink" title="1.变量预解析（变量提升）：只提升声明，不提升赋值"></a>1.变量预解析（变量提升）：只提升声明，不提升赋值</h1><p>变量：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/3OhXKN0D8m4L.png?imageslim" alt="mark"><br>函数以变量形式声明时：<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/LCntf5zB4B58.png?imageslim" alt="mark"></p><h1 id="2-函数预解析（函数提升）："><a href="#2-函数预解析（函数提升）：" class="headerlink" title="2.函数预解析（函数提升）："></a>2.函数预解析（函数提升）：</h1><p>函数以这种形式声明时<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/QcbeaYtFJDEY.png?imageslim" alt="mark"><br>只提升函数声明，不调用函数。因此声明和调用的先后顺序不影响执行。<br>案例<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/QyCog6HlvvL6.png?imageslim" alt="mark"><br>输出 9 9 9 9 9 error</p><p>在函数内部，形参与变量名重名时，以形参为主<br>函数内部，只给值不声明是全局变量。但是不能和形参重名，重名的话就不是全局变量了<br>函数调用时，不会改变函数原来的作用域</p><p>​                ​            </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/5.%E5%87%BD%E6%95%B0/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/5.%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、函数的概念"><a href="#一、函数的概念" class="headerlink" title="一、函数的概念"></a>一、函数的概念</h1><h2 id="1-为什么需要函数"><a href="#1-为什么需要函数" class="headerlink" title="1.为什么需要函数"></a>1.为什么需要函数</h2><p>让大量代码可以被重复使用；<br>代码模块化；</p><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><p>封装了一块可以被重复执行调用的代码块,对外只提供一个简单的函数接口</p><h1 id="二、函数的使用"><a href="#二、函数的使用" class="headerlink" title="二、函数的使用"></a>二、函数的使用</h1><p>两个步骤：</p><h2 id="1-声明函数"><a href="#1-声明函数" class="headerlink" title="1.声明函数"></a>1.声明函数</h2><p>方式1    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 函数名 = function()&#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时    fn();<br>fn是变量名 不是函数名<br>函数表达式也可以传递参数</p><p>函数名一般是动词，驼峰命名法；</p><h2 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2.调用函数"></a>2.调用函数</h2><p>函数名();</p><p>函数不调用，自己不执行；</p><h1 id="三、函数的参数"><a href="#三、函数的参数" class="headerlink" title="三、函数的参数"></a>三、函数的参数</h1><p>形参和实参<br>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名（形参1，形参2...）&#123;</span><br><span class="line">函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>    <code>函数名(实参1，实参2...);</code></p><p>形参是接收实参的，类似于变量；<br>函数的参数可有可无，数量不限；</p><p>形参和实参个数关系：<br>    个数相等：一一匹配；<br>    实参个数 &gt; 形参个数：舍弃多余的实参；<br>    实参个数 &lt; 形参个数：没有接收到值的形参是undifined；</p><h1 id="四、函数的返回值"><a href="#四、函数的返回值" class="headerlink" title="四、函数的返回值"></a>四、函数的返回值</h1><h2 id="1-return语句"><a href="#1-return语句" class="headerlink" title="1.return语句"></a>1.return语句</h2><p>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">函数体；</span><br><span class="line">return 需要返回的值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>    <code>函数名();</code></p><p>函数体内不应该写输出语句<br>使用return把函数结果返回给调用者，即 函数名() = 返回的值；</p><p>return只能返回一个值，如果写了多个，只会返回最后一个值；想返回多个值可以使用数组；</p><h2 id="2-return会终止函数"><a href="#2-return会终止函数" class="headerlink" title="2.return会终止函数"></a>2.return会终止函数</h2><p>return之后的函数语句不再执行，退出函数并返回值</p><h2 id="3-函数没有return返回undifined"><a href="#3-函数没有return返回undifined" class="headerlink" title="3.函数没有return返回undifined"></a>3.函数没有return返回undifined</h2><p>只要是函数都有返回值，函数没有return时返回值是undifined</p><h1 id="五、arguments的使用"><a href="#五、arguments的使用" class="headerlink" title="五、arguments的使用"></a>五、arguments的使用</h1><p>由于不确定传递多少个实参过来，<br>可以用arguments存储所有传递过来的实参，不再使用形参，跟形参无关<br>    1.arguments是伪数组，具有length属性和索引，但是没有真正数组的一些方法<br>    2.可以按照数组的方式遍历arguments<br>    3.只有函数才有arguments对象，每个函数都内置此对象<br>一般形参和实参数量匹配，arguments用的不多</p><h1 id="六、函数可以相互调用"><a href="#六、函数可以相互调用" class="headerlink" title="六、函数可以相互调用"></a>六、函数可以相互调用</h1><p>可以在一个函数内调用另外一个函数<br>函数可以 以参数的形式 传递，称为回调函数</p><p>​                ​            </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/4.%E6%95%B0%E7%BB%84/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/4.%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>什么是数组<br>    数组Array是一组数据的集合存放在单个变量名下，其中每个数据称为数组元素。<br>    数组可以存放任意类型的元素,一般一个数组只存放一种</p><h1 id="二、创建数组"><a href="#二、创建数组" class="headerlink" title="二、创建数组"></a>二、创建数组</h1><p>1.利用new创建数组<br>    <code>var arr = new Array();</code><br>    <code>var arr = new Array(1,2,3,4);</code><br>2.利用数组字面量创建数组 常用方式<br>    <code>var arr = [];   创建空数组</code><br>    <code>var arr = [1, 2, &#39;pink&#39;, true];  创建非空数组</code></p><p>区别： 当new Array()括号里只有一个数字时，代表的是数组的长度</p><h1 id="三、获取数组元素"><a href="#三、获取数组元素" class="headerlink" title="三、获取数组元素"></a>三、获取数组元素</h1><p>1.数组的索引<br>    索引又称作下标，是访问元素的序号，从0开始；<br>    用索引来访问数组元素；<br>2.数组长度<br>    arr.length 数组元素的个数  会自动检测数组元素的变化改变length大小<br>    与索引的关系： <code>arr.length - 1 = 数组最大索引值</code><br>3.遍历数组<br>    把数组的每个元素都访问一次，称为数组遍历<br>    利用循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  <span class="comment">//i当索引使用</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、增加-修改-删除数组元素"><a href="#四、增加-修改-删除数组元素" class="headerlink" title="四、增加/修改/删除数组元素"></a>四、增加/修改/删除数组元素</h1><p>1.修改数组长度新增元素<br>    数组长度arr.length是可变化的<br>        <code>arr.length = 5;</code><br>    新增的数组元素是undifined;<br>2.修改索引号新增元素<br>    假设<code>arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];</code><br>    此时索引是0-3，没有4，当设置 <code>arr[4] = &#39;e&#39;</code>时会在后面追加一个新元素e<br>    如果索引号已经占用，会覆盖掉原有的元素，实现修改效果<br>3.清空数组<br>    <code>arr.length = 0或Null;</code></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/3.js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/3.js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>流程控制：控制代码按照什么顺序执行<br>主要有顺序，分支，循环</p><h1 id="一-顺序流程控制"><a href="#一-顺序流程控制" class="headerlink" title="一.顺序流程控制"></a>一.顺序流程控制</h1><p>从上到下，顺序执行</p><h1 id="二-分支流程控制"><a href="#二-分支流程控制" class="headerlink" title="二.分支流程控制"></a>二.分支流程控制</h1><p>根据不同条件，执行不同代码，得到不同结果<br>1） if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式1) &#123;</span><br><span class="line">语句1；</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line">语句2；</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line">语句3；</span><br><span class="line">....</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 上述条件都不成立执行此处代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2） switch 语句</p><p>当要针对变量设置一系列的特定值的选项时，就可以使用 switch语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (表达式) &#123;</span><br><span class="line">case value1:</span><br><span class="line">表达式等于value1时要执行的代码；</span><br><span class="line">break;</span><br><span class="line">case value2:</span><br><span class="line">表达式等于value2时要执行的代码；</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">表达式不等于任何一个value时要执行的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断相等是===，类型和取值全相等才执行下面的语句<br>case后面不要加判断条件，而是确定的值<br>switch括号里的可以是变量或者表达式，一般是变量<br>如果不加break，会执行下一个case里的语句</p><h1 id="三-三元表达式"><a href="#三-三元表达式" class="headerlink" title="三.三元表达式"></a>三.三元表达式</h1><p>表达式是有返回值的</p><p>格式：<code>条件表达式1？表达式2：表达式3</code></p><p>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</p><h1 id="四-循环流程控制"><a href="#四-循环流程控制" class="headerlink" title="四.循环流程控制"></a>四.循环流程控制</h1><h2 id="1-循环的目的"><a href="#1-循环的目的" class="headerlink" title="1.循环的目的"></a>1.循环的目的</h2><p>重复执行某些语句<br>    循环体：被重复执行的代码<br>    终止条件：决定能否继续重复执行的条件</p><h2 id="2-三种循环语句"><a href="#2-三种循环语句" class="headerlink" title="2.三种循环语句"></a>2.三种循环语句</h2><p>1）for循环<br>重复执行某些代码，通常跟计数有关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化变量；条件表达式；操作表达式) &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化变量：用var声明的一个普通变量i，通常用于计数器使用<br>条件表达式：决定每一次循环是否执行，即终止条件<br>操作表达式：每次循环最后执行的代码，常用于 更新 计数器变量i </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i=1;i&lt;=10;i++)&#123;</span><br><span class="line">循环体执行10次;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以重复执行不同的代码，因为有变量i的存在；<br>循环体也可以是for循环，这样称作循环嵌套</p><p>2）while循环<br>一般用于不知道循环次数时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (条件表达式) &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式为真时执行循环体，否则跳出循环；<br>循环体里要有操作表达式，更新计数器变量，防止死循环</p><p>3）do while循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">循环体；</span><br><span class="line">&#125; while (条件表达式)</span><br></pre></td></tr></table></figure><p>先执行一次循环体，再判断条件是否为真继续循环</p><h2 id="3-continue和break关键字"><a href="#3-continue和break关键字" class="headerlink" title="3.continue和break关键字"></a>3.continue和break关键字</h2><p>1）continue<br>跳出本次循环，继续下一次循环<br>2）break<br>跳出整个循环，不再执行其他循环次数</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/2.js%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/2.js%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h1><p>加 减 乘 除 取余<br><code>+  -  *  /  %</code><br>1.浮点数直接运算会出现误差<br>2.不能直接判断两个浮点数是否相等<br>3.取余可以判断一个数能否被整除，余数是0就能整除<br>4.算术运算符优先级 先乘除后加减 有括号先算括号内的</p><h1 id="2-表达式和返回值"><a href="#2-表达式和返回值" class="headerlink" title="2.表达式和返回值"></a>2.表达式和返回值</h1><p>由数字、变量和运算符组成的式子称为表达式<br>表达式的结果称为返回值<br>只要是表达式都有返回值</p><h1 id="3-递增和递减运算符"><a href="#3-递增和递减运算符" class="headerlink" title="3.递增和递减运算符"></a>3.递增和递减运算符</h1><p>递增++ 和 递减– ，必须配合变量使用<br>前置++n: 先加1 后返回值<br>后置n++: 先返回值 后加1<br>单行写的时候没有区别，后面如果还有计算、或者直接输出就有区别</p><h1 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a>4.比较运算符</h1><p>返回结果是boolean型<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/S1Ht9K2Dtd5g.png?imageslim" alt="mark"></p><h1 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5.逻辑运算符"></a>5.逻辑运算符</h1><p>用布尔值进行运算，返回值也是布尔值<br><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/GgYJtyVxg3U3.png?imageslim" alt="mark"></p><h1 id="6-逻辑中断（短路运算）"><a href="#6-逻辑中断（短路运算）" class="headerlink" title="6.逻辑中断（短路运算）"></a>6.逻辑中断（短路运算）</h1><p>原理：多个表达式进行逻辑运算时，左边的值可以确定时，就不再计算右边的表达式<br>    逻辑与&amp;&amp;：（找错）  表达式1 &amp;&amp; 表达式2<br>        如果有false，输出此false，如果没有，返回最后一个表达式<br>    逻辑或||：（找对） 表达式1 || 表达式2<br>        如果有true，输出此true，如果没有，返回最后一个表达式</p><h1 id="7-赋值运算符"><a href="#7-赋值运算符" class="headerlink" title="7.赋值运算符"></a>7.赋值运算符</h1><p><code>=  +=  -=  *=  /=  %=</code><br>n+=2 等价于 n = n + 2</p><h1 id="8-运算符优先级"><a href="#8-运算符优先级" class="headerlink" title="8.运算符优先级"></a>8.运算符优先级</h1><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/vfjyozcab6V1.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和数据类型</title>
      <link href="/2017/05/13/1.js%E5%9F%BA%E7%A1%80/1.%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/05/13/1.js%E5%9F%BA%E7%A1%80/1.%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、js介绍"><a href="#一、js介绍" class="headerlink" title="一、js介绍"></a>一、js介绍</h1><h2 id="1-为什么学习JavaScript"><a href="#1-为什么学习JavaScript" class="headerlink" title="1.为什么学习JavaScript"></a>1.为什么学习JavaScript</h2><p>一开始的作用：判断用户的输入，验证表单<br>现在的意义：页面特效、移动端开发、异步和服务器交互ajax、服务端开发 </p><h2 id="2-浏览器是如何工作的"><a href="#2-浏览器是如何工作的" class="headerlink" title="2.浏览器是如何工作的"></a>2.浏览器是如何工作的</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/39XqGt97Enfc.png?imageslim" alt="mark"><br>User Interface: 用户界面<br>Browser engine： 浏览器引擎 查询和操作渲染引擎<br>Rendering engine：渲染引擎 解释执行html和css代码<br>JavaScript Interpreter：js解析器 解释执行javascript<br>Networking：网络 向服务器发送和接收请求<br>UI Backend： UI后端 绘制组合框和弹出窗口<br>Data Persistence：数据持久化 浏览器存储数据 cookie、html5中的sessionStorage</p><h2 id="3-JavaScript语言介绍"><a href="#3-JavaScript语言介绍" class="headerlink" title="3.JavaScript语言介绍"></a>3.JavaScript语言介绍</h2><p>js是脚本语言，不需要编译，边解析边执行。<br>编译：一次性把代码转换成CPU可以读懂的语言，一行一行执行<br>解释：一行一行解析，解析一行执行一行</p><p>js是客户端的脚本语言，因为它运行在浏览器上<br>js是直译型、弱类型、可以跨平台、面对对象开发的语言</p><h2 id="4-JavaScript的组成"><a href="#4-JavaScript的组成" class="headerlink" title="4.JavaScript的组成"></a>4.JavaScript的组成</h2><p>ECMAScript：JavaScript语法规范<br>DOM: JavaScript操作网页元素的API<br>BOM:    JavaScript操作浏览器部分功能的API</p><h1 id="二、js书写位置"><a href="#二、js书写位置" class="headerlink" title="二、js书写位置"></a>二、js书写位置</h1><h2 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h2><p>1.行内式：写在标签内 <code>&lt;button onclick=&quot;alert(&#39;成功&#39;)&quot;&gt; &lt;/button&gt;</code><br>2.内嵌式：写在html文件里面，head之内添加<code>&lt;script&gt;js代码&lt;/script&gt;</code><br>3.外部式：引入 <code>&lt;script src=&quot;main.js&quot;&gt; &lt;/script&gt;</code> 中间不可以再写js代码</p><h2 id="script标签的属性"><a href="#script标签的属性" class="headerlink" title="script标签的属性"></a>script标签的属性</h2><p>src: script文件路径<br>type: 默认是text/javascript 可以省略<br>async: 异步，并列执行 取值仅有一个值async<br>sync： 同步，线性执行<br>differ: 异步执行，在整个html文档都执行完之后再执行外部脚本，只有外部脚本可以使用，取值只有differ</p><h1 id="三、js注释"><a href="#三、js注释" class="headerlink" title="三、js注释"></a>三、js注释</h1><p><code>单行 //  快捷键 ctrl+/</code><br>多行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*   </span><br><span class="line">快捷键 修改为 crtl + shift + /</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="四、输入输出语句"><a href="#四、输入输出语句" class="headerlink" title="四、输入输出语句"></a>四、输入输出语句</h1><p>输入语句：<br><code>prompt(&quot;提示信息&quot;,&quot;默认值&quot;); 浏览器弹出输入框,取到的值是字符型的</code></p><p>输出语句：<br><code>alert(msg);</code> 浏览器弹出警示框 比如弹出变量值 <code>alert(&#39;变量值是&#39; + num);</code><br><code>console.log(msg);</code> 浏览器控制台打印输出日志 想要输出多个变量 用逗号分隔<br><code>document.write(&quot;&quot;);</code> 输出内容 在浏览器中显示 换行是用<code>&lt;br /&gt;</code></p><h1 id="五、变量"><a href="#五、变量" class="headerlink" title="五、变量"></a>五、变量</h1><h2 id="1-变量："><a href="#1-变量：" class="headerlink" title="1.变量："></a>1.变量：</h2><p>存放数据的容器，通过变量名获取数据<br>变量是在内存中存放数据的空间 </p><h2 id="2-定义变量两种方式："><a href="#2-定义变量两种方式：" class="headerlink" title="2.定义变量两种方式："></a>2.定义变量两种方式：</h2><p><code>var 变量名=值；</code><br><code>var 变量名； 变量名=值；</code><br>也可以一次声明多个变量 var name,age,sex；</p><p>只声明不赋值，该值是undifined<br>只赋值不声明，浏览器会根据赋值自动声明<br>既不声明也不赋值，会报错</p><p>定义变量后，存储在内存中，基本变量存储在栈中，复杂变量存储在堆中</p><h2 id="3-变量命名："><a href="#3-变量命名：" class="headerlink" title="3.变量命名："></a>3.变量命名：</h2><ul><li>变量命名规则：<br> 1.由字母、数字、下划线和$组成，开头不能是数字<br> 2.不能是关键字和保留字，不使用name<br> 3.区分大小写</li><li>变量命名规范：<br> 1.命名要有意义<br> 2.遵守驼峰命名法，首字母小写，其他单词第一个字母大写</li></ul><p><strong>练习</strong>  交换两个变量的值<br>    两种办法：使用中间变量、不使用中间变量</p><h2 id="4-获取变量类型"><a href="#4-获取变量类型" class="headerlink" title="4.获取变量类型"></a>4.获取变量类型</h2><p>使用<code>变量.typeof</code>方法</p><h1 id="六、简单数据类型"><a href="#六、简单数据类型" class="headerlink" title="六、简单数据类型"></a>六、简单数据类型</h1><h2 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h2><p>js是动态语言，数据类型是可以变化的。变量的数据类型是在程序运行过程中确定的，根据等号右边的值</p><h2 id="2-简单数据类型："><a href="#2-简单数据类型：" class="headerlink" title="2.简单数据类型："></a>2.简单数据类型：</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/3FR5jRw30AaQ.png?imageslim" alt="mark"></p><p>1）number 数字型<br>        取值可以是整数或者小数，也可以是各种进制的数。0开头是八进制数，0x开头是十六进制数<br>        js里面数字有最大值和最小值： Number.MAX_VALUE Number.MIN_VALUE<br>        数字型三个特殊值： 无穷大 Infinity  无穷小 -Infinity  非数字 NaN（not a number）<br>        isNaN() 方法用来判断变量是不是非数字<br>            如果不是数字返回true，如果是数字或者能转换成数字，则返回false<br>            NaN和任何值都不相等，包括它自己。</p><p>2）string 字符串型<br>        取值必须加引号，引号可以是””，也可以是’’， 推荐使用单引号<br>        字符串嵌套时要使用不同的引号，外双内单或者外单内双<br>        转义字符：<br>        <img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/MBHUChas60WJ.png?imageslim" alt="mark">    </p><pre><code>转义字符只适用于console.log()的输出document.write() 换行使用br字符串长度属性： str.length       str[索引] 获取字符串的第几个字符 索引从0开始字符串拼接： newstr = str1 + str2;  数值相加，字符相连字符串和不同类型的值也可以拼接，结果都是字符串类型</code></pre><p>boolean和数字运算时，false和true 取值为0和1<br>undifined和数字相加结果是NaN<br>null和数字相加仍为原数字,null是对象类型</p><h1 id="七、数据类型转换"><a href="#七、数据类型转换" class="headerlink" title="七、数据类型转换"></a>七、数据类型转换</h1><p>chrome控制台输出蓝色是数字型，黑色是字符串型</p><h2 id="1-转换成字符串型"><a href="#1-转换成字符串型" class="headerlink" title="1.转换成字符串型"></a>1.转换成字符串型</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/rIMS8zHNmz8y.png?imageslim" alt="mark"></p><p> 变量.toString()  里面的变量要先声明<br> String(变量或值)  强制转换<br> 隐式转换：和字符串相加</p><h2 id="2-转换为数字型"><a href="#2-转换为数字型" class="headerlink" title="2.转换为数字型"></a>2.转换为数字型</h2><p><img src="https://blog-1259330568.cos.ap-shanghai.myqcloud.com/20190526/my2vtLI6YeL7.png?imageslim" alt="mark"><br>    parseInt(字符串)     把字符串转换成整数，取整且去掉字母（开头要是数字）<br>    parseFloat(字符串)    把字符串转换成浮点数，去掉字母（开头要是数字）<br>        parseInt和parseFloat括号里可以逗号+进制 这样会把字符串转换为指定进制的数字<br>    Number(变量)     把变量变成数字型，变量有字母结果就是NaN，null转换为0<br>    隐式转换 在变量前面加+号、 -0 、* 1 、/ 1；</p><h2 id="3-转换为boolean类型"><a href="#3-转换为boolean类型" class="headerlink" title="3.转换为boolean类型"></a>3.转换为boolean类型</h2><p>Boolean(变量)<br>    转换为false的情况： 变量是 0 、 NaN 、 undefined 、null 、”” 、false<br>    其他都是true<br>隐式转换： !!变量</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
